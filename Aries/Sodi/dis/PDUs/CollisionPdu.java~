/*
 File:		CollisionPdu.java
 CVS Info:	$Id: CollisionPdu.java,v 1.2 1998/01/27 18:43:58 mcgredo Exp $
 Compiler:	jdk 1.3
 */

package PDUs;                        // package to which we belong

import mil.navy.nps.util.*;         // General-purpose utilities
import mil.navy.nps.disEnumerations.*;         // Enumerations for DIS

import java.lang.*;
import java.util.*;                              // utility stuff we need
import java.io.*;                                // input/output for serialization

/**
 * Report collision between entities.
 *
 *@version 1.0
 *@author <a href="mailto:mcgredo@cs.nps.navy.mil"> Don McGregor</a> (<a href="http://www.npsnet.org/~mcgredo">http://www.npsnet.org/~mcgredo</a>)
 *
 *<dt><b>Location:</b>
 *<dd>Web:  <a href="http://www.web3d.org/WorkingGroups/vrtp/mil/navy/nps/dis/CollisionPdu.java">
 *  http://www.web3d.org/WorkingGroups/vrtp/mil/navy/nps/dis/CollisionPdu.java</a>
 *
 *<dd>or locally:  <a href="../../../../../../mil/navy/nps/dis/CollisionPdu.java">
 *  ~/mil/navy/nps/dis/CollisionPdu.java</a>
 *
 *<dt><b>Hierarchy Diagram:</b>
 *<dd><a href="../../../../../../dis-java-vrml/images/PduClassHierarchy.jpg"><IMG SRC="../../../../../../dis-java-vrml/images/PduClassHierarchyButton.jpg" ALIGN=ABSCENTER WIDTH=150 HEIGHT=21></a>
 *
 *<dt><b>Summary:</b>
 *<dd>Collisions between entities shall be communicated by issuing a Collision PDU.
 *
 *<dt><b>Explanation:</b>
 *<dd>   The collision pdu denotes the collision between two entities. It inherits 
 *  the header information from ProtocolDataUnit, an abstract class that contains
 *  assorted protocol information. It implements the IDs of the issuing entity, 
 *  the colliding entity, the event, and where the impact occurred with respect 
 *  to the issuing entity.<P>
 *  As with other PDUs, it knows how to serialize and deserialize itself
 *  from the wire. It also knows how to clone itself, and knows how to
 *  calculate its size when sent to the wire.<P>
 *
 *<dt><b>Note:</b>
 *<dd>   Here we don't have any padding field, because it isn't used in DIS. However, it is serialized and deSerialized
 * when written to the wire.
 * Also note that we have not created accessor methods for the nested fields.
 *
 *<dt><b>History:</b>
 *<dd>		10Sep97	/JPL			/New
 *<dd>		8Dec97	/Ronan Fauglas		/changes for documentation templates + complements in documentation
 *<dd>		11Dec97	/Ronan Fauglas		/changed access methods: thisVariable() --> getThisVariable()
 *<dd>          15Nov99 /Christian Taranti      /Revised and added commends. Javadoc compliant.
 *
 *<dt><b>References:</b>
 *<dd>		DIS-Java-VRML Working Group: <a href="http://www.web3d.org/WorkingGroups/vrtp/dis-java-vrml/">http://www.web3d.org/WorkingGroups/vrtp/dis-java-vrml/</a>
 *<dd>		DIS Data Dictionary:<a href="http://SISO.sc.ist.ucf.edu/dis-dd/pdu/77.htm">Collision PDU</a>	
 *<dd>		DIS specification: IEEE 1278.1, Section 4.4.2.2, 5.4.3.2
 *
 *@see EntityStatePdu
 *@see PduElement 
 *@see ProtocolDataUnit
 *@see SerializationInterface
 *@see mil.navy.nps.disEnumerations.CollisionTypeField
 */
public class CollisionPdu extends ProtocolDataUnit 
{

    /**
     *Issuing Entity ID - This field shall identify the entity that is issueing the Pdu
     */
    protected EntityID        issuingEntityID;   // ID of entity that noticed collision

    /**
     *Colliding Entity ID -  This field shall identify the entity that has collided with the issuing entity.
     *
     *<dl>
     *<dt><b>Value:</b>
     *<dd> If the entity ID is unknown or the collision is with a terrain object, this field shall contain 
     *ENTITY_ID_UNKNOWN.
     *</dl>
     */
    protected EntityID        collidingEntityID; // ID of entity that was hit

    /**
     *Event ID - this field shall contain an identification generated by the issuing simulation application
     * to associate related collision events.
     */
    protected EventID         eventID;           // ID of event

    /**
     * Collision Type - This field shall identify the type of collision.
     *
     *<dl>
     *<dt><b>Value:</b>
     *<dd>Enumeration, see references below for semantics.
     *<dt><b>References:</b>
     *<dd>	see Section 10 in the EBV-doc
     *</dl>
     */
    protected UnsignedByte    collisionType;     // collision modeling info

    /**
     *Velocity - [m/s] This field shall contain the velocity of the issuing entity (at the time the collision is detected). 
     *<dl>
     *<dt><b>Value:</b>
     *<dd>The velocity shall be represented in world Coordinates.
     *</dl>
     */
    protected LinearVelocity        velocity;          // Velocity of issuing entity

    /**
     *Mass - [kg] this field shall contain the mass of the issuing entity.
     *<dl>
     *<dt><b>Value:</b>
     *<dd>In kilograms.
     *</dl>     
     */
    protected float           mass;              // Mass of issuing entity

    /**
     *Location - [m,m,m] This field shall specify the location of the collision with respect to the entity 
     *with which the issuing entity collided.
     */
    protected EntityCoordinate  location;          // x,y,z location of impact, in 32 bit coords

    /**
     *Constant value- [bytes] size of an collision PDU without headder.
     *<code>sizeOf = 60 bytes</code>
     */
    public static final int   sizeOf = 60;       // size of CollisionPDU (bytes), AS WRITTEN TO WIRE

/**
 *Default constructor--fills with zeros for all values.
 */
public CollisionPdu()
{
    super.setPduType(PduTypeField.COLLISION);

    issuingEntityID    = new EntityID();
    collidingEntityID  = new EntityID();
    eventID            = new EventID();
    collisionType      = new UnsignedByte();
    velocity     = new LinearVelocity();
    mass               = (float)0.0;
    location           = new EntityCoordinate();
}


public Object clone()
{
    /** make a deep copy, so we don't have two objects sharing pointers to the same data (see details).
     * The cloning makes possible to have two PDUs describing the same event but with different values.
     * The user of this function is advised, therefore, to take proper care when using the return value
     * of this function.
     */
 CollisionPdu  newCollisionPdu = (CollisionPdu)super.clone();

 newCollisionPdu.setIssuingEntityID(this.getIssuingEntityID());
 newCollisionPdu.setCollidingEntityID(this.getCollidingEntityID());
 newCollisionPdu.setEventID(this.getEventID());
 newCollisionPdu.setCollisionType(this.getCollisionType());
 newCollisionPdu.setLinearVelocity(this.getLinearVelocity());
 newCollisionPdu.setMass(this.getMass());
 newCollisionPdu.setLocation(this.getLocation());

 return newCollisionPdu;
}


/**
 *@exception RuntimeException when IO error occurs.
 */
public void serialize(DataOutputStream outputStream)
{
    /** write the data to an output stream in the order specified by the DIS
        standard. */

    UnsignedByte   padding = new UnsignedByte(0);

    super.serialize(outputStream);      // write out header info

    issuingEntityID.serialize(outputStream);
    collidingEntityID.serialize(outputStream);
    eventID.serialize(outputStream);
    collisionType.serialize(outputStream);
    padding.serialize(outputStream);
    velocity.serialize(outputStream);
    try {
      outputStream.writeFloat(mass);
    }
    catch(IOException ioError) {
       throw new RuntimeException("Exception in CollisionPdu. Error writing to wire.");
    }
    location.serialize(outputStream);

    return;
}


/**
 *@exception RuntimeException when IO error occurs.
 */
public void deSerialize(DataInputStream inputStream)
{
    /**
    deserialize the data from the input stream. By calling the superclass,
    the data is read into the buffer first.  Then we deserialize each of our 
    ivars to the appropriate variable stream in the order specified by the DIS
    standard. */

    UnsignedByte   padding = new UnsignedByte(0);

    super.deSerialize(inputStream);

    issuingEntityID.deSerialize(inputStream);
    collidingEntityID.deSerialize(inputStream);
    eventID.deSerialize(inputStream);
    collisionType.deSerialize(inputStream);
    padding.deSerialize(inputStream);
    velocity.deSerialize(inputStream);
    try {
       mass = inputStream.readFloat();
    }
    catch (IOException ioError) {
       throw new RuntimeException("Exception in CollisionPdu. Error reading from wire.");
    }
    location.deSerialize(inputStream);

    return;
}

/** returns the size of the class (return sizeOf)
*/

public int length()
{  return sizeOf;  }

/** returns new String("Collision PDU").
The string is allocated dynamically. 
*/
public String pduName()
{  return new String("Collision PDU");  }


/** Prints the valules of the PDU fields. this is important for debugging.
*/
public void printValues(int indentLevel, PrintStream printStream)
{
    /** print the values of the object out, with correct level of
        indentation on the page. */

    StringBuffer indent = ProtocolDataUnit.getPaddingOfLength(indentLevel);
    int idx, superclassIndent = indentLevel;

    printStream.println();
    printStream.println("Collision PDU-");

    if(superclassIndent > 0)
      superclassIndent -= 1;

    super.printValues(superclassIndent, printStream);

    issuingEntityID.printValues(indentLevel, printStream);
    collidingEntityID.printValues(indentLevel, printStream);
    eventID.printValues(indentLevel, printStream);
    printStream.println(indent + "Collision type: "   + collisionType.intValue());
    velocity.printValues(indentLevel, printStream);
    printStream.println(indent + "Mass: "   + mass);
    location.printValues(indentLevel, printStream);

    return;
}


//Accessor methods
/** Returns the ID of the issuing entity.
*/
public EntityID getIssuingEntityID()
{  return (EntityID)issuingEntityID.clone();  }

/** Sets the ID of the issuing entity.
*/
public void setIssuingEntityID(EntityID pIssuingEntityID)
{  issuingEntityID = pIssuingEntityID;  }

/** Returns the ID of the colliding entity.
*/
public EntityID getCollidingEntityID()
{  return (EntityID)collidingEntityID.clone();  }

/** Sets the ID of the colliding entity.
*/
public void setCollidingEntityID(EntityID pCollidingEntityID)
{  collidingEntityID = pCollidingEntityID;  }


/** Returns the ID of the event.
*/
public EventID getEventID()
{  return (EventID)eventID.clone();  }

/** Sets the ID of the event.
*/
public void setEventID(EventID pEventID)
{  eventID = pEventID;  }

/** Returns the type of the collision.
*/
public UnsignedByte getCollisionType()
{  return (UnsignedByte)collisionType.clone();  }

/** Sets the type of the collision.
*/
public void setCollisionType(mil.navy.nps.util.UnsignedByte pCollisionType)
{  collisionType = pCollisionType;  }



/** Returns the linear velocity (safe deep copy).
*/
public LinearVelocity getLinearVelocity()
{  return (LinearVelocity)velocity.clone();  }

/** Sets the linear velocity given a lienar velocity
*/
public void setLinearVelocity(LinearVelocity pLinearVelocity)
{  velocity = pLinearVelocity;  }

/** Sets the linear velocity given each of the xyz velocities
*/
public void setLinearVelocity(float x, float y, float z)
{  velocity = new LinearVelocity(x, y, z);  }


/** Returns the mass of the colliding entity
*/
public float getMass()
{  return mass;  }

/** Sets the mass of the colliding entity
*/
public void setMass(float pMass)
{  mass = pMass;  }


/** Returns location of the colliding entity (safe deep copy).
*/
public EntityCoordinate getLocation()
{  return (EntityCoordinate)location.clone();  }

/** Sets location of the colliding entity.
*/
public void setLocation(EntityCoordinate pLocation)
{  location = pLocation;  }

/** Sets location of the colliding entity given (x,y,z).
*/
public void setLocation(float x, float y, float z)
{  location = new EntityCoordinate(x, y, z);  }

} // end of class CollisionPdu

