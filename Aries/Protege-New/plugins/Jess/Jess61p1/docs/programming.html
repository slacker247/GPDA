<html>

<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Jess, the Java Expert System Shell - Programming in the Jess Language</title>
<link title="style" href="stylesheet.css" type="text/css" rel="stylesheet">
</head>
<body>
<h2>3.
        Programming in the Jess Language</h2>

Useful expert systems can be written using the Jess
language, with no extensions. I won't present a tutorial on writing
such systems here (maybe someday!), but I do want to share a few
useful hints and ideas in the following sections.



<a name="editor">
<h3>3.1. Using an External Editor</h3>
</a>
Jess allows you to enter rules and other code directly at its interactive prompt. While
this is fine for experimenting, Jess doesn't yet have the ability to save
the source text for all the rules and constructs you enter. Therefore,
you will typically enter your rules and other data into a separate script
file and read it into Jess using the <a href="functions.html#batch"><tt>batch</tt></a> command. Jess does
offer the <a href="functions.html#ppdefrule"><tt>ppdefrule</tt></a> and <a href="functions.html#save-facts"><tt>save-facts</tt></a> commands, both of
which can be very helpful in interactively building up a system definition
and then storing it in a file. Note that you might use the
<a href="functions.html#system"><tt>system</tt></a> command to start the external editor from within Jess,
if desired. 




<a name="efficiency">
<h3>3.2. Efficiency of rule-based systems</h3>
</a>

The single biggest determinant of Jess performance is the number of <i>partial
matches</i> generated by your rules. You should always try to obey the
following (sometimes contradictory) guidelines while writing your rules:
<ul>

<li>
Put the <i>most specific</i> patterns (those that will match the fewest
facts) near the top of each rule's LHS.</li>


<li>
Put the <i>most transient</i> patterns (those that will match facts that
are frequently retracted and asserted) near the bottom of a LHS.</li>

</ul>
You can use the <a href="functions.html#view"><tt>view</tt></a> command to find out how
many partial matches your rules generate. See this chapter on
<a href="rete.html">How Jess Works</a> for more details.



<a name="errors">
<h3>3.3. Error Reporting and Debugging</h3>
</a>

I'm constantly trying to improve Jess's error reporting,
but it is still not perfect. When you get an error from
Jess (during parsing or at runtime) it is generally delivered as a Java
exception. The exception will contain an explanation of the problem and
the stack trace of the exception will help you understand what went wrong.
For this reason, it is <i>very important</i> that, if you're embedding
Jess in a Java application, you don't write code like this:

<pre>
        try
        {
          Rete engine = new Rete();
          engine.executeCommand("(gibberish!)");
        }
        catch (JessException re) { /* ignore errors */ }
</pre>

If you ignore the Java exceptions, you will miss Jess's explanations
of what's wrong with your code. Don't laugh - more people code this
way than you'd think!
 <p align=""></p>
Anyway, as an example, if you attempt to load the folowing rule in the
standard Jess command-line executable,

<pre>
        Jess&gt; (defrule foo-1
                (foo bar)
                -&gt;
                (printout "Found Foo Bar" crlf))
</pre>

You'll get the following printout:

<pre>
  Jess reported an error in routine Jesp.parseDefrule.
    Message: Expected '=&gt;' .
    Program text: ( defrule foo-1 ( foo bar ) -&gt;  at line 2.
          at jess.Jesp.parseError(Jesp.java:1434)
          at jess.Jesp.doParseDefrule(Compiled Code)
          at jess.Jesp.parseDefrule(Jesp.java:882)
          at jess.Jesp.parseSexp(Jesp.java:153)
          at jess.Jesp.parse(Compiled Code)
          at jess.Main.execute(Compiled Code)
          at jess.Main.main(Main.java:26)
</pre>

This exception, like all exceptions reporte by Jess, lists a Java
routine name. The name <tt>parseDefrule</tt> makes it fairly clear
that a rule was being parsed, and the detail message explains
that <tt>-&gt;</tt> was found in the input instead of the expected
<tt>=&gt;</tt> symbol (we accidentally typed <tt>-&gt;</tt> instead). This
particular error message, then, was fairly easy to understand.

<p align=""></p>Runtime errors can be more puzzling, but the printout will
generally give you a lot of information. Here's a rule where we
erroneously try to add the number <tt>3.0</tt> to the word <tt>four</tt>:
<pre>
        Jess&gt; (defrule foo-2
                =&gt;
              (printout t (+ 3.0 four) crlf))
</pre>

This rule will compile fine, since the parser doesn't know that the
<tt>+</tt> function won't accept the atom <tt>four</tt> as an argument.
When we <tt>(reset)</tt> and <tt>(run)</tt>, however,  we'll see:

<pre>
Jess reported an error in routine Value.numericValue
  while executing (+ 3.0 four) while executing (printout t (+ 3.0 four) crlf)
  while executing defrule foo-2 while executing (run).
  Message: Not a number: "four" (type = ATOM).
  Program text: ( run )  at line 4.
        at jess.Value.typeError(Value.java:361)
        at jess.Value.typeError(Value.java:356)
        at jess.Value.numericValue(Value.java:244)
        at jess.Plus.call(Compiled Code)
        at jess.FunctionHolder.call(FunctionHolder.java:35)
        at jess.Funcall.execute(Funcall.java:238)
        at jess.FuncallValue.resolveValue(FuncallValue.java:33)
        at jess.Printout.call(Compiled Code)
        at jess.FunctionHolder.call(FunctionHolder.java:35)
        at jess.Funcall.execute(Funcall.java:238)
        at jess.Defrule.fire(Compiled Code)
        at jess.Activation.fire(Activation.java:58)
        at jess.Rete.run(Compiled Code)
        at jess.Rete.run(Compiled Code)
        at jess.HaltEtc.call(Funcall.java:1559)
        at jess.FunctionHolder.call(FunctionHolder.java:35)
        at jess.Funcall.execute(Funcall.java:238)
        at jess.Jesp.parseAndExecuteFuncall(Jesp.java:1423)
        at jess.Jesp.parseSexp(Jesp.java:172)
        at jess.Jesp.parse(Compiled Code)
        at jess.Main.execute(Compiled Code)
        at jess.Main.main(Main.java:26)
</pre>

In this case, the error message is also pretty clear. It shows the
offending function (+ 3.0 four) then the function that called that (printout) then the
context in which the function was called (defrule foo-2), and finally
the function which caused the rule to fire (run). 
<p align=""></p>
Looking at the stack trace, starting from the top down, you can find
entries for the <tt>+</tt> fucntion (<tt>Plus.call()</tt>), the
<tt>printout</tt> function, the rule firing
(<tt>Defrule.fire()</tt>) and the <a href="functions.html#run"><tt>run</tt></a> command (<tt>Rete.run()</tt>).

<p align=""></p>The message 'Not a number: "four" (type = ATOM).' tells you that
the <tt>+</tt> function wanted a numeric argument, but found the
symbol (or ATOM) <tt>four</tt> instead.

<p align=""></p>
If we make a similar mistake on the LHS of a rule:
<pre>
        Jess&gt; (defrule foo-3
                (test (eq 3 (+ 2 one)))
                 =&gt;
                )
</pre>
We see the following after a <tt>reset</tt>:
<pre>
  Jess reported an error in routine Value.numericValue
    while executing (+ 2 one) while executing (eq 3 (+ 2 one))
    while executing 'test' CE while executing rule LHS (TECT) while executing (reset).
    Message: Not a number: "one" (type = ATOM).
    Program text: ( reset )  at line 4.
        at jess.Value.typeError(Value.java:361)
        at jess.Value.typeError(Value.java:356)
        at jess.Value.numericValue(Value.java:244)
        at jess.Plus.call(Compiled Code)
        at jess.FunctionHolder.call(FunctionHolder.java:35)
        at jess.Funcall.execute(Funcall.java:238)
        at jess.FuncallValue.resolveValue(FuncallValue.java:33)
        at jess.Eq.call(Compiled Code)
        at jess.FunctionHolder.call(FunctionHolder.java:35)
        at jess.Funcall.execute(Funcall.java:238)
        at jess.FuncallValue.resolveValue(FuncallValue.java:33)
        at jess.Test1.doTest(Test1.java:95)
        at jess.NodeJoin.runTests(Compiled Code)
        at jess.NodeJoin.callNode(Compiled Code)
        at jess.Node.passAlong(Compiled Code)
        at jess.Node1TECT.callNode(Compiled Code)
        at jess.Rete.processTokenOneNode(Rete.java:1009)
        at jess.Rete.processToken(Compiled Code)
        at jess.Rete.assert(Rete.java:754)
        at jess.Rete.reset(Rete.java:680)
        at jess.HaltEtc.call(Funcall.java:1565)
        at jess.FunctionHolder.call(FunctionHolder.java:35)
        at jess.Funcall.execute(Funcall.java:238)
        at jess.Jesp.parseAndExecuteFuncall(Jesp.java:1423)
        at jess.Jesp.parseSexp(Jesp.java:172)
        at jess.Jesp.parse(Compiled Code)
        at jess.Main.execute(Compiled Code)
        at jess.Main.main(Main.java:26)
</pre>

Again, the error message is very detailed, and makes it clear, I hope,
that the error occurred during rule LHS execution, in a <tt>test</tt>
CE, in the function <tt>(+ 2 one).</tt> Note that Jess cannot tell you
which rule this LHS belongs to, since rule LHSs can be shared. 





<a name="equals_and_hashcode">
<h3>3.4. Putting Java Objects into          Fact Slots</h3>
</a>

You can easily put Java objects into the slots of Jess facts, as
described elsewhere in this document. This section describes some
minimal requirements for objects used in this way.
<p align=""></p>
Jess uses the <tt>equals</tt> and <tt>hashCode</tt> methods of any
objects added to a slot in a Jess fact. As such, it is very important
that these methods be implemented properly. The Java API documentation
lists some important properties of <tt>equals</tt> and
<tt>hashCode</tt>, but I will reiterate the most important (and most
often overlooked) one here: if you write <tt>equals</tt>, you probably
<i>must</i> write <tt>hashCode</tt> too. For any two instance of a
class for which <tt>equals</tt> returns <tt>true</tt>,
<tt>hashCode</tt> must return the same value. If this rule is not
observed, Jess will appear to malfunction when processing facts
containing these improperly defined objects in their slots. In
particular, rules that should fire may not do so.


<p>
<i><a href="index.html">Back to index</a></i>
</p>
</body>

</html>
