\input texinfo  @c -*-texinfo-*-
@c Copyright 1995-2002 MySQL AB
@c
@c This manual is NOT distributed under a GPL style license.
@c Use of the manual is subject to the following terms:
@c - Conversion to other formats is allowed, but the actual
@c   content may not be altered or edited in any way.
@c - You may create a printed copy for your own personal use.
@c - For all other uses, such as selling printed copies or
@c   using (parts of) the manual in another publication,
@c   prior written agreement from MySQL AB is required.
@c
@c Please e-mail docs@mysql.com for more information or if
@c you are interested in doing a translation.
@c
@c *********************************************************
@c Note that @node names are used on our web site.
@c So do not change node names without checking
@c Makefile.am and SitePages first.
@c *********************************************************
@c
@c %**start of header

@setfilename manual.info

@c We want the types in the same index
@c syncodeindex tp fn

@c Get version information. This file is generated by the Makefile!!
@include include.texi

@ifclear tex-debug
@c This removes the black squares in the right margin
@finalout
@end ifclear

@c Set background for HTML
@set _body_tags BGCOLOR=#FFFFFF TEXT=#000000 LINK=#003366 VLINK=#001933 ALINK=#FF0000
@c Set some style elements for the manual in HTML form. 'suggested'
@c natural language colors: aqua, black, blue, fuchsia, gray, green,
@c lime, maroon, navy, olive, purple, red, silver, teal, white, and
@c yellow. From Steeve Buehler <ahr@YogElements.com>
@set _extra_head <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style>

@settitle MyODBC Reference Manual for version @value{myodbc3_version}

@c We want single-sided heading format, with chapters on new pages. To
@c get double-sided format change 'on' below to 'odd'
@setchapternewpage on

@paragraphindent 0

@c %**end of header

@ifinfo
@format
START-INFO-DIR-ENTRY
* manual: (manual).               MyODBC 3 documentation.
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@titlepage
@sp 10
@center @titlefont{MyODBC Programmer's Reference Manual}
@sp 10
@center Copyright @copyright{} 1995-2002 MySQL AB
@center   @uref{http://www.mysql.com}
@c blank page after title page makes page 1 be a page front.
@c also makes the back of the title page blank.
@page
@end titlepage

@c Short contents, blank page, long contents.
@c until i can figure out the blank page, no short contents.
@c @shortcontents
@c @page
@c @page
@contents

@c This should be added. The HTML conversion also needs a MyODBC version
@c number somewhere.

@iftex
@c change this to double if you want formatting for double-sided
@c printing
@headings single

@oddheading @thischapter @| @| @thispage
@evenheading @thispage @| @| MyODBC Programmer's Reference Manual 
for Version @value{myodbc3_version}

@end iftex


@node Top, Introduction, (dir), (dir)

@ifinfo
This is the manual of the MyODBC driver, which provides ODBC 3.51 
compliant access to the MySQL Database System. 
This version is about the @value{myodbc3_version} version of 
MyODBC. You can find a specific manual for any older version of 
MyODBC in the binary or source distribution for that version.
@end ifinfo



@menu
* Introduction::                Introduction
* General Information::         General Information About ODBC and MyODBC 3.51
* Developing Applications Using MyODBC::  Developing Applications Using MyODBC
* MyODBC API Reference::        MyODBC API Reference
* MyODBC Data Types::           MyODBC Data Types
* MyODBC Error Codes::          MyODBC Error Codes
* MyODBC With VB::              MyODBC with ADO, DAO and RDO
* MyODBC With .NET::            
* Credits::                     
* GPL license::                 GNU GENERAL PUBLIC LICENSE
@end menu

@node Introduction, General Information, Top, Top
@chapter Introduction

@menu
* What is MySQL::               What is MySQL
* What is MySQL AB::            What is MySQL AB
* What is MyODBC::              What is MyODBC
* What is MyODBC 3.51::         What is MyODBC 3.51
* About This Manual ::          About This Manual
* Intended Audience ::          Intended Audience
@end menu

@node What is MySQL, What is MySQL AB, Introduction, Introduction
@section What is MySQL
@code{MySQL}, the most popular Open Source SQL database, is developed
and provided by @code{MySQL AB}. @code{MySQL AB} is a commercial company
that builds its business providing services around the @code{MySQL} database.
The @code{MySQL} web site (@uref{http://www.mysql.com/}) provides
the latest information about @code{MySQL} software and @code{MySQL AB}.



@node What is MySQL AB, What is MyODBC, What is MySQL, Introduction
@section What is MySQL AB
@code{MySQL AB} is the Swedish company owned and run by the @code{MySQL}
founders and main developers. We are dedicated to developing @code{MySQL}
and spreading our database to new users. @code{MySQL AB} owns the
copyright to the @code{MySQL} server source code and the @code{MySQL}
trademark. A significant amount of revenues from our services goes to
developing @code{MySQL}.



@node What is MyODBC, What is MyODBC 3.51, What is MySQL AB, Introduction
@section What is MyODBC

@code{@strong{MyODBC 2.50}} is a 32-bit ODBC Driver from @code{@strong{MySQL AB}},
which is based on @strong{ODBC 2.50 specification} Level 0 (with level 1 and 2 
features). This is one of the most popular ODBC Driver in the open source 
market, used by many users to access the MySQL functionality.


@node What is MyODBC 3.51, About This Manual , What is MyODBC, Introduction
@section What is MyODBC 3.51
.
@code{@strong{MyODBC 3.51}} is a 32-bit ODBC Driver, also known as MySQL ODBC 
3.51 Driver. This is a enhanced version to the existing MyODBC 2.50, with 
@strong{ODBC 3.5x specification} level 1(complete core API + level 2 features) 
in order to continue to provide all functionality of ODBC to access MySQL.


@node About This Manual , Intended Audience , What is MyODBC 3.51, Introduction
@section About This Manual
This manual contains information about the usage of MySQL ODBC Drivers,
MyODBC and MyODBC 3.51, in order to explore MySQL capabilities by means
of ODBC API.

Note, as this manual is a reference to the ODBC programming for the
MySQL ODBC Drivers, not all ODBC concepts and practices may be covered
fully.
The manual is currently available in Texinfo, Info, plain text and HTML
formats,
and is being maintained by Monty Widenius, Venu Anuganti and Arjen Lentz.
For any changes or contributions to the manual, please send a mail to
@email{docs@@mysql.com} or to @email{myodbc@@lists.mysql.com}.




@node Intended Audience ,  , About This Manual , Introduction
@section Intended Audience
This manual assumes a good working knowledge of C, general DBMS knowledge,
and finally, but not least, familiarity with MySQL.
For more information about MySQL functionality and its syntax, refer to
@uref{http://www.mysql.com/documentation/index.html}.



@node General Information, Developing Applications Using MyODBC, Introduction, Top
@chapter General Information About ODBC and MyODBC 3.51
This chapter contains the general information about ODBC and MyODBC.

@menu
* Introduction to ODBC::        Introduction to ODBC
* What is ODBC::                What is ODBC
* ODBC Standard::               How Does ODBC Standardize Database Access
* ODBC Architecture::           
* Types of MySQL ODBC Drivers::  Types of MySQL ODBC Drivers
* Where Can I Get MyODBC::      Where Can I Get MyODBC
* How To Install MyODBC::       How To Install MyODBC
* Supported Platforms::         Supported Platforms
* MyODBC Mailing List::         MyODBC Mailing List
* MyODBC Support ::             MyODBC Support
* Reporting Problems::          How to Report MyODBC Problems or Bugs
* Programs Known to Work With MyODBC::  Programs Known to Work With MyODBC
@end menu



@node Introduction to ODBC, What is ODBC, General Information, General Information
@section Introduction to ODBC
Open Database Connectivity (ODBC) is a widely accepted application-programming
interface (API) for database access. It is based on the Call-Level Interface
(CLI) specifications from X/Open and ISO/IEC for database APIs and uses
Structured Query Language (SQL) as its database access language.

ODBC is designed for maximum interoperability, that is, the ability of a
single application to access different database management systems with
the same source code. Database applications call functions in the ODBC
interface, which are implemented in database-specific modules called
drivers. The use of drivers isolates applications from database-specific
calls. For more information about ODBC, see
@uref{http://www.microsoft.com/data/}.


@node What is ODBC, ODBC Standard, Introduction to ODBC, General Information
@section What is ODBC
Many misconceptions about ODBC exist in the computing world.
To the end user, it is an icon in the Microsoft Windows Control Panel.
To the application programmer, it is a library containing data access
routines. To many others, it is the answer to all database access
problems ever imagined.

First and foremost, ODBC is a specification for a database API.
This API is independent of any one DBMS or operating system;
The ODBC API is language-independent.

The ODBC API is based on the CLI specifications from X/Open and ISO/IEC.
ODBC 3.x fully implements both of these specifications earlier versions
of ODBC were based on preliminary versions of these specifications but
did not fully implement them and adds features commonly needed by
developers of screen-based database applications, such as scrollable
cursors.

The developers of DBMS-specific drivers implement the functions in the
ODBC API.Applications call the functions in these drivers to access data in a
DBMS-independent manner. A Driver Manager manages communication between
applications and drivers.


@node ODBC Standard, ODBC Architecture, What is ODBC, General Information
@section How Does ODBC Standardize Database Access
There are two architectural requirements:

@enumerate
@item
Applications must be able to access multiple DBMSs using the same
source code without recompiling or re-linking.
@item
Applications must be able to access multiple DBMSs simultaneously.
@end enumerate

ODBC solves these problems in the following manner:

@table @strong
@item ODBC is a call-level interface:

To solve the problem of how applications access multiple DBMSs using
the same source code, ODBC defines a standard CLI. This contains all
of the functions in the CLI specifications from X/Open and ISO/IEC
and provides additional functions commonly required by applications.

@*
@item ODBC defines a standard SQL grammar:

In addition to a standard call-level interface, ODBC defines a standard
SQL grammar. This grammar is based on the X/Open SQL CAE specification.
If a statement uses ODBC grammar that is different from DBMS-specific
grammar, the driver converts it before sending it to the data source.
However, such conversions are rare because most DBMSs already use
standard SQL grammar.

@*
@item ODBC provides a Driver Manager to manage simultaneous access to multiple DBMSs:

Although the use of drivers solves the problem of accessing multiple DBMSs
simultaneously, the code to do this can be complex. Applications that are
designed to work with all drivers cannot be statically linked to any drivers.
Instead, they must load drivers at run time and call the functions in them
through a table of function pointers.

The situation becomes more complex if the application uses multiple
drivers simultaneously.
Rather than forcing each application to do this, ODBC provides a
Driver Manager.

The Driver Manager implements all of the ODBC functions mostly as pass-through
calls to ODBC functions in drivers and is statically linked to the application
or loaded by the application at run time.
Thus, the application calls ODBC functions by name in the Driver Manager,
rather than by pointer in each driver.

ODBC exposes a significant number of DBMS features, but does not
require drivers to support all of them.

@end table



@node ODBC Architecture, Types of MySQL ODBC Drivers, ODBC Standard, General Information
@section (My)ODBC Architecture

The MyODBC architecture has mainly 5 components as shown below:

@* @image{Images/myarchitecture}

@table @strong
@item Application:

An application is a program that calls the ODBC API to access the
data from (MySQL) server. The Application communicates with the
Driver Manager or Driver directly using the standard ODBC calls.
The Application does not care, where the data is stored, how it
is stored or even how the system is configured to access the data.
It only needs to know the Data Source Name (DSN).

A number of tasks are common to all applications, no matter how they use ODBC.
These tasks are:
@itemize @bullet
@item Selecting the (MySQL) server and connecting to it.
@item Submitting an SQL statement for execution.
@item Retrieving results (if any).
@item Processing errors.
@item Committing or rolling back the transaction enclosing the SQL statement.
@item Disconnecting from the (MySQL) server.
@end itemize

Because most data access work is done with SQL, the primary task for which
applications use ODBC is to submit SQL statements and retrieve the results (if
any) generated by those statements.

@*
@item Driver manager:

The Driver Manager is a library that manages communication
between application and driver or drivers. It does:
@itemize @bullet
@item Resolves Data Source Names (DSN).
@item Loading and unloading of the drivers.
@item Processes ODBC function calls or passes them to the driver.
@end itemize

@*
@item MyODBC Driver:

MyODBC Driver is a library that implements the functions in the
ODBC API. It processes ODBC function calls, submits SQL requests to MySQL
server, and returns results back to the application. If necessary, the driver
modifies an application's request so that the request conforms to syntax
supported by the MySQL.

@*
@item ODBC.INI:

ODBC.INI is the ODBC configuration file, which stores the driver and
database information required to connect to the server. It is used by
the Driver Manager to determine which driver to be loaded using the
Data Source Name.
Driver uses this to read connection parameters based on the DSN specified.
For more information, @ref{Configuring MyODBC DSN}.

@*
@item MySQL SERVER:

It is the source of data. MySQL is
@itemize @bullet
@item Data base management system (DBMS)
@item Relational database management system (RDBMS)
@item Open Source Software
@end itemize

@end table



@node Types of MySQL ODBC Drivers, Where Can I Get MyODBC, ODBC Architecture, General Information
@section Types of MySQL ODBC Drivers
As described earlier, MySQL AB supports two Open Source ODBC drivers,
namely MyODBC and MySQL ODBC 3.51 Driver, to access MySQL functionality
through the ODBC API.
Note, from this section of the manual onwards, we refer both the drivers
as MyODBC itself, and whenever there is a difference then we keep the
original names.



@node Where Can I Get MyODBC, How To Install MyODBC, Types of MySQL ODBC Drivers, General Information
@section Where Can I Get MyODBC
MySQL AB distributes all its products under General Public License (GPL).
You can get the latest, free copy of MyODBC or MyODBC 3.51 driver
binaries and sources from its website @uref{http://www.mysql.com/}.
For more information about MySQL ODBC Drivers, visit
@uref{http://www.mysql.com/downloads/api-myodbc.html}.



@node How To Install MyODBC, Supported Platforms, Where Can I Get MyODBC, General Information
@section How To Install MyODBC


@menu
* Binary Windows Installation::  Binary Installation on Windows
* Source Windows Installation::  Installing From Source Distribution on Windows
* Source Installation Unix::    Installing From Source Distribution on Unix
* Development Source Tree Installation::  Installing From The Development Source Tree
@end menu



@node Binary Windows Installation, Source Windows Installation, How To Install MyODBC, How To Install MyODBC
@subsection Binary Installation on Windows

To install MyODBC on Windows, you should download the appropriate
distribution file for your operating system from
@uref{http://www.mysql.com/downloads/api-myodbc.html}, unpack it,
and execute the @file{SETUP.EXE} file.



@node Source Windows Installation, Source Installation Unix, Binary Windows Installation, How To Install MyODBC
@subsection Installing From Source Distribution on Windows

@subsubheading Requirements:
@itemize @bullet
@item
@strong{MDAC}, Microsoft Data Access SDK from @uref{www.microsoft.com/data/}
@item
@strong{MySQL client libraries and include files} from 3.23.14 and above.
This is required because MyODBC uses new calls that only exist 
starting from the above library, @uref{http://www.mysql.com/downloads/index.html}
@end itemize


@subsubheading Building MyODBC 3.51:
@code{MyODBC 3.51} distributes its sources with @strong{Makefiles} that uses
@file{nmake}. In the distribution, one can find @file{WIN_Makefile} for building the
release version and @file{WIN_Makefile_debug} for building the Debug version of
driver libraries and DLLs. To build the driver:


First, download and extract the sources to a folder @file{myodbc3-src},
and follow the commands to build and install the release version   

@example
Command> cd myodbc3-src
Command> nmake -f Win_Makefile
Command> nmake -f Win_Makefile install
@end example

@file{nmake -f Win_Makefile} builds the release version of the driver and places
the binaries in sub directory called @file{release}. @file{nmake -f Win_Makefile install} 
installs (copies) the driver DLLs and libraries(@file{myodbc3.dll} and @file{myodbc3.lib}
) to your system directory. Similarly you can build the debug version by making use of 
the Makefile @file{Win_Makefile_Debug} as shown below:

@example
Command> nmake -f Win_Makefile_debug
Command> nmake -f Win_Makefile_debug install
@end example

You can clean and rebuild the driver by using:
@example
Command> nmake -f Win_Makefile clean
Command> nmake -f Win_Makefile install
@end example

@code{NOTE:} Make sure to specify the correct MySQL client libraries and header
files path in the Makefiles. It assumes the default path as @file{C:\mysql\include}
and @file{C:\mysql\lib\opt} for release DLLs and @file{C:\mysql\lib\debug} for 
debug versions. 

@strong{Testing the Driver Libraries:}@*
After the driver libraries are copied to system directory, you can test whether 
the libraries you built are properly built are not by using the samples provided 
in the @file{samples} sub-directory:

@example
Command> cd samples
Command> nmake -f Win_Makefile all
@end example


@subsubheading Building MyODBC 2.50:
@code{MyODBC} distributes its sources as VC Project for windows. One can
build the driver using the direct VC project files (.dsp and .dsw) provided
in the distribution. 



@node Source Installation Unix, Development Source Tree Installation, Source Windows Installation, How To Install MyODBC
@subsection Installing From Source Distribution on Unix
To build the driver yourself on Linux, you need to have:

@subsubheading Requirements:
@itemize @bullet
@item
@strong{MySQL client libraries} and include files from 3.23.14 and above. 
This is required because MyODBC uses new calls that only exist 
starting from the above library, @uref{http://www.mysql.com/downloads/index.html}
@item
The MySQL library must be configured with '--with-thread-safe-client'
libmysqlclient installed as a shared library.
@item
One of the following unix ODBC driver managers:@*
  - @strong{iodbc} 3.0 or later, (http://www.iodbc.org), installed @*
  - @strong{unixodbc} Alpha 3 or later (http://www.unixodbc.org), installed  
@item
If you using a @strong{character set} that isn't compiled into the MySQL
client library (the defaults are:latin1 big5 czech euc_kr gb2312 gbk sjis tis620 
ujis) then you need to install the mysql character definitions from the charsets 
directory into SHAREDIR (default @file{/usr/local/mysql/share/mysql/charsets});
These should already be into place if you have installed the MySQL server on 
the same machine.
@end itemize

Once you have all the required files, unpack the source files to a
separate directory and follow the instructions as given below:

@subsubheading Configuration:

The only required options are
    @code{--with-mysql-libs=DIR}
    @code{--with-mysql-includes=DIR}
Where @code{DIR} is the directory where the mysql libraries and
include files are.

If using @code{iodbc}, if @code{iodbc} is not installed in its default
location (@file{/usr/local}),
you might have to use
    @code{--with-iodbc=DIR} or
If the iODBC headers are not residing in @file{DIR/include},
you can also use
    @code{--with-iodbc-includes=INCDIR}
Same goes for libraries; if they are not in @file{DIR/lib},
use
    @code{--with-iodbc-libs=LIBDIR}

If using @code{unixODBC}, to make @file{configure} look for
@code{unixODBC} instead of @code{iODBC}, use
    @code{--with-unixODBC=DIR}
Where @code{DIR} is where unixODBC is installed.

And (as usual), if the unixODBC headers and libraries aren't located in
@file{DIR/include} and @file{DIR/lib}, use
    @code{--with-unixODBC-libs=LIBDIR}
    @code{--with-unixODBC-includes=INCDIR}

You might want to specify a prefix other than @file{/usr/local}
for installation, for example keep MyODBC drivers in
@file{/usr/local/odbc/lib}, so you can specify
    @code{--prefix=/usr/local/odbc}

Final Configuration example looks like this:

@example
  $ ./configure --prefix=/usr/local --with-iodbc=/usr/local
                --with-mysql-libs=/usr/local/mysql/lib/mysql
                --with-mysql-includes=/usr/local/mysql/include/mysql
@end example


@subsubheading Building the driver libraries:

To build the driver libraries, you have to just execute @file{make},
which takes care of everything.

@example
  $ make
@end example

Should build the libraries. If any errors occurs, correct them and continue 
the build process. If you can't able build, then send a detailed email to 
@email{myodbc@@lists.mysql.com} for further assistance.

@subsubheading Installing driver libraries:
@example
  $ make install
@end example

Installs the following set of libraries:
@example
  - libmyodbc3.so, 
  - libmyodbc3-3.51.01.so, where 3.51.01 is the version of the driver
  - libmyodbc3.a for @strong{MyODBC 3.51} or
  
  - libmyodbc.so
  - libmyodbc-2.50.39.so, where 2.50.39 is the version of the driver
  - libmyodbc.a for @strong{MyODBC 2.50}
@end example

For more information on build process, refer to the @file{INSTALL} file
that comes with the source distribution.

@code{@strong{Note}}, If you are trying to use the @file{make} from @code{SUN}, 
then you will end up with errors. On the other hand, @file{Make} from @code{GNU}
should work fine on all platforms.


@node Development Source Tree Installation,  , Source Installation Unix, How To Install MyODBC
@subsection Installing From The Development Source Tree
Caution: You should read this section only if you are interested
in helping us test our new code. If you just want to get @code{MyODBC 3.51}
up and running on your system, you should use a standard release
distribution (either a source or binary distribution will do).

To obtain our most recent development source tree, use these instructions:
@itemize
@item
Download @code{BitKeeper} from
@uref{http://www.bitmover.com/cgi-bin/download.cgi}.
You will need @code{Bitkeeper 2.0} or newer to access our repository.

@item
Follow the instructions to install it.

@item
After BitKeeper is installed, first go to the directory you want to work
from, and then use this command if you want to clone the MyODBC 3.51 branch:

@example
 shell> bk clone bk://work.mysql.com:7002/myodbc-3.51
@end example

In the above examples the source tree will be set up in the
@file{myodbc-3.51/} subdirectory of your current directory.

@item
You will need @code{GNU autoconf 2.13}, @code{automake 1.4},
@code{libtool}, and @code{m4} to run the next set of commands.

@example
  shell> cd myodbc-3.51
  shell> bk -r edit
  shell> aclocal; autoheader; autoconf;  automake;
  shell> ./configure  # Add your favorite options here
  shell> make
@end example

For more information on how to build, refer to the @file{INSTALL} file
located in the same directory.

On Windows, make use of Windows Makefiles @file{WIN-Makefile} and
@file{WIN-Makefile_debug} in building the driver.
For more information, see @ref{Source Windows Installation}.

@item
When the build is done, run @code{make install}, which installs the
@code{MyODBC 3.51} driver on your system.
If you have gotten to the make stage and the distribution does not compile,
please report it to @email{myodbc@@lists.mysql.com}.
If you have installed the latest versions of the required GNU tools,
and they crash trying to process our configuration files, please report
that also. However, if you execute @code{aclocal} and get a command not
found error or a similar problem, do not report it.
Instead, make sure all the necessary tools are installed and that your PATH
variable is set correctly so your shell can find them.

@item
After the initial @code{bk clone} operation to get the source tree,
you should run @code{bk pull} periodically to get the updates.

@item
You can examine the change history for the tree with all the diffs by
using @code{bk sccstool}. If you see some funny diffs or code that you
have a question about, do not hesitate to send e-mail to
@email{myodbc@@lists.mysql.com}.@*
Also, if you think you have a better idea on how to do something,
send an e-mail to the same address with a patch.
@code{bk diffs} will produce a patch for you after you have made
changes to the source. If you do not have the time to code your idea,
just send a description.

@item
@code{BitKeeper} has a nice help utility that you can access via
@code{bk helptool}.
@end itemize


@node Supported Platforms, MyODBC Mailing List, How To Install MyODBC, General Information
@section Supported Platforms
MySQL ODBC Drivers can be used on all major platforms supported by MySQL,
such as:

@itemize @bullet
@item All Windows platforms, 95/98 and NT/ME/2000/XP
@item All Unix Operating Systems
@itemize @bullet
@item AIX
@item Amiga
@item BSDI
@item DEC
@item FreeBSD
@item HP-UX
@item Linux
@item Mac OS X Server
@item NetBSD
@item OpenBSD
@item OS/2
@item SGI Irix
@item Solaris
@item SunOS
@item SCO OpenServer
@item SCO UnixWare
@item Tru64 Unix
@end itemize
@end itemize

In General, MyODBC (3.51) is supported in all the platforms that
MySQL supports.
If the binary distribution is not available for downloading for a
particular platform, then you can build the driver yourself, by
downloading the driver sources and contribute the binaries to MySQL,
by sending a mail to @email{myodbc@@lists.mysql.com}, so that it
becomes easy for other users.



@node MyODBC Mailing List, MyODBC Support , Supported Platforms, General Information
@section MyODBC Mailing List
MySQL provides the user community by means of its mailing lists,
where in you get the solutions from experienced users, by sending
your queries to @email{myodbc@@lists.mysql.com}.

To subscribe to the MyODBC mailing list, send a message to
@email{myodbc-subscribe@@lists.mysql.com}.
To unsubscribe from the MyODBC mailing list, send a message to
@email{myodbc-unsubscribe@@lists.mysql.com}.
You can also browse the mailing list archives at
@uref{http://lists.mysql.com/}.



@node MyODBC Support , Reporting Problems, MyODBC Mailing List, General Information
@section MyODBC Support
For the success of any product, support from the product vendor or the
development team plays a key role. If you want:

@example
  * Bugs to be resolved within time.
  * To have the immediate patches delivered directly to your mailbox.
  * To ask a feature in the driver.
  * To have enhancement to the driver.
  * To resolve any MyODBC or MySQL issues.
  * To have direct interaction with MySQL and MyODBC developers.
@end example

Then, you need to get a support contract from @code{MySQL AB}.
@code{MySQL AB} supports different types of support licenses in order 
to help you by keeping your requirements and ability to purchase it.
For more information about MySQL support, visit @uref{https://order.mysql.com/} 
or send a mail to @email{licensing@@mysql.com}.

Once you have the support means, you can send queries or bug reports
using the MySQL support wizard from @uref{http://support.mysql.com/},
then the MySQL team will work on your problem immediately until it got
resolved.



@node Reporting Problems, Programs Known to Work With MyODBC, MyODBC Support , General Information
@section How to Report MyODBC Problems or Bugs

If you encounter difficulties with @code{MyODBC} or @code{MyODBC 3.51},
you should start by making a log file from the @code{ODBC Manager}
(the log you get when requesting logs from @code{ODBC ADMIN}) and a
@code{MyODBC} or @code{MyODBC 3.51} log.

@strong{To get an ODBC trace through Driver Manager, you need to do the following:}

@itemize @tab
@strong{To open ODBC Data Source Administrator:}
@*@*

@itemize
@item
Click @code{@strong{Start}}, point to @code{@strong{Settings}}, and then click @code{@strong{Control Panel}}.
@item
On computers running @code{@strong{Microsoft Windows 2000}}, double-click @code{@strong{Administrative Tools}},
and then double-click @code{@strong{Data Sources (ODBC)}} as shown below:

@* @image{Images/mydsn-icon} @*@*

On computers running an earlier version of @code{@strong{Microsoft Windows}},
double-click @code{@strong{32-bit ODBC}} or @code{@strong{ODBC}}. @*

@strong{The @code{@strong{ODBC Data Source Administrator}} dialog box appears, as shown below:}@*

@* @image{Images/mydsn} @*@*

Click Help for detailed information about each tab of the @code{@strong{ODBC Data 
Source Administrator}} dialog box.@*
@end itemize

@*
@strong{To enable the trace option, you need to do the following:}
@*
@*

@itemize @bullet
@item
The @code{@strong{Tracing}} tab of the @code{@strong{ODBC Data Source Administrator}}
dialog box enables you to configure the way ODBC function calls are
traced.
@item
When you activate tracing from the @code{@strong{Tracing}} tab, the
@code{@strong{Driver Manager}} will log all ODBC function calls for all
subsequently run applications.
@item
ODBC function calls from applications running before tracing is
activated are not logged. ODBC function calls are recorded in a
log file you specify.
@item
Tracing ceases only after you click Stop Tracing Now. Remember that
while tracing is on, the log file continues to increase in size and
that this affects the performance of all your ODBC applications.

@* @image{Images/mydsn-trace} @*@*

@strong{On Unix}, you need to explicitly set the @code{@strong{TRACE}} option in the
@code{@strong{ODBC.INI}}.

Set the tracing @code{ON} or @code{OFF} by using TRACE and TRACEFILE parameters in
@file{odbc.ini} as shown below:

@example
  TraceFile  = /tmp/odbc.trace
  Trace      = 1
@end example

Where TRACEFILE specifies the name and full path of the trace file and TRACE
is set to ON or OFF. You can also use 1 or YES for ON and 0 or NO for OFF.@*@*

@strong{Note}, if you are using @file{ODBCConfig} from @code{unixODBC}, then 
follow the instructions from '@uref{http://www.unixodbc.org/config.html, 
HOWTO-ODBCConfig}', to trace the unixODBC calls.

@end itemize

@*
@strong{To get @code{MyODBC} or @code{MyODBC 3.51} driver log, you need to do
the following:}
@*
@*
@itemize @bullet

@item
Ensure that you are using @file{myodbc3d.dll} and not
@file{myodbc3.dll} for @code{MyODBC 3.51}
(and @file{myodbcd.dll} for @code{MyODBC}).

The easiest way to do this is to get @file{myodbc3d.dll}
(or @file{myodbcd.dll}) from the @code{MyODBC 3.51} distribution and
copy it over the @file{myodbc3.dll} (or @file{myodbc.dll}),
which is probably in your @file{C:\windows\system32} or
@file{C:\winnt\system32} directory. Note that you probably want to
restore the old @file{myodbc.dll} file when you have finished testing,
as this is a lot faster than @file{myodbc3d.dll} (or @file{myodbcd.dll}),
so do keep a backup copy of original DLLs.

@item
Tag the @code{@strong{`Trace MyODBC'}} option flag in the MyODBC connect/configure
screen. The log will be written to file @file{C:\myodbc.log}.
If the trace option is not remembered when you are going back to the
above screen, it means that you are not using the @file{myodbcd.dll}
driver (see above). On Linux or if you are using DSN-Less connection,
then you need to supply @code{OPTION=4} in the connection string.

@item
Start your application and try to get it to fail.
Check the MyODBC trace file, to find out what could be wrong.

If you find out something is wrong, please send a mail to
@email{myodbc@@lists.mysql.com} (or to @email{support@@mysql.com},
only if you have a support contract from MySQL AB) with a brief
description of the problem, with the following additional information:

@itemize @minus
@item MyODBC version
@item ODBC Driver Manager type used and its version
@item MySQL server version
@item ODBC trace from Driver Manager
@item MyODBC log file from MyODBC driver
@item Simple reproducible sample

@end itemize
@end itemize

Remember that the more information you can supply to us,
the more likely it is that we can fix the problem! Also,
read the MyODBC mailing list archive from
@uref{http://lists.mysql.com/}, before posting the bug.
@end itemize


@node Programs Known to Work With MyODBC,  , Reporting Problems, General Information
@section Programs Known to Work With MyODBC

Most programs should work with @strong{MyODBC}, but for each of those
listed below, we have tested it ourselves or received confirmation from
some user that it works.

@table @asis
@item @strong{Program}
@strong{Comment}
@cindex Access program

@item Access
To make Access work:
@itemize @bullet
@item
If you are using Access 2000, you should get and install the newest
(version 2.6 or above) Microsoft MDAC (@code{Microsoft Data Access
Components}) from @uref{http://www.microsoft.com/data/}.  This will fix
the following bug in Access: when you export data to MySQL, the
table and column names aren't specified.  Another way to around this bug
is to upgrade to MyODBC Version 2.50.33 and MySQL Version
3.23.x, which together provide a workaround for this bug!

You should also get and apply the Microsoft Jet 4.0 Service Pack 5 (SP5)
which can be found here
@uref{http://support.microsoft.com/default.aspx?scid=kb;EN-US;q239114}.
This will fix some cases where columns are marked as @code{#deleted#}
in Access.

Note that if you are using MySQL Version 3.22, you must to apply the
MDAC patch and use MyODBC 2.50.32 or 2.50.34 and above to go around
this problem.
@item
For all Access versions, you should enable the MyODBC option flag
@code{Return matching rows}. For Access 2.0, you should additionally enable
@code{Simulate ODBC 1.0}.
@item
You should have a timestamp in all tables you want to be able to update.
For maximum portability @code{TIMESTAMP(14)} or simple @code{TIMESTAMP}
is recommended instead of other @code{TIMESTAMP(X)} variations.
@item
You should have a primary key in the table. If not, new or updated rows
may show up as @code{#DELETED#}.
@item
Only use @code{DOUBLE} float fields. Access fails when comparing with
single floats.  The symptom usually is that new or updated rows may show
up as @code{#DELETED#} or that you can't find or update rows.
@item
If you are linking a table through MyODBC, which has @code{BIGINT} as
one of the column, then the results will be displayed as @code{#DELETED}. The
work around solution is:
@itemize @bullet
@item
Have one more dummy column with @code{TIMESTAMP} as the data type, preferably
@code{TIMESTAMP(14)}.
@item
Check the @code{'Change BIGINT columns to INT'} in connection options dialog in
ODBC DSN Administrator
@item
Delete the table link from access and re-create it.
@end itemize

It still displays the previous records as @code{#DELETED#}, but newly
added/updated records will be displayed properly.
@item
If you still get the error @code{Another user has changed your data} after
adding a @code{TIMESTAMP} column, the following trick may help you:

Don't use @code{table} data sheet view. Create instead a form with the
fields you want, and use that @code{form} data sheet view.  You should
set the @code{DefaultValue} property for the @code{TIMESTAMP} column to
@code{NOW()}.  It may be a good idea to hide the @code{TIMESTAMP} column
from view so your users are not confused.
@item
In some cases, Access may generate illegal SQL queries that
MySQL can't understand. You can fix this by selecting
@code{"Query|SQLSpecific|Pass-Through"} from the Access menu.
@item
Access on NT will report @code{BLOB} columns as @code{OLE OBJECTS}. If
you want to have @code{MEMO} columns instead, you should change the
column to @code{TEXT} with @code{ALTER TABLE}.
@item
Access can't always handle @code{DATE} columns properly. If you have a problem
with these, change the columns to @code{DATETIME}.
@item
If you have in Access a column defined as @code{BYTE}, Access will try
to export this as @code{TINYINT} instead of @code{TINYINT UNSIGNED}.
This will give you problems if you have values > 127 in the column!
@end itemize

@cindex ADO program
@item ADO
When you are coding with the ADO API and @strong{MyODBC} you need to put
attention in some default properties that aren't supported by the
MySQL server.  For example, using the @code{CursorLocation
Property} as @code{adUseServer} will return for the @code{RecordCount
Property} a result of -1. To have the right value, you need to set this
property to @code{adUseClient}, like is showing in the VB code below:

@example
Dim myconn As New ADODB.Connection
Dim myrs As New Recordset
Dim mySQL As String
Dim myrows As Long

myconn.Open "DSN=MyODBCsample"
mySQL = "SELECT * from user"
myrs.Source = mySQL
Set myrs.ActiveConnection = myconn
myrs.CursorLocation = adUseClient
myrs.Open
myrows = myrs.RecordCount

myrs.Close
myconn.Close
@end example

Another workaround is to use a @code{SELECT COUNT(*)} statement
for a similar query to get the correct row count.

@item Active server pages (ASP)
You should use the option flag @code{Return matching rows}.

@item BDE applications
To get these to work, you should set the option flags
@code{Don't optimize column widths} and @code{Return matching rows}.

@cindex Borland Builder 4 program
@item Borland Builder 4
When you start a query you can use the property @code{Active} or use the
method @code{Open}.  Note that @code{Active} will start by automatically
issuing a @code{SELECT * FROM ...} query that may not be a good thing if
your tables are big!

@item ColdFusion (On Unix)
The following information is taken from the ColdFusion documentation:

Use the following information to configure ColdFusion Server for Linux
to use the unixODBC driver with @strong{MyODBC} for MySQL data
sources.  Allaire has verified that @strong{MyODBC} Version 2.50.26
works with MySQL Version 3.22.27 and ColdFusion for Linux. (Any
newer version should also work.) You can download @strong{MyODBC} at
@uref{http://www.mysql.com/downloads/api-myodbc.html}

@cindex ColdFusion program
ColdFusion Version 4.5.1 allows you to us the ColdFusion Administrator
to add the MySQL data source. However, the driver is not
included with ColdFusion Version 4.5.1. Before the MySQL driver
will appear in the ODBC datasources drop-down list, you must build and
copy the @strong{MyODBC} driver to
@file{/opt/coldfusion/lib/libmyodbc.so}.

The Contrib directory contains the program mydsn-xxx.zip which allows
you to build and remove the DSN registry file for the MyODBC driver
on Coldfusion applications.

@cindex DataJunction
@item DataJunction
You have to change it to output @code{VARCHAR} rather than @code{ENUM}, as
it exports the latter in a manner that causes MySQL grief.

@cindex Excel
@item Excel
Works. A few tips:
@itemize @bullet
@item
If you have problems with dates, try to select them as strings using the
@code{CONCAT()} function. For example:
@example
select CONCAT(rise_time), CONCAT(set_time)
    from sunrise_sunset;
@end example
Values retrieved as strings this way should be correctly recognized
as time values by Excel97.

The purpose of @code{CONCAT()} in this example is to fool ODBC into thinking
the column is of ``string type''. Without the @code{CONCAT()}, ODBC knows the
column is of time type, and Excel does not understand that.

Note that this is a bug in Excel, because it automatically converts a
string to a time. This would be great if the source was a text file, but
is plain stupid when the source is an ODBC connection that reports
exact types for each column.
@end itemize
@cindex Word program
@item Word

To retrieve data from MySQL to Word/Excel documents, you need to
use the @code{MyODBC} driver and the Add-in Microsoft Query help.

For example, create a db with a table containing 2 columns of text:

@itemize @bullet
@item
Insert rows using the @code{mysql} client command-line tool.
@item
Create a DSN file using the MyODBC driver, for example, my for the db above.
@item
Open the Word application.
@item
Create a blank new documentation.
@item
Using the tool bar called Database, press the button insert database.
@item
Press the button Get Data.
@item
At the right hand of the screen Get Data, press the button Ms Query.
@item
In the Ms Query create a New Data Source using the DSN file my.
@item
Select the new query.
@item
Select the columns that you want.
@item
Make a filter if you want.
@item
Make a Sort if you want.
@item
Select Return Data to Microsoft Word.
@item
Click Finish.
@item
Click Insert data and select the records.
@item
Click OK and you see the rows in your Word document.
@end itemize

@cindex odbcadmin program
@item odbcadmin
Test program for ODBC.

@cindex Delphi program
@item Delphi
You must use BDE Version 3.2 or newer.  Set the @code{Don't optimize column width}
option field when connecting to MySQL.

Also, here is some potentially useful Delphi code that sets up both an
ODBC entry and a BDE entry for @strong{MyODBC} (the BDE entry requires a BDE
Alias Editor that is free at a Delphi Super Page near
you. (Thanks to Bryan Brunton @email{bryan@@flesherfab.com} for this):

@example
fReg:= TRegistry.Create;
  fReg.OpenKey('\Software\ODBC\ODBC.INI\DocumentsFab', True);
  fReg.WriteString('Database', 'Documents');
  fReg.WriteString('Description', ' ');
  fReg.WriteString('Driver', 'C:\WINNT\System32\myodbc.dll');
  fReg.WriteString('Flag', '1');
  fReg.WriteString('Password', '');
  fReg.WriteString('Port', ' ');
  fReg.WriteString('Server', 'xmark');
  fReg.WriteString('User', 'winuser');
  fReg.OpenKey('\Software\ODBC\ODBC.INI\ODBC Data Sources', True);
  fReg.WriteString('DocumentsFab', 'MySQL');
  fReg.CloseKey;
  fReg.Free;

  Memo1.Lines.Add('DATABASE NAME=');
  Memo1.Lines.Add('USER NAME=');
  Memo1.Lines.Add('ODBC DSN=DocumentsFab');
  Memo1.Lines.Add('OPEN MODE=READ/WRITE');
  Memo1.Lines.Add('BATCH COUNT=200');
  Memo1.Lines.Add('LANGDRIVER=');
  Memo1.Lines.Add('MAX ROWS=-1');
  Memo1.Lines.Add('SCHEMA CACHE DIR=');
  Memo1.Lines.Add('SCHEMA CACHE SIZE=8');
  Memo1.Lines.Add('SCHEMA CACHE TIME=-1');
  Memo1.Lines.Add('SQLPASSTHRU MODE=SHARED AUTOCOMMIT');
  Memo1.Lines.Add('SQLQRYMODE=');
  Memo1.Lines.Add('ENABLE SCHEMA CACHE=FALSE');
  Memo1.Lines.Add('ENABLE BCD=FALSE');
  Memo1.Lines.Add('ROWSET SIZE=20');
  Memo1.Lines.Add('BLOBS TO CACHE=64');
  Memo1.Lines.Add('BLOB SIZE=32');

  AliasEditor.Add('DocumentsFab','MySQL',Memo1.Lines);
@end example

@cindex C++ Builder
@item C++ Builder
Tested with BDE Version 3.0. The only known problem is that when the table
schema changes, query fields are not updated. BDE, however, does not seem
to recognise primary keys, only the index PRIMARY, though this has not
been a problem.

@item Vision
You should use the option flag @code{Return matching rows}.

@cindex Visual Basic
@item Visual Basic
To be able to update a table, you must define a primary key for the table.

Visual Basic with ADO can't handle big integers. This means that some queries
like @code{SHOW PROCESSLIST} will not work properly.  The fix is to set
add the option @code{OPTION=16834} in the ODBC connect string or set
the @code{Change BIGINT columns to INT} option in the MyODBC connect screen.
You may also want to set the @code{Return matching rows} option.

@item VisualInterDev
If you get the error @code{[Microsoft][ODBC Driver Manager] Driver does
not support this parameter} the reason may be that you have a
@code{BIGINT} in your result.  Try setting the @code{Change BIGINT
columns to INT} option in the MyODBC connect screen.

@item Visual Objects
You should use the option flag @code{Don't optimize column widths}.

@item MS Visio Enterprise 2000
We made database model diagram by connecting from MS Vision Enterprise 
2000 to MySQL via MyODBC(2.50.37 or greater) and using Visio's reverse 
engineer function to retrieve information about the DB (Visio shows all 
the column definitions, primary keys, Indexes and so on). Also we tested 
by designing new tables in Visio and exported them to MySQL via MyODBC.
@end table

@c
@c CHAPTER 3
@c


@node Developing Applications Using MyODBC, MyODBC API Reference, General Information, Top
@chapter Developing Applications Using MyODBC

This chapter contains information about developing applications to access MySQL 
server that use MyODBC as the interface.


@menu
* Basic MyODBC application steps ::  
* Configuring MyODBC DSN ::     
* Connection parameters ::      
* Connecting to MySQL server ::  
* Executing SQL Statements ::   
* Retrieving Results ::         
* Cursor Operations ::          
* Catalog Functions ::          
* Transaction Control ::        
* Getting Diagnostic Information ::  
@end menu

@node Basic MyODBC application steps , Configuring MyODBC DSN , Developing Applications Using MyODBC, Developing Applications Using MyODBC
@section Basic MyODBC application steps 

More or less, to interact with MySQL server from any ODBC/MyODBC application, 
involves the following steps of operations:

@itemize @bullet    
@item Configuring the MyODBC DSN
@item Connecting to MySQL server
@item Initializations
@item Execution of SQL statements
@item Retrieving results
@item Performing Transactions
@item Disconnecting from the server
@end itemize

Most applications use some variation of these steps. The basic application 
steps are shown in the following diagram:

@*@* @image{Images/myflowchart} @*@*


@node Configuring MyODBC DSN , Connection parameters , Basic MyODBC application steps , Developing Applications Using MyODBC
@section Configuring MyODBC DSN 

A data source identifies a path to data that can include a network
library, server, database, and other attributes-in this case; the
data source is the path to @code{MySQL} database. To connect to a
data source, the Driver Manager checks the Windows registry for
specific connection information. 

The @code{ODBC Driver Manager} and @code{MyODBC Drivers} use the
registry entry created by the @code{ODBC Data Source Administrator}.
This entry contains information about each data source and its
associated driver. Before you can connect to a data source, its
connection information must be added to the registry.


To add and configure data sources, use the @code{@strong{ODBC Data Source
Administrator}}. The @code{@strong{ODBC Administrator}} updates your data
source connection information. As you add data sources, the
@code{@strong{ODBC Administrator}} updates the registry information for you. 

@strong{To open the @code{@strong{ODBC Administrator}} from the Control Panel:}

@itemize
@item
Click @code{@strong{Start}}, point to @code{@strong{Settings}}, and then click @code{@strong{Control Panel}}.
@item
On computers running Microsoft Windows 2000, double-click
@code{@strong{Administrative Tools}}, and then double-click @code{@strong{Data
Sources (ODBC)}}.On computers running previous versions of Microsoft Windows,
double-click @code{@strong{32-bit ODBC}} or @code{@strong{ODBC}}.

@*@* @image{Images/mydsn-icon} @*

The @code{@strong{ODBC Data Source Administrator}} dialog box appears, as 
shown below.

@*@* @image{Images/mydsn} @*@*


Click Help for detailed information about each tab of the @code{@strong{ODBC Data
Source Administrator}} dialog box.@*@*
@end itemize

@strong{To add a data source on Windows:}@*

@enumerate
@item
Open the @code{@strong{ODBC Data Source Administrator}}.
@item
In the @code{@strong{ODBC Data Source Administrator}} dialog box, click
@code{Add}. The @code{@strong{Create New Data Source}} dialog box appears.
@item
Select @code{@strong{MySQL ODBC 3.51 Driver}}, and then click @code{@strong{Finish}}.
The @code{@strong{MySQL ODBC 3.51 Driver - DSN Configuration}} dialog box
appears, as shown below:

@*@* @image{Images/mydsn-setup} @*@*

@item
In the @code{@strong{Data Source Name}} box, type the name of the data
source you want to access. It can be any valid name that you choose.
@item
In the @code{@strong{Description}} box, type the description needed for the DSN.
@item
In the @code{@strong{Host or Server Name (or IP)}}, type the MySQL server name
that you want to access. By default it is 'local host'.
@item
In the @code{@strong{Database Name}}, type the name of the MySQL database
that you want to use it as the default database.
@item
In the @code{@strong{User}} box, type your database user name (your database
user ID).
@item
In the @code{@strong{Password}} box, type your pass word
@item
In the @code{@strong{Port}} box, type the port number if it is not the
default ’3306’.
@item
In the @code{@strong{SQL Command}} box, you can enter the optional SQL command
that you want to use it after the connection. The final dialog look like:

@end enumerate

@itemize
@* @image{Images/mydsn-example} @*@*

Click @code{@strong{OK}} to add this data source.


@code{@strong{Note:}} Upon clicking OK, the Data Sources dialog box appears, and
the @code{@strong{ODBC Administrator}} updates the registry information. The user
name and connect string that you typed become the default connection
values for this data source when you connect to it.

You can also @code{test} whether your settings are enough to connect to the
server using the button @code{@strong{Test Data Source}}. This feature is available
only for @code{MyODBC 3.51} driver. Here are the screen shots of @code{Test
Data Source} results for failed and successful connection:

@*@* @image{Images/mydsn-test-success} @*

@* @image{Images/mydsn-test-fail} @*@*
 
You can also see lot of check boxes with @code{@strong{Options that affect the
behavior of MyODBC}}. You can refer to @ref{Connection parameters}, to know more
about this.
@end itemize

@*

@strong{To modify a data source on Windows}:

@enumerate

@item
Open the @code{@strong{ODBC Data Source Administrator}}. Click the appropriate DSN tab.
@item
Select the MySQL data source you want to @code{@strong{modify}} and then click @code{@strong{Configure}}.
The @code{@strong{MySQL ODBC 3.51 Driver - DSN Configuration}} dialog box appears.
@item
Modify the applicable data source fields, and then click @code{@strong{OK}}.

@end enumerate
@*
When you have finished modifying the information in this dialog box, the
@code{@strong{ODBC Administrator}} updates the registry information.

@*

@strong{To configure data source on Unix}:

On @code{Unix}, you can configure the @code{DSN} entries directly in the
ODBC.INI file. Here is an example of odbc.ini file, with 'myodbc' as the 
DSN name for MyODBC 2.50 and myodbc3 for MyODBC 3.51 Drivers:

@example
  ;
  ;  odbc.ini configuration for MyODBC and MyODBC 3.51 Drivers
  ;
  @strong{[ODBC Data Sources]}
  myodbc      = MySQL ODBC 2.50 Driver DSN 
  myodbc3     = MySQL ODBC 3.51 Driver DSN 

  @strong{[myodbc]}
  Driver       = /usr/local/lib/libmyodbc.so
  Description  = MySQL ODBC 2.50 Driver DSN
  SERVER       = localhost
  PORT         =
  USER         = root
  Password     =
  Database     = test
  OPTION       = 3
  SOCKET       = 

  @strong{[myodbc3]}
  Driver       = /usr/local/lib/libmyodbc3.so
  Description  = MySQL ODBC 3.51 Driver DSN
  SERVER       = localhost
  PORT         =
  USER         = root
  Password     =
  Database     = test
  OPTION       = 3   
  SOCKET       = 

  @strong{[Default]}
  Driver       = /usr/local/lib/libmyodbc3.so
  Description  = MySQL ODBC 3.51 Driver DSN
  SERVER       = localhost
  PORT         =
  USER         = root
  Password     =
  Database     = test
  OPTION       = 3
  SOCKET       = 
@end example


Refer to the @ref{Connection parameters}, for the list of connection parameters that can be supplied

@strong{Note}, if you are using unixODBC, then you can make use of the 
following tools in order to setup the DSN:
@itemize
@item ODBCConfig GUI tool(
@uref{http://www.unixodbc.org/config.html, HOWTO : ODBCConfig})
@item odbcinst
@end itemize


@node Connection parameters , Connecting to MySQL server , Configuring MyODBC DSN , Developing Applications Using MyODBC
@section Connection parameters 

One can specify the following parameters for @strong{MyODBC} or
@strong{MyODBC 3.51} on the @code{[Data Source Name]} section of an
@code{ODBC.INI} file or through the @code{InConnectionString}
argument in the @code{SQLDriverConnect()} call.

@multitable @columnfractions .2 .2 .6
@item @strong{Parameter} @tab @strong{Default value} @tab @strong{Comment}
@item user @tab ODBC (on Windows) @tab The username used to connect to MySQL.
@item server @tab localhost @tab The hostname of the MySQL server.
@item database @tab @tab The default database
@item option @tab 0 @tab A integer by which you can specify how @strong{MyODBC 3.51} should work. See below.
@item port @tab 3306 @tab The TCP/IP port to use if @code{server} is not @code{localhost}.
@item stmt @tab @tab A statement that will be executed when connection to @code{MySQL}.
@item password @tab @tab The password for the @code{server} @code{user} combination.
@item socket @tab @tab The socket or Windows pipe to connect to.
@end multitable

The @code{OPTION} argument is used to tell @strong{MyODBC 3.51} that the
client isn't 100% ODBC compliant. On Windows, one normally sets the
option flag by toggling the different options on the connection screen
but one can also set this using @code{OPTION} connection argument. 
The following options are listed in the same order as they appear in 
the @strong{MyODBC 3.51} connect screen:

@multitable @columnfractions .1 .9
@item @strong{Bit} @tab @strong{Description}
@item 1 @tab The client can't handle that @strong{MyODBC} returns the real width of a column.
@item 2 @tab  The client can't handle that MySQL returns the true value of affected rows.  If this flag is set then MySQL returns 'found rows' instead.  One must have MySQL 3.21.14 or newer to get this to work.
@item 4 @tab Make a debug log in c:\myodbc.log.  This is the same as putting @code{MYSQL_DEBUG=d:t:O,c::\myodbc.log} in @file{AUTOEXEC.BAT}
@item 8  @tab Don't set any packet limit for results and parameters.
@item 16 @tab Don't prompt for questions even if driver would like to prompt
@item 32 @tab Enable or disable the dynamic cursor support. This is not allowed in MyODBC 2.50.
@item 64 @tab Ignore use of database name in 'database.table.column'.
@item 128 @tab Force use of ODBC manager cursors (experimental).
@item 256 @tab Disable the use of extended fetch (experimental).
@item 512 @tab Pad CHAR fields to full column length.
@item 1024 @tab SQLDescribeCol() will return fully qualified column names
@item 2048 @tab Use the compressed server/client protocol
@item 4096 @tab Tell server to ignore space after function name and before @code{'('} (needed by PowerBuilder).  This will make all function names keywords!
@item 8192 @tab Connect with named pipes to a @code{mysqld} server running on NT.
@item 16384 @tab Change LONGLONG columns to INT columns (some applications can't handle LONGLONG).
@item 32768 @tab Return 'user' as Table_qualifier and Table_owner from SQLTables (experimental)
@item 65536 @tab Read parameters from the @code{client} and @code{odbc} groups from @file{my.cnf}
@item 131072 @tab Add some extra safety checks (should not bee needed but...)
@end multitable

If you want to have many options, you should add the above flags!  For
example setting option to 12 (4+8) gives you debugging without package
limits!

The default @file{MYODBC3.DLL} is compiled for optimal performance.  If
you want to to debug @strong{MyODBC 3.51} (for example to enable tracing),
you should instead use @code{MYODBCD3.DLL}.  To install this file, copy
@file{MYODBCD3.DLL} over the installed @code{MYODBC3.DLL} file.


@node Connecting to MySQL server , Executing SQL Statements , Connection parameters , Developing Applications Using MyODBC
@section Connecting to MySQL server 

An application can be connected to any number of drivers and data sources. These 
can be a variety of drivers and data sources, the same driver and a variety of 
data sources, or even multiple connections to the same driver and data source. 
An application must follow the following steps in order to connect to MySQL 
server through MyODBC:  

@itemize @bullet
  @item @code{Allocate the Environment Handle}
  @item @code{Set the ODBC Version}
  @item @code{Allocate the Connection Handle}
  @item @code{Set Optional Connection Attributes, before the connection}
  @item @code{Establish a Connection}
  @item @code{Set Optional Connection Attributes, after the connection}
@end itemize

@menu
* Allocating the Environment Handle ::  
* Declaring the Application ODBC Version ::  
* Allocating a Connection Handle ::  
* Setting Connection Attributes ::  
* Establishing a connection using MyODBC::  
* Driver Information ::         
* Terminating Connections ::    
@end menu

@node Allocating the Environment Handle , Declaring the Application ODBC Version , Connecting to MySQL server , Connecting to MySQL server
@subsection Allocating the Environment Handle 

Before an application can use any other ODBC function, the first task for any 
application is to initialize the ODBC interface and associate an environment 
handle. An environment handle provides access to global information such as 
valid connection handles and active connection handles. 


To allocate an environment handle, an application:    

@enumerate
@item Declares a variable of the type SQLHENV. For example, the application 
could use the declaration:  
@example
  SQLHENV henv;  
@end example
@item Call SQLAllocHandle (or SQLAllocEnv in case of MyODBC 2.50) and pass 
the address of this variable and the SQL_HANDLE_ENV option as:
@example         
  SQLAllocHandle (SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv) or
  SQLAllocEnv (&henv)
@end example
@end enumerate

If the application is linked through Driver manager, then this call loads the 
Driver Manager. The Driver Manager does not call @code{SQLAllocHandle} in the driver at 
this time because it does not know which driver to call. It delays calling 
@code{SQLAllocHandle} in the driver until the application calls a function to connect 
to a data source.@*@*

    
If the application is linked directly with the driver static library, then this 
call loads the driver, and driver builds the environment information and returns 
the allocated structure back to the application.    



@node Declaring the Application ODBC Version , Allocating a Connection Handle , Allocating the Environment Handle , Connecting to MySQL server
@subsection Declaring the Application ODBC Version 

If you are using MyODBC 2.50 driver, then you can ignore this section. Before an 
application allocates a connection, it must set the SQL_ATTR_ODBC_VERSION 
environment attribute using SQLSetEnvAttr as shown below:  
@example
  SQLSetEnvAttr (henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER) SQL_OV_ODBC3, 0);  
@end example


This attribute states that the application follows the ODBC 2.x or ODBC 3.x 
specification when using the following items:    

@itemize @bullet
  @item SQLSTATEs: Many SQLSTATE values are different in ODBC 2.x and ODBC 3.x. For 
  the list of SQLSTATE codes returned by MyODBC 3.51 driver, @xref{MyODBC Error Codes}. 

  @item Date, Time, and Timestamp Type Identifiers: The following table shows the type 
  identifiers for date, time, and timestamp data in ODBC 2.x and ODBC 3.x. @*

@multitable @columnfractions .1 .9
@item @strong{ODBC 2.X} @tab @strong{ODBC 3.X}
@item SQL Type Identifiers 
@item SQL_DATE @tab SQL_TYPE_DATE 
@item SQL_TIME @tab SQL_TYPE_TIME 
@item SQL_TIMESTAMP @tab SQL_TYPE_TIMESTAMP 
@item C Type Identifiers 
@item SQL_C_DATE @tab SQL_C_TYPE_DATE 
@item SQL_C_TIME @tab SQL_C_TYPE_TIME 
@item SQL_C_TIMESTAMP @tab SQL_C_TYPE_TIMESTAMP 
@end multitable
@end itemize

MyODBC 3.51 checks the version of the ODBC specification to which an application 
is written and responds accordingly. For example, if the application follows the 
ODBC 2.x specification and calls SQLExecute before calling SQLPrepare, the 
driver returns: SQLSTATE @strong{S1010} (Function sequence error).  If the application 
follows the ODBC 3.x specification, then it returns: SQLSTATE @strong{HY010} (Function 
sequence error)   



@node Allocating a Connection Handle , Setting Connection Attributes , Declaring the Application ODBC Version , Connecting to MySQL server
@subsection Allocating a Connection Handle 

A connection handle provides access to information such as whether the 
connection is open or not, valid statement and descriptor handles on the 
connection and whether a transaction is currently open or not.  


Before the application can connect to a MySQL server or driver, it must 
allocate a connection handle, as follows:    

@itemize @bullet
  @item The application declares a variable of type SQLHDBC. 
  @item It then calls  SQLAllocHandle (or SQLAllocConnect in case of 
  MyODBC 2.50) and passes the address of this variable, the handle of the 
  environment in which to allocate the connection, and the SQL_HANDLE_DBC 
  option. For example: 
@end itemize
@example
      SQLHDBC hdbc;  
  
      SQLAllocHandle (SQL_HANDLE_DBC, henv, &hdbc); or
      SQLAllocConnect (henv, &hdbc);      
@end example

If the application is linked through Driver Manager, then Driver Manager 
allocates memory to store information about the connection and returns the 
connection handle back to the application, and note that, it does not yet passes 
any call to driver. On the other hand, if you directly linked through driver 
library instead of through driver manager, then driver does this job.    


@node Setting Connection Attributes , Establishing a connection using MyODBC, Allocating a Connection Handle , Connecting to MySQL server
@subsection Setting Connection Attributes 

Connection attributes are characteristics of the connection. For example, 
because transactions occur at the connection level, the transaction isolation 
level is a connection attribute. Similarly, the login timeout, or number of 
seconds to wait while trying to connect before timing out, is a connection 
attribute.    


Connection attributes are set with SQLSetConnectAttr and their current settings 
can be retrieved with SQLGetConnectAttr. For MyODBC 2.50 driver applications, 
can make use of SQLSetConnectOption and SQLGetConnectOption.     


A connection attribute can be set before or after connection, or either, 
depending on the type of the attribute. The login timeout SQL_ATTR_LOGIN_TIMEOUT 
applies to the connection process and is effective only if set before 
connecting. 

The attributes that specify whether to use the ODBC cursor library 
SQL_ATTR_ODBC_CURSORS and the network packet size SQL_ATTR_PACKET_SIZE must be 
set before connecting, because the ODBC cursor library resides between the 
Driver Manager and the driver and   therefore must be loaded before the driver.  
 
For more information about list of connection attributes supported by MyODBC 
drivers, @xref{SQLSetConnectAttr}.


@node Establishing a connection using MyODBC, Driver Information , Setting Connection Attributes , Connecting to MySQL server
@subsection Establishing a connection using MyODBC

After allocating environment and connection handles, and setting optional 
connection attributes, the application is ready to connect to MySQL server or 
MyODBC driver (through Driver Manager). There are two different functions 
supported by MyODBC to do this:    

@itemize @bullet
  @item @strong{SQLConnect} and 
  @item @strong{SQLDriverConnect} 
@end itemize

@subsubheading Connecting with SQLConnect
  @strong{SQLConnect} is the simplest connection function. It requires a data source name 
  and accepts an optional user ID and password. Application passes the following 
  information to the driver through SQLConnect:

  @code{DSN:} The name of the data source.@*
  @code{UID:} The user name or login name to connect to server (optional).@*
  @code{PWD:} Password (optional).@*      

  Note that, if you already specified user name and password in the DSN setup or 
  ODBC.INI itself, then you can just specify the valid DSN and driver internally 
  gets the other required information from the DSN entries.  

  When an application calls SQLConnect, the Driver Manager uses the data source 
  name to read the name of the driver DLL or from the appropriate section of the 
  ODBC.INI file or registry. It then loads the driver DLL and passes the 
  SQLConnect arguments to it. If the driver needs additional information to 
  connect to the data source, it reads this information from the same section of 
  the ODBC.INI file.  

  If the application specifies a data source name that is not in the ODBC.INI 
  file or registry, or if the application does not specify a data source name, 
  the Driver Manager searches for the default data source specification. If it 
  finds the default data source, it loads the default driver DLL and passes the 
  application-specified data source name to it. If there is no default data 
  source, the Driver Manager returns an error. 

@strong{Example:}
The following example allocates the necessary environment and connection 
handles and connects to MySQL server using DSN 'myodbc3'.

@example  
    SQLHENV    henv; 
    SQLHDBC    hdbc; 
    SQLHSTMT   hstmt; 
    SQLRETURN  retcode; 
      
    /*Allocate environment handle */ 
    retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv); 
    if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
    @{ 
       /* Set the ODBC version environment attribute to version 3 */ 
       retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, 0);       
       if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
       @{ 
          /* Allocate connection handle */ 
          retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);       
          if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
          @{ 
             /* Connect to data source myodbc3 */ 
             retcode = SQLConnect(hdbc, (SQLCHAR*) "myodbc3", SQL_NTS, 
                                        (SQLCHAR*) "myuser", SQL_NTS, 
                                        (SQLCHAR*) "mypassword", SQL_NTS); 
      
             if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)
             @{ 
               /* Set auto commit to ON */ 
               retcode = SQLSetConnectAttr(hdbc, SQL_ATTR_AUTO_COMMIT, SQL_AUTOCOMMIT_ON,0); 
                printf("\n autocommit returned :%d", redcode);

                /* Allocate statement handle */ 
                retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);       
                if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
                @{ 
                  /* Process data */ 
                      ; 
                      ; 
                      ; 
                   /* Free stattemt handle */
                   SQLFreeHandle(SQL_HANDLE_STMT, hstmt); 
                @} 
                /* Disconnect from the server */
                SQLDisconnect(hdbc); 
             @} 
             /* Close the connection handle */
             SQLFreeHandle(SQL_HANDLE_DBC, hdbc); 
          @} 
       @} 
       /* Close the environment handle */
       SQLFreeHandle(SQL_HANDLE_ENV, henv);
@end example

@subsubheading  Connecting with SQLDriverConnect:  
@strong{SQLDriverConnect} is used to connect to a server using a connection string.  
One can use SQLDriverConnect instead of SQLConnect for the following reasons: 

@itemize @bullet     
@item To let the application use driver-specific connection information.
@item To request that the driver prompt the user for connection information.
@item To connect without specifying a data source i.e. DSN less connection 
@end itemize
         
The connection string may consists of one or more of the MyODBC connection 
parameters separated by ';'(@xref{Connection parameters}, for list of 
connection parameters). If user requested the driver to prompt for 
connection information, then driver displays the following connection dialog:

@* @image{Images/mydsn-example}@*@*


@subsubheading Connection string for SQLDriverConnect:
By using 'myodbc3' as the MySQL ODBC 3.51 DSN:
@example
ConnectionString = "DSN=myodbc3"
@end example
DSN Less Connection:
@example
ConnectionString = "DRIVER=@{MySQL ODBC 3.51 Driver@};\
                    SERVER=localhost;\
                    DATABASE=test;\
                    USER=monty;\
                    PASSWORD=monty;\
                    OPTION=4;"
@end example


@node Driver Information , Terminating Connections , Establishing a connection using MyODBC, Connecting to MySQL server
@subsection Retrieving Driver and Data Source Information 

Once the connection is established, application should be able to get the more 
information about the driver and the data source to which it is connected. Using 
the following set of APIs can do this:  

@itemize @bullet
@item @code{SQLGetInfo}: Returns general information about the driver and data source 
associated with a connection. 
For example, what SQL statements will the application execute? Will the 
application use scrollable cursors? Transactions? Procedures? Long data? For 
ideas about what features might not be supported by the driver and or server, 
application can make use of SQLGetInfo in order to get all the above 
information. For more information, refer to @ref{SQLGetInfo},
@item @code{SQLGetTypeInfo:} Returns information about data types supported by the 
server. The driver returns the information in the form of an SQL result set. The data 
types are intended for use in Data Definition Language (DDL) statements. For more 
information, refer to @ref{SQLGetTypeInfo}.
@item @code{SQLGetFunctions:} Returns information about whether a driver supports a 
specific ODBC function. Application can always make use of this function in 
order to verify whether the driver supports a particular API or not. For more 
information, refer to @ref{SQLGetFunctions}.
@end itemize

@strong{Example:}
The following example gets the driver name and its version, server name and its 
version and the SQL conformance supported by the driver.  
@example

  SQLHDBC     hdbc; 
  SQLRETURN   retcode; 
  SQLCHAR     strValue[50]; 
  SQLINTEGER  nValue; 
  SQLSMALLINT pcbValue; 
    
  /* Connect to the server */
  retcode = SQLConnect (..) 
  if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
  @{ 
    /* get the driver name */ 
    retcode = SQLGetInfo (hdbc, SQL_DRIVER_NAME, strValue, 50, &pcbValue); 
    if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
    @{ 
       printf("driver name:%s",strValue); 
    @} 
    
    /* get the driver version */ 
    retcode = SQLGetInfo(hdbc, SQL_DRIVER_VER, strValue, 50, &pcbValue); 
    if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
    @{ 
       printf("driver version:%s",strValue); 
    @} 
    
    /* get the server name */ 
    retcode = SQLGetInfo(hdbc, SQL_DBMS_NAME, strValue, 50, &pcbValue); 
    if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
    @{ 
       printf("server name:%s",strValue); 
    @} 
    
    /* get the SQL conformance*/ 
    retcode = SQLGetInfo(hdbc, SQL_SQL_CONFORMANCE, &nValue, 0, &pcbValue); 
    if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
    @{ 
       printf("SQL Conformance:%d",nValue); 
    @} 
  @}
@end example


@node Terminating Connections ,  , Driver Information , Connecting to MySQL server
@subsection Terminating Connections 

When an application has finished using the MySQL server, it should close the 
connection and free all previously allocated handles. To terminate a connection 
from MyODBC and MySQL server, an application must:  

@itemize @bullet
@item Call @code{SQLDisconnect}(@xref{SQLDisconnect},) to close the connection. If there is any open statement 
  handles on this connection, then driver internally frees all open statements 
  on this connection. The application can then use the connection handle to 
  reconnect to the same data source or to a different data source, if the 
  connection handle is not freed. 
@item Call @code{SQLFreeHandle}(@xref{SQLFreeHandle},) with option as SQL_HANDLE_DBC to free the connection handle 
  and free all resources associated with the handle. 
@item Call @code{SQLFreeHandle}(@xref{SQLFreeHandle},) with option as SQL_HANDLE_ENV to free the environment 
  handle and free all resources associated with the handle. 
@end itemize
Note, if you are using MyODBC 2.50 driver, then you should use SQLFreeConnect 
and SQLFreeEnv to free connection and environment handles respectively.   



@node Executing SQL Statements , Retrieving Results , Connecting to MySQL server , Developing Applications Using MyODBC
@section Executing SQL Statements 

An application can submit any SQL statement supported by MySQL server. ODBC 
applications perform almost all database access by executing SQL statements. The 
general sequence of events is to:  
@itemize
@item @strong{Allocate a statement handle} 
@item @strong{Set optional statement attributes}
@item @strong{Execute the statement}
@item @strong{Retrieve any results}, and 
@item @strong{Free the statement handle}. 
@end itemize

@menu
* Allocating a statement handle ::  
* Setting the statement attributes ::  
* Submitting SQL Statements ::  
* Freeing a Statement Handle ::  
@end menu

@node Allocating a statement handle , Setting the statement attributes , Executing SQL Statements , Executing SQL Statements
@subsection Allocating a statement handle 

A statement handle provides access to statement information, such as error 
messages, the cursor name, and status information for SQL statement processing. 
Before the application can submit a SQL statement, it must allocate a statement 
handle using SQLAllocHandle (or SQLAllocStmt in case of MyODBC 2.50) as follows: 
 
@itemize @bullet
@item The application declares a variable of type HSTMT. It then calls 
SQLAllocHandle and passes the address of this variable, the handle of the 
connection in which to allocate the statement, and the SQL_HANDLE_STMT option. 

For example: 
@example
   SQLHSTMT hstmt;
   SQLAllocHandle (SQL_HANDLE_STMT, hdbc, &hstmt) or
   SQLAllocStmt (hdbc, &hstmt)
@end example
 
@item The Driver Manager allocates a structure in which to store information about 
  the statement and calls SQLAllocHandle in the driver with the SQL_HANDLE_STMT 
  option.  
@item The driver allocates its own structure in which to store information about the 
  statement and returns the driver statement handle to the Driver Manager.  On 
  the other hand, if you are linking directly with the driver, then driver 
  allocates the statement structure and returns the address back to the 
  application. 
@item  The Driver Manager returns the Driver Manager statement handle to the 
  application in the application variable. 
@end itemize

The driver identifies which statement to use when calling ODBC functions through 
statement handles.  

@node Setting the statement attributes , Submitting SQL Statements , Allocating a statement handle , Executing SQL Statements
@subsection Setting the statement attributes 

Statement attributes are characteristics of the statement. For example, to set 
the name of the cursor for a particular statement or to set the maximum rows to 
be fetched in one fetch statement.  

Statement attributes are set with SQLSetStmtAttr and their current settings 
retrieved with SQLGetStmtAttr (SQLSetStmtOption and SQLGetConnectOption in case 
of MyODBC 2.50). There is no requirement that an application set any statement 
attributes; all statement attributes have defaults.  

For more information about the statement attributes, refer to 
@xref{SQLSetStmtAttr}.  

@node Submitting SQL Statements , Freeing a Statement Handle , Setting the statement attributes , Executing SQL Statements
@subsection Submitting SQL Statements 

MyODBC allows an application to submit the SQL statements in two different 
ways:

@itemize @bullet
@item Prepared Execution
@item Direct Execution
@end itemize

@menu
* Prepared Execution::          
* Direct Execution::            
* Statement Parameters::        
* Sending Long or Blob Data::   
@end menu

@node Prepared Execution, Direct Execution, Submitting SQL Statements , Submitting SQL Statements
@subsubsection Prepared Execution
Prepared execution is an efficient way to execute a statement more than once. 
The statement is first compiled, or prepared, into an access plan. The access 
plan is then executed one or more times at a later time.  

An applicant can prefer the prepared execution, for the following reasons, if 
the application:  

@itemize @bullet
@item Executes the statement more than once, by changing the parameter values. 
@item Needs information about the SQL statement or the result set prior to 
      execution.
@end itemize 

The prepared execution is mainly achieved by SQLPrepare and SQLExecute MyODBC 
APIs. A prepared statement executes faster than an unprepared statement or 
direct execution because the driver compiles the statement, produces an access 
plan, and returns an access plan identifier back to the application. The driver 
minimizes processing time, as it does not have to produce an access plan each 
time it executes the statement. Network traffic is minimized for the prepared 
state statements.  

Note that, at the time of wring this document, MySQL server doesnot support any 
prepared execution, but MySQL ODBC drivers simulates everything needed for the 
prepared execution at driver level itself.  

@strong{To prepare and execute a statement, the application:}@*@*  
@itemize @bullet

@item Calls SQLPrepare and passes it a string containing the SQL statement. 
@item Sets the values of any statement parameters. For more information, see @ref{Statement Parameters}.
@item Calls SQLExecute and does any additional processing that is necessary, 
such as fetching data.
@item  Repeats steps 2 and 3 as necessary.
@item  When SQLPrepare is called, the driver modifies the SQL statement to use 
the MySQL grammar without parsing the statement. This includes replacing the 
escape sequences.
Note, driver does not return any syntactic and semantic errors at this point, 
rather it considers at the time of execution. 
@item  When SQLExecute is called, the driver:
@itemize @bullet
@item Retrieves the current parameter values and converts them as necessary. 
For more information, refer to @ref{Statement Parameters}.
@item Sends the access plan identifier and converted parameter values to MySQL 
Server.
@item Returns any errors. These are generally run-time errors such as SQLSTATE 
24000 (Invalid cursor state) and syntactic and semantic errors, if any.  
@end itemize
@end itemize

@strong{Example:}
The following example explains how an application can make use of prepared 
execution. The sample prepares an INSERT statement and inserts 100 rows of data 
by changing the buffer values.  
@example 
    SQLHSTMT hstmt; 
    SQLRETURN retcode; 
      
    retcode = SQLPrepare(hstmt, "INSERT INTO EMP(ID,NAME) VALUES(?,?)", SQL_NTS);
    if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
    @{ 
      SQLINTEGER id; 
      SQLCHAR name[30]; 
      
      /* do the binding for parameter 1, id */ 
      retcode = SQLBindParameter(hstmt,1,SQL_PARAM_INPUT, 
                                 SQL_C_LONG,  SQL_INTEGER, 
                                 0,0, &id, 0, NULL); 
      if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
      @{ 
        /* Now do the bindings for parameter 2, name */ 
        retcode = SQLBindParameter (hstmt,1,SQL_PARAM_INPUT, 
                                    SQL_C_CHAR, SQL_VARCHAR, 
                                    0,0, name, sizeof (name), NULL); 
        if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
        @{ 
          /* Now insert data by changing id and name buffer values */ 
          for ( id = 1 ; id <= 100;  id++) 
          @{ 
            /* Set name as ‘mysql1’, ‘mysql2’… */ 
            sprintf(name,”mysql%d”,id); 
            retcode = SQLExecute(hstmt); 
           @} 
        @} 
      @} 
      /* Free param buffer resources */ 
      retcode = SQLFreeStmt(hstmt, SQL_REST_PARAMS); 
    @}   
@end example


@node Direct Execution, Statement Parameters, Prepared Execution, Submitting SQL Statements
@subsubsection Direct Execution

Direct execution is the simplest way to execute a statement. Direct execution is 
commonly used by generic applications that build and execute statements at run 
time. For example, the following code builds an SQL statement and executes it a 
single time:  
@example
  SQLCHAR *statement;
    
  // Build an SQL statement.
  printf("enter the SQL statement:");
  scanf("%s",&statement);
    
  // Execute the statement.
  SQLExecDirect (hstmt, statement, SQL_NTS);
@end example
An application should execute a statements using direct execution, if:@*  
@itemize @bullet
@item The application will execute the statement only once. 
@item The application does not need information about the result set prior to execution 
@end itemize
The main drawback of using @code{Direct Execution} is, the SQL statement is parsed 
every time it is executed.  

@strong{To execute a statement directly, the application performs the following set of 
actions:}@*@*
@itemize @bullet 
  
@item Sets the values of any parameters. For more information, see @ref{Statement Parameters}.
@item Calls SQLExecDirect and passes it a string containing the SQL statement.
@item When SQLExecDirect is called, the driver:
@itemize @bullet
@item  Modifies the SQL statement to use MySQL grammar without parsing the statement; 
  this includes replacing the escape sequences. 
@item  Retrieves the current parameter values and modifies the SQL statement by 
  replacing parameter markers with the data supplied by parameter binding, with 
  appropriate conversions. 
@item Sends the modified SQL statement to MySQL for execution. 
@item Returns any errors. These include sequencing or state diagnostics such as 
  SQLSTATE 24000 (Invalid cursor state), syntactic errors such as SQLSTATE 42000 
  (Syntax error or access violation), and semantic errors such as SQLSTATE 42S02 
  (Base table or view not found). 
@end itemize
@end itemize

@strong{Example:}@*
The following example explains how an application can make use of direct 
execution. The sample creates a table, inserts, updates, and deletes some rows 
of data and finally drops the table.
@example
    SQLHSTMT hstmt; 
    SQLRETURN retcode; 
      
    /* create table as "my_test" with integer and text field */ 
    retcode = SQLExecDirect(hstmt, "CREATE TABLE my_test(id int, name text", SQL_NTS); 
    if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
    @{ 
       printf("table created successfully.."); 
      
       /* insert 2 rows of data to the table ‘my_test’ */ 
       retcode = SQLExecDirect(hstmt, "INSERT INTO my_test VALUES(10,'mysql')", SQL_NTS); 
       if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
       @{ 
         printf("row 1 inserted successfully.."); 
       @} 
       retcode = SQLExecDirect(hstmt,"INSERT INTO my_test VALUES(20,'monty')", SQL_NTS); 
       if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
       @{ 
         printf("row 2 inserted successfully.."); 
       @} 
      
       /* Now update the second row by changing id from 20 to 100 */ 
       retcode = SQLExecDirect(hstmt, "UPDATE my_test SET id=100 WHERE name='monty', SQL_NTS); 
       if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
       @{ 
         SQLINTEGER rowcount; 
         printf("row updated successfully.."); 
      
         /* Get total number of rows affected by the update statement */ 
         retcode=SQLRowCount(hstmt, &rowcount); 
         printf("total rows affected by the updated statement:%d",rowcount); 
      @} 
      
      /* Now delete the newly updated row */ 
      retcode = SQLExecDirect(hstmt, "DELETE FROM my_test WHERE id=100", SQL_NTS); 
      if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
      @{ 
        SQLINTEGER rowcount; 
        printf("row deleted successfully.."); 
      
        /* Get total number of rows affected by the delete statement */ 
        retcode=SQLRowCount(hstmt, &rowcount); 
        printf("total rows affected by the delete statement:%d",rowcount); 
      @} 
    @} 
    /* now drop the table ‘my_test’ */ 
    retcode = SQLExecDirect(hstmt,"DROP TABLE my_test", SQL_NTS); 
    if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) 
    @{ 
      printf(“table dropped successfully); 
    @}   
@end example

@node Statement Parameters, Sending Long or Blob Data, Direct Execution, Submitting SQL Statements
@subsubsection Statement Parameters

A parameter is a variable in an SQL statement. An SQL statement can contain 
parameter markers ("@strong{?}") that indicate values that the driver retrieves 
from the application at execution time.   

For example, an application might use the following statement to insert a row of 
data into the EMPLOYEE table:  
@example
INSERT INTO EMPLOYEE (NAME.AGE) VALUES (?,?)  
@end example

An application can use parameter markers instead of literal or constant values 
in the SQL statement for the following reasons:@*
@itemize @bullet
@item It needs to execute the same prepared statement several times with different 
  parameter values. 
@item The parameter values are not known when the statement is prepared. 
@item The parameter values need to be converted from one data type to another.   
@end itemize

To set the value of a parameter, the application simply sets the value of the 
variable bound to the parameter using SQLBindParameter. It is not important when 
this value is set, as long as it is set before the statement is executed. The 
application can set the value before or after binding the variable, and it can 
change the value as many times as it wants.  

When the statement is executed, the driver simply retrieves the current value of 
the variable. This is particularly useful when a prepared statement is executed 
more than once; the application sets new values for some or all of the variables 
each time the statement is executed. For an example of this, see @ref{Prepared Execution}.  

If a length/indicator buffer was bound in the call to SQLBindParameter, it must 
be set to one of the following values before the statement is executed:@*  
@itemize @bullet
@item The byte length of the data in the bound variable. The driver checks this 
  length only if the variable is character or binary (ValueType is SQL_C_CHAR or 
  SQL_C_BINARY). 
@item SQL_NTS. The data is a null-terminated string. 
@item SQL_NULL_DATA. The data value is NULL, and the driver ignores the value of the 
  bound variable. 
@item SQL_DATA_AT_EXEC or the result of the SQL_LEN_DATA_AT_EXEC macro. The value of 
  the parameter is to be sent with SQLPutData. For more information, see @ref{Sending Long or Blob Data}. 
@end itemize


The parameter locations supplied through SQLBindParameter, remain bound to 
parameter markers until the application calls SQLFreeStmt with the 
SQL_RESET_PARAMS option or the SQL_DROP option. An application can bind a 
different storage location to a parameter marker at any time by calling 
SQLBindParameter.   

@strong{Example:}
@example
    SQLUINTEGER   id; 
    SQLINTEGER     idInd; 
      
    // Prepare a statement to insert id 
    SQLPrepare(hstmt, "INSERT INTO my_table VALUES(?)", SQL_NTS); 
      
    // Bind id to the parameter for the id column 
    SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_ULONG, 
                     SQL_LONG, 0, 0, &id, 0, &idInd); 
      
    // Repeatedly execute the statement, to insert 100 rows of data 
    for ( id=1; id <= 100; id++) 
    @{ 
       SQLExecute(hstmt); 
    @}   
@end example

@node Sending Long or Blob Data,  , Statement Parameters, Submitting SQL Statements
@subsubsection Sending Long or Blob Data

MySQL defines long data as any character or binary data over a certain size, 
such as 254 characters. It might not be possible to store an entire item of long 
data in memory, such as when the item represents a long text document or a 
bitmap. Because such data cannot be stored in a single buffer, the application 
sends it to the driver in parts with SQLPutData when the statement is executed. 
Parameters for which data is sent at execution time are known as 
data-at-execution parameters.  

Note   An application can actually send any type of data at execution time with 
SQLPutData, although only character and binary data can be sent in parts. 
However, if the data is small enough to fit in a single buffer, there is 
generally no reason to use SQLPutData. It is much easier to bind the buffer and 
let the driver retrieve the data from the buffer.  

When you need to enter large amounts of data into a long varchar or long 
varbinary columns, you can use the SQLPutData and SQLParamData ODBC functions to 
enter the data in smaller segments. Data is supplied in segments through 
SQLPutData, and SQLParamData is used to check if parameters require data.  

@strong{To send long data at execution time in segments, the application performs the 
following actions:}@*
@itemize @bullet  

@item @code{Prepare the statement:} Prepare the SQL Statement with parameter markers to 
  which the long or blob data to be supplied using SQLPrepare 
@item @code{Bind the parameters:} Set the pcbValue argument in the SQLBindParameter 
  function to either SQL_DATA_AT_EXEC or SQL_LEN_DATA_AT_EXEC. This lets the 
  driver know that you will provide values for this parameter at execution time 
  using SQLPutData. 
@item @code{Execute the SQL command:} If the statement is already prepared, execute the 
  prepared statement using SQLExecute or execute it using SQLExecDirect. If 
  there is any parameters that are expecting data at execution time, then driver 
  returns SQL_NEED_DATA. 
@item @code{Call SQLParamData:} in response to the SQL_NEED_DATA return value. If long data 
  needs to be sent, SQLParamData returns SQL_NEED_DATA. In the buffer pointed to 
  by the ValuePtrPtr argument, the driver returns the value that identifies the 
  data-at-execution parameter. If there is more than one data-at-execution 
  parameter, the application must use this value to determine which parameter to 
  send data for; the driver is not required to request data for 
  data-at-execution parameters in any particular order. 
@item @code{Call SQLPutData:} to send the parameter data to the driver. If the parameter 
  data does not fit into a single buffer, as is often the case with long data, 
  the application calls SQLPutData repeatedly to send the data in parts; 
@item @code{Call SQLParamData:} If the return code is SQL_NEED_DATA, the next parameter 
  that is expecting data at execution time is ready to receive data, and you 
  should go back to Step 4. If the return code is SQL_SUCCESS or 
  SQL_SUCCESS_WITH_INFO, then all data for all parameters expecting data at 
  execution time has been sent and the SQL statement has completed its 
  execution. 
@end itemize


@node Freeing a Statement Handle ,  , Submitting SQL Statements , Executing SQL Statements
@subsection Freeing a Statement Handle 

It is more efficient to reuse statements than to drop them and allocate new 
ones. Before executing a new SQL statement on a statement, applications should 
be sure that the current statement settings are appropriate. These include 
statement attributes, parameter bindings, and result set bindings. Generally, 
parameters and result sets for the old SQL statement needs to be unbound (by 
calling SQLFreeStmt with the SQL_RESET_PARAMS and SQL_UNBIND options) and 
rebound for the new SQL statement.  

When the application has finished using the statement, it calls SQLFreeHandle 
with SQL_HANDLE_STMT or SQLFreeStmt with option SQL_DROP to free the statement. 
By calling SQLDisconnect automatically frees all open statements on a 
connection.

The SQLFreeStmt function has four options:   

@multitable @columnfractions .1 .9
@item @strong{Option} @tab @strong{Functionality}
@item SQL_CLOSE @tab Closes the cursor, if one exists, and discards pending results. The 
application can use the statement handle again later. 
@item  SQL_DROP @tab Closes the cursor if one exists, discards pending results, and frees 
  all resources associated with the statement handle 
@item  SQL_UNBIND @tab Frees all return buffers bound by SQLBindCol for the statement 
  handle. 
@item  SQL_RESET_PARAMS @tab Frees all parameter buffers requested by SQLBindParameter 
  for the statement handle. 
@end multitable  



@node Retrieving Results , Cursor Operations , Executing SQL Statements , Developing Applications Using MyODBC
@section Retrieving Results 

A result set is a set of rows on the data source that matches certain criteria. 
When an application needs to retrieve data from a database, the most common 
method is to perform a query by using the @strong{SELECT} or @strong{SHOW} statement. In this 
section, we will learn how to perform a query and fetch the result data row by 
row using MyODBC (3.51) functions.   


@menu
* How to know whether the result set is created or not? ::  
* Getting Result Set Metadata ::  
* Fetching Data ::              
@end menu

@node How to know whether the result set is created or not? , Getting Result Set Metadata , Retrieving Results , Retrieving Results
@subsection How to know whether the result set is created or not? 

In most cases, when application is not sure of whether a particular statement 
resulted in a result set, it should call SQLNumResultCols to determine the 
number of columns in the result set. If this is 0, the statement did not create 
a result set; if it is any other number, then the statement did create a result 
set.  

The application can call SQLNumResultCols at any time after the statement is 
prepared or executed. Note, However,  if you call SQLNumResultCols  on a 
prepared statement, without the statement is executed, then the application 
suffers from performance, as the driver internally executes the prepared 
statement to return the statement information back to application.  

NOTE, for statements such as @strong{INSERT}, @strong{UPDATE} or @strong{DELETE}, the application calls 
SQLRowCount to determine number of rows affected by the statement. For other SQL 
statements, driver does not’t return any result set, and return code from 
SQLExecute or SQLExecDirect is usually the only source of information as to 
whether the statement was successful or failed.  


@node Getting Result Set Metadata , Fetching Data , How to know whether the result set is created or not? , Retrieving Results
@subsection Getting Result Set Metadata 

Applications require metadata for most result set operations. For example, the 
application uses the data type of a column to determine what kind of variable to 
bind to that column. It uses the byte length of a character column to determine 
how much space it needs to display data from that column. How an application 
determines the metadata for a column depends on the type of the application.  

SQLDescribeCol and SQLColAttribute (SQLColAttributes in case of MyODBC 2.50 
driver) are used to retrieve result set metadata. The difference between these 
two functions is that SQLDescribeCol always returns the same five pieces of 
information (a column's name, data type, precision, scale, and nullability), 
while SQLColAttribute returns a single piece of information requested by the 
application. However, SQLColAttribute can return a much richer selection of 
metadata, including a column's case-sensitivity, display size, updatability, and 
searchability.   


@node Fetching Data ,  , Getting Result Set Metadata , Retrieving Results
@subsection Fetching Data 

To retrieve a row of data from the result set, an application:   
@itemize @bullet
@item Calls SQLBindCol to bind the columns of the result set to storage locations if 
  it has not already done so. 
@item Calls SQLFetch to move to the next row in the result set and retrieve data for 
  all bound columns.   
@end itemize

Data fetched from the MySQL server is returned to the application by the driver 
in the variables that the application has allocated for this purpose. Before 
this can be done, the application must associate, or bind, these variables to 
the columns of the result set using SQLBindCol.   

Applications can bind as many or as few columns of the result set as they 
choose, including binding no columns at all. When a row of data is fetched, the 
driver returns the data for the bound columns to the application. Data can be 
retrieved from unbound columns by calling SQLGetData. This is commonly called to 
retrieve long data, which often exceeds the length of a single buffer and must 
be retrieved in parts.   

A variable remains bound to a column until a different variable is bound to the 
column, until the column is unbound by calling SQLBindCol with a null pointer as 
the variable's address, until all columns are unbound by calling SQLFreeStmt 
with the SQL_UNBIND option, or until the statement is released   



@node Cursor Operations , Catalog Functions , Retrieving Results , Developing Applications Using MyODBC
@section Cursor Operations 

A cursor is a tool that allows you to step through a result set row-by-row. 
Applications can perform multiple operations on each individual row in a given 
result set. A cursor is opened on the result set by execution of a query.   
The name cursor, as it applies to databases, probably originated from the 
blinking cursor on a computer terminal. Just as that cursor indicates the 
current position on the screen and where the typed words will appear next, a 
cursor on a result set indicates the current position in the result set and what 
row will be returned next.  

MyODBC supports its result set operations through two types of cursors, namely: 

@itemize @bullet
@item @strong{Block Cursor} and 
@item @strong{Scrollable Cursor}   
@end itemize


@menu
* Block Cursor::                
* Cursor Types ::               
* Result Set Scrolling ::       
* Positioned update and delete ::  
* Using SQLSetPos::             
@end menu

@node Block Cursor, Cursor Types , Cursor Operations , Cursor Operations
@subsection Block Cursor - Fetching Multiple rows of data 

An application can fetch multiple rows of data using a single fetch statement by 
making use of block cursors. The rows returned in a single fetch with a block 
cursor are called the rowset. 
  
It is important not to confuse the rowset with the result set. The result set is 
maintained at the MySQL server (some times in the driver side ), while the 
rowset is maintained in application buffers by the driver. While the result set 
is fixed, the rowset is not—it changes position and contents each time a new set 
of rows is fetched. Just as a single-row cursor such as the forward-only cursor 
points to a current row, a block cursor points to the rowset, which can be 
thought of as current rows. 
  
Application can set the size of the rowset using SQLSetStmtAttr with attribute 
option as SQL_ATTR_ROW_ARRAY_SIZE.  


@node Cursor Types , Result Set Scrolling , Block Cursor, Cursor Operations
@subsection Cursor Types 

MyODBC 3.51 supports three types of scrollable cursors, using this, an 
application can move backward and forward in the result set based on the 
requirement:
  
@itemize @bullet
@item Forward-only 
@item Static and 
@item Dynamic (only from MyODBC 3.51.01) 
@end itemize

Note, driver doesn't yet support Key set-Driven Cursor type, and to have dynamic 
support, one must check the option "Enable Dynamic Cursor Type" from DSN 
settings or by passing OPTION=32 as the connection string. @*

  
Application can set the cursor type through SQLSetStmtAttr (or SQLSetStmtOption 
in MyODBC 2.50 driver) with option as SQL_ATTR_CURSOR_TYPE. By default, driver 
implicitly uses forwards-only cursor. @*

  
Using the forwards-only cursor, an application can only forward in the result 
set, and it can not go backward, where as in the other case, Static cursor type, 
an application can move forward or backward or to any desired location in the 
result set.


@node Result Set Scrolling , Positioned update and delete , Cursor Types , Cursor Operations
@subsection Result Set Scrolling 

When using a scrollable cursor, applications call SQLFetchScroll (or 
SQLExtendedFetch in case of MyODBC 2.50 driver) to position the cursor and fetch 
rows. SQLFetchScroll supports relative scrolling (next, prior, and relative n 
rows) and absolute scrolling (first, last, and row n). The FetchOrientation and 
FetchOffset arguments in SQLFetchScroll specify which rowset to fetch.

@multitable @columnfractions .1 .9  
@item @strong{FetchOrientation} @tab @strong{Meaning}
@item SQL_FETCH_NEXT @tab Return the next rowset. This is equivalent to calling SQLFetch.
      SQLFetchScroll ignores the value of FetchOffset. 
@item SQL_FETCH_PRIOR  @tab Return the prior rowset. SQLFetchScroll ignores the value 
      of FetchOffset. 
@item SQL_FETCH_FIRST  @tab Return the first rowset in the result set. SQLFetchScroll 
      ignores the value of FetchOffset. 
@item SQL_FETCH_LAST  @tab Return the last complete rowset in the result set. 
      SQLFetchScroll ignores the value of FetchOffset. 
@item SQL_FETCH_ABSOLUTE  @tab Return the rowset starting at row FetchOffset. 
@item SQL_FETCH_RELATIVE  @tab Return the rowset FetchOffset from the start of the 
      current rowset. 
@end multitable
  
Note, as said earlier, using the forward-only cursor type, an application can 
only move forward through SQL_FETCH_NEXT, where as using the static and or 
dynamic types, it can move to any desired location.


@node Positioned update and delete , Using SQLSetPos, Result Set Scrolling , Cursor Operations
@subsection Positioned update and delete 

Applications can update or delete the desired rows in the result set using the 
following set of ODBC calls:

@itemize @bullet
@item By calling @code{SQLSetPos} 
@item By executing positioned SQL statements using @code{SQLExecute} or @code{SQLExecDirect}.   
@end itemize

Refer to the @ref{Using SQLSetPos}, for more information on how to use SQLSetPos 
in updating or deleting the rows in the current rowset.

@*
@strong{To use a positioned update or delete statement, the application must follow 
the following steps:}@*
@itemize @bullet
@item  Set the cursor name by calling SQLSetCursorName. If the application did not 
  set the cursor name explicitly means, then the driver returns a default cursor 
  name. 
@item Open the result set through SELECT statement 
@item Position the cursor on the row to be updated or deleted. Application can do 
  this by calling SQLFetchScroll (or SQLExtendedFetch in case of MyODBC 2.50) to 
  retrieve a rowset containing the required row and calling SQLSetPos with 
  SQL_POSITION to position the rowset cursor on that row. 
@item Get the name of the cursor by calling SQLGetCursorName. Note that, if the 
  application did not’t set the cursor name explicitly before opening the result 
  set in the same statement handle through SQLSetCursorName, driver returns a 
  default cursor name. 
@item  Now, application executes the positioned update or deletes SQL statement on a 
  different statement handle than the statement being used by the result set. 
@end itemize

The syntax of these statements is:
@example
  UPDATE table-name SET column-identifier = @{expression | NULL@} 
                       [, column-identifier = @{expression | NULL@}]... 
                       WHERE CURRENT OF cursor-name 

  DELETE FROM table-name WHERE CURRENT OF cursor-name 
@end example
Where @code{cursor-name} is the name of the cursor returned by SQLGetCursorName.

  
@strong{Example:}
@example  
    HSTMT  hstmtSelect; 
    HSTMT  hstmtUpdate; 
    UCHAR  szLname[NAME_LEN],szFname[NAME_LEN],cursorName[10]; 
    SWORD  cursorLen; 
    SDWORD cbName; 
      
    /* Allocate the statement handles */ 

    retcode = SQLAllocStmt(hdbc, &hstmtSelect); 
    retcode = SQLAllocStmt(hdbc, &hstmtUpdate); 

    /* SELECT the result set and bind its columns to local storage  */ 

    retcode = SQLExecDirect(hstmtSelect, "SELECT lname,fname FROM EMP", SQL_NTS); 
    retcode = SQLBindCol(hstmtSelect, 1, SQL_C_CHAR, szLname, NAME_LEN, &cbLname); 
    retcode = SQLBindCol(hstmtSelect, 2, SQL_C_CHAR, szFname, NAME_LEN, &cbFname); 

    /* get the cursor name */ 
    retcode = SQLGetCursorName(hstmtSelect, cursorName, 10, &cursorLen); 
      
    /* Position to third row in the result set */ 
      
    retcode = SQLFetchScroll(hstmtSelect,SQL_FETCH_ABSOLUTE, 3); 
    if(retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)); 
      
    /* Perform a positioned update */ 
    sprintf(updsql, "UPDATE EMP SET fname = 'monty' WHERE CURRENT OF %s",  cursorName); 
    retcode = SQLExecDirect(hstmtUpdate, updsql, SQL_NTS);   
@end example


@node Using SQLSetPos,  , Positioned update and delete , Cursor Operations
@subsection Using SQLSetPos

Applications can update or delete any row in the current rowset usingh 
SQLSetPos. This is the convenient alternative to constructing and executing 
an SQL statement described in the earlier @ref{Positioned update and delete}.

  
SQLSetPos operates on the current rowset and can be used only after a call to 
SQLFetchScroll or SQLExtendedFetch. The application specifies the number of the 
row to update, delete, or insert, and the driver retrieves the new data for that 
row from the rowset buffers. SQLSetPos can also be used to designate a specified 
row as the current row, or to refresh a particular row in the rowset from the 
data source.

  
Rowset size is set by a call to SQLSetStmtAttr with an Attribute argument of 
SQL_ATTR_ROW_ARRAY_SIZE.

  
The first row in the rowset is row number 1. The RowNumber argument in SQLSetPos 
must identify a row in the rowset; that is, its value must be in the range 
between 1 and the number of rows that were most recently fetched (which may be 
less than the rowset size). If RowNumber is 0, the operation applies to every 
row in the rowset.


@strong{Updating rows in rowset:}@*
The update operation SQL_UPDATE of SQLSetPos makes the server to update one or 
more selected rows of a table, using data in the application buffers for each 
bound column.
  

To update rows with SQLSetPos, the application does the following:@*
@itemize @bullet 
@item  Places the new data values in the rowset buffers. 
@item  Sets the value in the length/indicator buffer of each column as necessary. 
  This is the byte length of the data or SQL_NTS for columns bound to string 
  buffers, the byte length of the data for columns bound to binary buffers, and 
  SQL_NULL_DATA for any columns to be set to NULL. 
@item  Calls SQLSetPos with Operation set to SQL_UPDATE and RowNumber set to the 
  number of the row to update. If RowNumber is 0, all rows in the rowset are 
  updated. 
@end itemize


After SQLSetPos returns, the current row is set to the updated row. Application 
can check the total number of rows affected by the update statement, calling 
SQLRowCount and the status of the update through SQL_ATTR_ROW_STATUS_PTR 
statement attribute.@*

  
@strong{Deleting rows in rowset:}@* 
The delete operation SQL_DELETE of SQLSetPos makes the server to delete one or 
more selected rows of a table. To delete rows with SQLSetPos, the application 
calls SQLSetPos with Operation set to SQL_DELETE and RowNumber set to the number 
of the row to delete. If RowNumber is 0, all rows in the rowset are deleted.

  
After SQLSetPos returns, the deleted row is the current row and its status is 
SQL_ROW_DELETED. The row cannot be used in any further positioned operations.


@node Catalog Functions , Transaction Control , Cursor Operations , Developing Applications Using MyODBC
@section Catalog Functions 

MySQL server supports @strong{SHOW} SQL syntax to provide formation about databases, 
tables, columns, or status information about the server. ODBC Applications can 
get the Meta data information about the server by using the following catalog 
functions:

@multitable @columnfractions .1 .9  
@item @strong{FUNCTION} @tab @strong{DESCRIPTION} 
@item SQLTables, @tab Returns a list of catalogs (databases), tables, or table types in 
      the server
@item SQLColumns, @tab Returns a list of columns in one or more tables.
@item SQLStatistics, @tab Returns a list of statistics about a single table. Also 
      returns a list of indexes associated with that table.
@item SQLSpecialColumns, @tab Returns a list of columns that uniquely identifies a row 
      in a single table. Also returns a list of columns in that table that are 
      automatically updated.
@item SQLPrimaryKeys, @tab Returns a list of columns that compose the primary key of a 
      single table. 
@item SQLForeignKeys,  @tab Returns a list of foreign keys in a single table or a list 
      of foreign keys in other tables that refer to a single table. 
@item SQLTablePrivileges,  @tab Returns a list of privileges associated with one or 
      more tables. 
@item SQLColumnPrivileges,  @tab Returns a list of privileges associated with one or 
      more columns in a single table. 
@item SQLGetTypeInfo,  @tab Returns a list of the SQL data types supported by the 
      server. These data types are generally used in CREATE TABLE and ALTER 
      TABLE statements. 
@end multitable


@node Transaction Control , Getting Diagnostic Information , Catalog Functions , Developing Applications Using MyODBC
@section Transaction Control 

A transaction is a sequence of one or more SQL statements that form a logical 
unit of work. Each SQL statement in the transaction performs part of a task and 
all of them are necessary for the task. Only when all SQL statements in the 
transaction are executed successfully we can treat the task as completed. 
  
Here is the general flow control of transaction: 
@itemize @bullet
@item  Start a transaction 
@item  Execute the statements 
@item  Commit or Rollback the statements   
@end itemize

By default, MyODBC/MySQL runs in autocommit mode. This means that as soon as you 
execute an SQL statement, MySQL will store the statement on disk.  If you are 
using transaction safe tables (like BDB, InnoDB, you can put MySQL into 
non-autocommit mode with the SQL command:

@example  
SET AUTOCOMMIT=0 
@end example
  
Through MyODBC, you can set the AUTOCOMMIT to either ON of OFF by using 
SQLSetConnectAttr (or SQLSetConnectOption in MyODBC 2.50) with attribute as 
SQL_ATTR_AUTOCOMMIT.
  
After this you must use SQLEndTran (or SQLTransact in MyODBC 2.50) to COMMIT 
your changes to disk or ROLLBACK if you want to ignore the changes you have made 
since the beginning of your transaction using SQL_COMMIT and SQL_ROLLBACK as the 
options.@*
  

@strong{Example:}@* 
In the following example, the application does the following set of operations, 
in order to demonstrate the transactional behavior:
@itemize @bullet  
@item  Creates a table of type BDB or InnoDB
@item  Sets the AUTOCOMMIT mode to off 
@item  Inserts a row of data and commits it 
@item  Now inserts a second row of data and rollbacks 
@item  Now you should be able to see only one row of data in the table. 
@end itemize
You can try the same with InnoDB by changing the table type. 
@example
       SQLHDBC hdbc; 
       SQLHSTMT hstmt; 
         
       /* Set AUTOCOMMIT to OFF */ 
       SQLSetConnectOption(hdbc,SQL_AUTOCOMMIT,SQL_AUTOCOMMIT_OFF); 
         
       /* CREATE TABLE t_tran of TYPE BDB */ 
       SQLExecDirect(hstmt,"drop table if exists t_tran",SQL_NTS);     
         
       SQLTransact(NULL,hdbc,SQL_COMMIT); 
          
       SQLExecDirect(hstmt,"create table t_tran(col1 int ,col2 varchar(30)) TYPE= BDB",SQL_NTS); 
          
       SQLTransact(NULL,hdbc,SQL_COMMIT); 
         
       /* INSERT A ROW OF DATA */ 
       SQLExecDirect(hstmt,"insert into t_tran values(10,'venu')",SQL_NTS); 
         
       /* Now, commit the insert */ 
       SQLTransact(NULL,hdbc,SQL_COMMIT); 
          
       /* Again INSERT second row of data */ 
       SQLExecDirect(hstmt,"insert into t_tran values(20,'mysql')",SQL_NTS); 
         
       /* Rollback the previous INSERT */ 
       SQLTransact(NULL,hdbc,SQL_ROLLBACK); 
          
       /* Now FETCH bac and check whether it has one row or not. */ 
       SQLFreeStmt(hstmt,SQL_CLOSE); 
          
       SQLExecDirect(hstmt,"select * from t_tran",SQL_NTS); 
          
       SQLFetch(hstmt); 
       assert(SQLFetch(hstmt) == SQL_NO_DATA_FOUND);  
      
       SQLFreeStmt(hstmt,SQL_CLOSE); 
@end example
  
Note If you are using MyODBC 3.51 driver, replace SQLSetConnectOption by 
SQLSetConnectAttr and SQLTransact by SQLEndTran.


@node Getting Diagnostic Information ,  , Transaction Control , Developing Applications Using MyODBC
@section Getting Diagnostic Information

All functions in MyODBC returns diagnostic information in two ways. The return 
code from the function indicates the overall success or failure or other 
relevant information of the function. If the application wants the detailed 
information about the function status, then diagnostic records provide detailed.
Diagnostic information is used to catch programming errors such as invalid 
handles, invalid function sequence and syntax errors in the SQL statements. It 
is used at run time to catch run-time errors and warnings such as data 
truncation, access violations, and syntax errors in SQL statements entered by 
the user.   


@strong{Return Codes:}@*
 
Each function in ODBC returns a code, known as its return code.  The following 
are the various return codes returned by MyODBC. 

@multitable @columnfractions .1 .9  
@item @strong{RETURN CODE} @tab @strong{DESCRIPTION} 
  
@item SQL_SUCCESS @tab The ODBC function executed successfully. 
@item SQL_SUCCESS_WITH_INFO @tab  The ODBC function was executed successfully, 
      but some warning information is being returned. The application can call 
      SQLGetDiagRec (or SQLError in case of MyODBC 2.50 driver) or 
      SQLGetDiagField to retrieve additional information. 
@item SQL_ERROR @tab  An error has occurred and the function failed. The application 
      can call SQLGetDiagRec (or SQLError in case of MyODBC 2.50 driver) or 
      SQLGetDiagField to retrieve additional information. 
@item SQL_NO_DATA @tab  No more data can be fetched 
@item SQL_NO_DATA_FOUND @tab  This is deprecated and is synonym to SQL_NO_DATA in the 
      case of MyODBC 2.50 driver 
@item SQL_INVALID_HANDLE @tab  An invalid handle was detected and the function 
      Failed. This indicates a programming error 
@item SQL_NEED_DATA @tab  The driver indicates the application must send parameter 
      data values. 
@end multitable

  
When an error occurred in the application i.e. when a function returned 
SQL_ERROR or SQL_SUCCESS_WITH_INFO, then application can request the diagnostic 
information by calling SQLGetDiagRec or SQLGetDiagField functions from the 
driver. In MyODBC 2.50 driver, the application can make use of SQLError in doing 
this job. Using MyODBC 3.51 driver, the application can request more diagnostic 
records or header information using SQLGetDiagField.
  

@strong{Using SQLGetDiagRec and SQLGetDiagField:}@* 
As described in the previous section, Applications call SQLGetDiagRec or 
SQLGetDiagField to retrieve diagnostic information in the case of MyODBC 3.51 
driver. These functions accept an environment, connection, statement, or 
descriptor handle and return diagnostics from the function that last used that 
handle. The diagnostics logged on a particular handle are discarded when a new 
function is called using that handle, as the driver is not capable of handling 
multiple records.
  

Applications retrieve individual diagnostic fields by calling SQLGetDiagField 
and specifying the field to retrieve. Certain diagnostic fields do not have any 
meaning for certain types of handles. For a list of diagnostic fields and their 
meanings, see the SQLGetDiagField function description.

  
Applications retrieve the SQLSTATE, native error code, and diagnostic message in 
a single call by calling SQLGetDiagRec; SQLGetDiagRec cannot be used to retrieve 
information from the header record.
  

@strong{Example:}@* 
Consider the following example, where the user is trying to drop a non-existing 
table, and driver returns SQL_ERROR, and application can fetch the diagnostic 
information using SQLGetDiagRec 
@example  
    SQLCHAR      SqlState[6], 
    SQLCHAR      ErrorMsg[SQL_MAX_MESSAGE_LENGTH]; 
    SQLINTEGER   NativeError; 
    SQLSMALLINT  MsgLen; 
    SQLRETURN    sql_return, diag_return; 
    SQLHSTMT      hstmt; 
      
    // Drop a non-existing table 
    sql_return= SQLExecDirect(hstmt, "DROP TABLE NON_EXISTANT_TABLES^&*", SQL_NTS); 
    if (sql_return == SQL_SUCCESS_WITH_INFO || sql_return == SQL_ERROR) 
    @{ 
      
     // Get the diag information. 
     Diag_return  = SQLGetDiagRec(SQL_HANDLE_STMT, hstmt, 
                                  1, SqlState, &NativeError,
                                  ErrorMsg, sizeof(ErrorMsg), 
                                  &MsgLen); 
     if(diag_return != SQL_NO_DATA) 
     @{ 
       DisplayError(SqlState,NativeError,Msg,MsgLen); 
     @} 
    @}
@end example




@c
@c Chapter 4
@c


@node MyODBC API Reference, MyODBC Data Types, Developing Applications Using MyODBC, Top
@chapter MyODBC API Reference

This chapter of the manual describes each function description(Syntax, Arguments and 
its usage) categorized by its functionality.


@menu
* MyODBC Function summary::     
* Mappping Deprecated Functions::  
* Establishing a connection::   
* Retrieving Driver and Data Source Information::  
* Setting and Retrieving Driver Attributes::  
* Preparing SQL requests::      
* Executing SQL statements::    
* Resultset::                   
* Diagnostic Information::      
* Meta Data Information::       
* Performing Transaction ::     
* Termination::                 
@end menu


Each function is defined as a C programming language function. Descriptions include 
the following:

@itemize @bullet 
@item
Purpose
@item
Syntax
@item
Arguments
@item
Return values
@item
Comments about the usage
@end itemize

@code{NOTE:} In general All APIs returns the following return codes
@*
@itemize @bullet
@item
SQL_SUCCESS
@item
SQL_SUCCESS_WITH_INFO 
@item
SQL_ERROR 
@item
SQL_INVALID_HANDLE 
@end itemize

And result set functions, such as SQLFetch, SQLFetchScroll, SQLGetData will 
also return @code{SQL_NO_DATA} or @code{SQL_NO_DATA_FOUND}.
  
Functions like SQLExecute, SQLExecDirect and SQLParamData will return 
@code{SQL_NEED_DATA} as the return code when supplying long or blob data 
in pieces.


@node MyODBC Function summary, Mappping Deprecated Functions, MyODBC API Reference, MyODBC API Reference
@section MyODBC Function Summary


An application can call SQLGetInfo function to obtain conformance 
information about MyODBC. To obtain information about support for a specific 
function in the driver, an application can call SQLGetFunctions.
  
Note MyODBC 3.51 driver for backward compatibility supports all deprecated 
functions.
  
Here is the list of MyODBC APIs grouped together based on the tasks:

@multitable @columnfractions .5 .5 .5 .5 .5 .6
@item @strong{Task} @tab @strong{Function name} @tab @strong{MyODBC} @tab @strong{MyODBC 3.51} @tab @strong{Conformance} @tab @strong{Purpose}

@item Connecting to a data source 
      @tab SQLAllocHandle @tab No @tab Yes @tab ISO 92 @tab Obtains an  environment, connection, statement, or descriptor handle. 
@item @tab SQLConnect @tab Yes @tab Yes @tab ISO 92 @tab Connects to a specific driver by data source name, user ID, 
      and password. 
@item @tab SQLDriverConnect @tab Yes  @tab Yes @tab ODBC @tab Connects to a specific driver by connection string or requests that the Driver Manager and driver display connection dialog boxes for the user. 
@item @tab SQLAllocEnv @tab Yes @tab Yes @tab Deprecated @tab Obtains an environment handle allocated from driver.    
@item @tab SQLAllocConnect @tab Yes @tab Yes @tab Deprecated @tab Obtains a connection handle 


@item Obtaining information about a driver and data source 
      @tab SQLDataSources @tab No @tab No @tab ISO 92 @tab Returns the list of available data sources, handled by the Driver Manager
@item @tab SQLDrivers @tab No @tab No @tab ODBC @tab Returns the list of installed drivers and their attributes, handles by Driver Manager
@item @tab SQLGetInfo @tab Yes @tab Yes @tab ISO 92 @tab Returns information about a specific driver and data source. 
@item @tab SQLGetFunctions @tab Yes @tab Yes @tab ISO 92 @tab Returns supported driver functions. 
@item @tab SQLGetTypeInfo @tab Yes @tab Yes @tab ISO 92 @tab Returns information about supported data types. 


@item Setting and retrieving driver attributes 
      @tab SQLSetConnectAttr @tab No @tab Yes @tab ISO 92 @tab Sets a connection attribute.
@item @tab SQLGetConnectAttr @tab No @tab Yes @tab ISO 92 @tab Returns the value of a connection attribute.
@item @tab SQLSetConnectOption @tab Yes @tab Yes @tab Deprecated @tab Sets a connection option
@item @tab SQLGetConnectOption @tab Yes @tab Yes @tab Deprecated @tab Returns the value of a connection option
@item @tab SQLSetEnvAttr @tab No @tab Yes @tab ISO 92 @tab Sets an environment attribute. 
@item @tab SQLGetEnvAttr @tab No @tab Yes @tab ISO 92 @tab  Returns the value of an environment attribute. 
@item @tab SQLSetStmtAttr @tab No @tab Yes @tab ISO 92 @tab Sets a statement attribute. 
@item @tab SQLGetStmtAttr @tab No @tab Yes @tab ISO 92 @tab Returns the value of a statement attribute. 
@item @tab SQLSetStmtOption @tab Yes @tab Yes @tab Deprecated @tab Sets a statement option
@item @tab SQLGetStmtOption @tab Yes @tab Yes @tab Deprecated @tab Returns the value of a statement option 


@item Preparing SQL requests 
      @tab SQLAllocStmt @tab Yes @tab Yes @tab Deprecated @tab Allocates a statement handle
@item @tab SQLPrepare @tab Yes @tab Yes @tab ISO 92 @tab Prepares an SQL statement for later execution. 
@item @tab SQLBindParameter @tab Yes @tab Yes @tab ODBC @tab Assigns storage for a parameter in an SQL statement. 
@item @tab SQLGetCursorName @tab  Yes @tab Yes @tab ISO 92 @tab Returns the cursor name associated with a statement handle. 
@item @tab SQLSetCursorName @tab Yes @tab Yes @tab ISO 92 @tab Specifies a cursor name. 
@item @tab SQLSetScrollOptions @tab Yes @tab Yes @tab ODBC @tab Sets options that control cursor behavior.

 
@item submitting requests 
      @tab SQLExecute @tab Yes @tab Yes @tab ISO 92 @tab Executes a prepared statement.
@item @tab SQLExecDirect @tab Yes @tab Yes @tab ISO 92 @tab Executes a statement
@item @tab SQLNativeSql @tab Yes @tab Yes @tab ODBC @tab Returns the text of an SQL statement as translated by the driver. 
@item @tab SQLDescribeParam @tab Yes @tab Yes @tab ODBC @tab Returns the description for a specific parameter in a statement. 
@item @tab SQLNumParams @tab Yes @tab Yes @tab ISO 92 @tab Returns the number of parameters in a statement. 
@item @tab SQLParamData @tab Yes @tab Yes @tab ISO 92 @tab Used in conjunction with SQLPutData to supply parameter data at execution time. (Useful for long data values.) 
@item @tab SQLPutData @tab Yes @tab Yes @tab ISO 92 @tab Sends part or all of a data value for a parameter. (Useful for long data values.) 


@item Retrieving results and information about results 
      @tab SQLRowCount @tab Yes @tab Yes @tab ISO 92 @tab Returns the number of rows affected by an insert, update, or delete request.
@item @tab SQLNumResultCols @tab Yes @tab Yes @tab ISO 92 @tab Returns the number of columns in the result set.
@item @tab SQLDescribeCol @tab  Yes @tab Yes @tab ISO 92  @tab Describes a column in the result set. 
@item @tab SQLColAttribute @tab No @tab Yes @tab ISO 92 @tab Describes attributes of a column in the result set. 
@item @tab SQLColAttributes  @tab Yes @tab Yes @tab Deprecated @tab  Describes attributes of a column in the result set. 
@item @tab SQLFetch @tab Yes @tab Yes @tab ISO 92 @tab  Returns multiple result rows. 
@item @tab SQLFetchScroll @tab No @tab Yes @tab ISO 92  @tab Returns scrollable result rows. 
@item @tab SQLExtendedFetch  @tab Yes @tab Yes @tab Deprecated  @tab Returns scrollable result rows. 
@item @tab SQLSetPos @tab Yes @tab Yes @tab ODBC @tab Positions a cursor within a fetched block of data and allows an application to refresh data in the rowset or to update or delete data  in the result set. 
@item @tab  SQLBulkOperations @tab No  @tab Yes @tab ODBC @tab  Performs bulk insertions and bulk bookmark operations, including update, delete, and fetch by bookmark. 


@item Retrieving error or diagnostic information 
      @tab SQLError @tab Yes @tab Yes @tab Deprecated  @tab Returns additional error or status information 
@item @tab SQLGetDiagField @tab Yes @tab Yes @tab ISO 92  @tab Returns additional diagnostic information (a single field of the diagnostic data structure). 
@item @tab SQLGetDiagRec @tab Yes @tab Yes @tab ISO 92 @tab  Returns additional diagnostic information (multiple fields of the diagnostic data structure). 


@item Obtaining information about the data source's system tables (catalog functions) item 
      @tab SQLColumnPrivileges @tab Yes @tab Yes @tab ODBC @tab Returns a list of columns and associated privileges for one or more tables.
@item @tab SQLColumns @tab Yes @tab Yes @tab X/Open @tab Returns the list of column names in specified tables.
@item @tab SQLForeignKeys @tab Yes @tab Yes @tab ODBC  @tab Returns a list of column names that make up foreign keys, if they exist for a specified table. 
@item @tab SQLPrimaryKeys @tab Yes @tab Yes @tab ODBC  @tab Returns the list of column names that make up the primary key for a table. 
@item @tab SQLSpecialColumns @tab Yes @tab Yes @tab X/Open  @tab Returns information about the optimal set of columns that uniquely identifies a row in a specified table, or the columns that are automatically updated when any value in the row is updated by a 
      transaction. 
@item @tab SQLStatistics @tab Yes @tab Yes @tab ISO 92 @tab Returns statistics about a single table and the list of indexes associated with the table. 
@item @tab SQLTablePrivileges  @tab Yes @tab Yes @tab ODBC @tab  Returns a list of tables and the privileges associated with each table. 
@item @tab SQLTables  @tab Yes @tab Yes @tab X/Open  @tab Returns the list of table names stored in a specific data source. 


@item Performing Transactions 
      @tab SQLTransact @tab Yes @tab Yes @tab Deprecated @tab Commits or rolls back a transaction  
@item @tab  SQLEndTran  @tab No  @tab Yes @tab ISO 92  @tab Commits or rolls back a transaction. 


@item Terminating a statement 
       @tab SQLFreeStmt @tab Yes @tab Yes @tab ISO 92 @tab  Ends statement processing, discards pending results, and, optionally, frees all resources associated with the statement handle. 
@item @tab SQLCloseCursor  @tab Yes @tab Yes @tab ISO 92  @tab Closes a cursor that has been opened on a statement handle. 
@item @tab SQLCancel  @tab Yes @tab Yes @tab ISO 92  @tab Cancels an SQL statement. 


@item Terminating a connection 
      @tab SQLDisconnect @tab Yes @tab Yes @tab ISO 92 @tab Closes the connection. 
@item @tab SQLFreeHandle @tab No  @tab Yes @tab ISO 92 @tab Releases an environment, connection, statement, or descriptor handle.
@item @tab SQLFreeConnect @tab Yes @tab Yes @tab Deprecated @tab Releases connection handle
@item @tab SQLFreeEnv @tab Yes @tab Yes @tab Deprecated @tab Releases an environment handle

@end multitable


@node Mappping Deprecated Functions, Establishing a connection, MyODBC Function summary, MyODBC API Reference
@section Mappping Deprecated Functions


This section describes how deprecated functions are mapped by the ODBC 3.x 
Driver Manager to guarantee backward compatibility with MyODBC 3.51 driver that 
are used with MyODBC 2.50. The Driver Manager performs this mapping regardless 
of the version of the application. Because each of the ODBC 2.x functions in the 
following list is mapped to the corresponding ODBC 3.x function when called in 
MyODBC 3.51 driver, the MyODBC 3.51driver does not have to implement the ODBC 
2.x functions. But for the sake of applications, which talk with driver directly 
without any driver manager, MyODBC 3.51 does support all 2.x functions.
  

The following table lists all duplicated functionality that was introduced in 
MyODBC 3.51 driver:

@multitable @columnfractions .1 .9
@item @strong{ODBC 2.x Function} @tab @strong{ODBC 3.x Function}
@item SQLAllocConnect @tab SQLAllocHandle with SQL_HANDLE_DBC
@item SQLAllocEnv @tab SQLAllocHandle with SQL_HANDLE_ENV
@item SQLAllocStmt @tab SQLAllocHandle with SQL_HANDLE_STMT
@item SQLColAttributes @tab SQLColAttribute
@item SQLError @tab SQLGetDiagRec
@item SQLFreeConnect @tab SQLFreeHandle with SQL_HANDLE_DBC
@item SQLFreeEnv @tab SQLFreeHandle with SQL_HANDLE_ENV
@item SQLFreeStmt with SQL_DROP @tab SQLFreeHandle with SQL_HANDLE_STMT
@item SQLSetConnectOption @tab SQLSetConnectAttr
@item SQLGetConnectOption @tab SQLGetConnectAttr
@item SQLSetStmtAttr @tab SQLSetStmtAttr
@item SQLGetStmtAttr @tab SQLGetStmtAttr
@item SQLParamOptions @tab SQLSetStmtAttr
@item SQLSetScrollOption @tab SQLSetStmtAttr
@item SQLTransact @tab SQLEndTran
@end multitable



@node Establishing a connection, Retrieving Driver and Data Source Information, Mappping Deprecated Functions, MyODBC API Reference
@section Establishing a connection


@menu
* SQLAllocHandle::              
* SQLAllocEnv::                 
* SQLAllocConnect::             
* SQLConnect::                  
* SQLDriverConnect::            
* SQLBrowseConnect::            
@end menu

@node SQLAllocHandle, SQLAllocEnv, Establishing a connection, Establishing a connection
@subsection SQLAllocHandle

@strong{SQLAllocHandle} allocates an environment, connection, statement, 
or descriptor handle.  

Note   This function is a generic function for allocating handles that 
replaces the ODBC 2.0 functions SQLAllocConnect, SQLAllocEnv, and SQLAllocStmt.
To allow applications calling SQLAllocHandle to work with ODBC 2.x drivers, a 
call to SQLAllocHandle is mapped in the Driver Manager to SQLAllocConnect, 
SQLAllocEnv, or SQLAllocStmt, as appropriate.

@subsubheading Syntax
@example
SQLRETURN SQLAllocHandle (
     SQLSMALLINT  HandleType,
     SQLHANDLE    InputHandle,
     SQLHANDLE*   OutputHandlePtr);
@end example

@subsubheading Arguments
@code{HandleType[Input]}@*
The type of handle to be allocated by SQLAllocHandle. Must be one of the 
following values:
SQL_HANDLE_ENV
SQL_HANDLE_DBC
SQL_HANDLE_STMT
SQL_HANDLE_DESC (not supported by the driver) 

@code{InputHandle[Input]}@*
The input handle in whose context the new handle is to be allocated. If 
HandleType is SQL_HANDLE_ENV, this is SQL_NULL_HANDLE. If HandleType is 
SQL_HANDLE_DBC, this must be an environment handle, and if it is 
SQL_HANDLE_STMT or SQL_HANDLE_DESC, it must be a connection handle.

@code{OutputHandlePtr[Output]}@*
Pointer to a buffer in which to return the handle to the newly allocated 
data structure.

@subsubheading Comments
@code{SQLAllocHandle} is used to allocate handles for environments, 
connections and statements, as described in the following sections. 
@code{Note} that, MyODBC does not support descriptors.

More than one environment, connection, or statement handle can be 
allocated by an application at a time if the driver supports 
multiple allocations. In MyODBC, no limit is defined on the number 
of environment, connection or statement handles that can be 
allocated at any one time.


If the application calls @ref{SQLAllocHandle} with *OutputHandlePtr 
set to an environment, connection or statement handle that already 
exists, the driver overwrites the information associated with the 
handle 
  

@code{Note} It is incorrect ODBC application programming to call 
@code{SQLAllocHandle} twice with the same application variable 
defined for *OutputHandlePtr without calling @code{SQLFreeHandle}
 to free the handle before reallocating it. Overwriting ODBC 
handles in such a manner can lead to inconsistent behavior or 
may lead to core dumps.
  

@code{SQLAllocHandle} does not set the SQL_ATTR_ODBC_VERSION environment 
attribute when it is called to allocate an environment handle; 
the environment attribute must be set by the application, or 
SQLSTATE HY010 (Function sequence error) will be returned when 
SQLAllocHandle is called to allocate a connection handle.
  

@strong{Allocating an Environment Handle:}
@*
An environment handle provides access to global information 
such as valid connection handles and active connection handles. 
For more information about how to allocate environment handle, 
@ref{Allocating the Environment Handle}.  

@strong{Allocating a Connection Handle:}
@*
A connection handle provides access to information such as the 
valid statement and descriptor handles on the connection and 
whether a transaction is currently open. For more information 
about how to allocate environment handle,
@xref{Allocating a Connection Handle}.  

@strong{Allocating a Statement Handle:}
@*
A statement handle provides access to statement information, 
such as error messages, the cursor name, and status information 
for SQL statement processing. For more information about how to 
allocate environment handle, @xref{Allocating a statement handle}.



@node SQLAllocEnv, SQLAllocConnect, SQLAllocHandle, Establishing a connection
@subsection SQLAllocEnv
@strong{SQLAllocEnv} allocates the memory for a environment handle.

@subsubheading Syntax
@example
SQLRETURN SQLAllocEnv (
     HENV*  EnvironmentHandle);
@end example

@subsubheading Comments
In ODBC 3.x, SQLAllocHandle has replaced the ODBC 2.x function SQLAllocEnv. 
For more information on how to allocate environment handle using 
SQLAllocHandle, @xref{SQLAllocHandle}, description.
@*    

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.



@node SQLAllocConnect, SQLConnect, SQLAllocEnv, Establishing a connection
@subsection SQLAllocConnect
@strong{SQLAllocConnect} allocates memory for a connection handle.

@subsubheading Syntax
@example
SQLRETURN SQLAllocConnect (
     HENV   EnvironmentHandle,
     HDBC*  ConnectionHandle);
@end example

@subsubheading Comments
In ODBC 3.x, SQLAllocHandle has replaced the ODBC 2.x function SQLAllocConnect.
For more information on how to allocate environment handle using SQLAllocHandle,
 @xref{SQLAllocHandle}, description.

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.


@node SQLConnect, SQLDriverConnect, SQLAllocConnect, Establishing a connection
@subsection SQLConnect
@strong{SQLConnect} establishes connections to a driver and a data source. The 
connection handle references storage of all information about the connection 
to the data source, including status, transaction state, and error information.

@subsubheading Syntax
@example
  SQLRETURN SQLConnect(
       SQLHDBC       ConnectionHandle,
       SQLCHAR *     ServerName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     UserName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     Authentication,
       SQLSMALLINT   NameLength3);
@end example

@subsubheading Arguments
@code{ConnectionHandle[Input]}@*
Connection handle.

@code{ServerName[Input]}@*
Data source name.

@code{NameLength1[Input]}@*
Length of *ServerName.

@code{UserName[Input]}@*
User identifier.

@code{NameLength2[Input]}@*
Length of *UserName.

@code{Authentication[Input]}@*
Authentication string (typically the password).

@code{NameLength3[Input]}@*
Length of *Authentication.

@subsubheading Comments
For more information about how an application uses SQLConnect to connect to MySQL 
server, see "Connecting with SQLConnect" in Chapter 3 under the 
@ref{Establishing a connection using MyODBC}



@node SQLDriverConnect, SQLBrowseConnect, SQLConnect, Establishing a connection
@subsection SQLDriverConnect
@strong{SQLDriverConnect} is an alternative to SQLConnect. It supports data 
sources that require more connection information than the three arguments in 
SQLConnect, dialog boxes to prompt the user for all connection information, 
and data sources that are not defined in the system information.
    

@strong{SQLDriverConnect} provides the following connection attributes:
@itemize 
@item
Establish a connection using a connection string that contains the data 
source name, one or more user IDs, one or more passwords, and other 
information required by the server. For more information regarding the list 
of connection parameters supported by the driver, @ref{Connection parameters}. 
@item
Establish a connection using a partial connection string or no additional 
information; in this case, the Driver Manager and the driver can each prompt 
he user for connection information. 
@item
Establish a connection to a data source that is not defined in the system 
information. If the application supplies a partial connection string, the 
driver can prompt the user for connection information. 
@item
Establish a connection to a data source using a connection string 
constructed from the information in a .dsn file. 
@end itemize

After a connection is established, @strong{SQLDriverConnect} returns the 
completed connection string. The application can use this string for 
subsequent connection requests.

@subsubheading Syntax
@example
  SQLRETURN SQLDriverConnect (
       SQLHDBC       ConnectionHandle,
       SQLHWND       WindowHandle,
       SQLCHAR *     InConnectionString,
       SQLSMALLINT   StringLength1,
       SQLCHAR *     OutConnectionString,
       SQLSMALLINT   BufferLength,
       SQLSMALLINT * StringLength2Ptr,
       SQLUSMALLINT  DriverCompletion);
@end example

@subsubheading Arguments
@code{ConnectionHandle [Input]}@*
  Connection handle.

@code{WndowHandle [Input]}@*
  Window handle. The application can pass the handle of the parent window, if 
  applicable, or a null pointer if either the window handle is not applicable or 
  SQLDriverConnect will not present any dialog boxes.

@code{InConnectionString [Input]}@*
  A full connection, a partial connection string, or an empty string.

@code{ StringLength1 [Input]}@*
  Length of *InConnectionString, in bytes.

@code{OutConnectionString [Output]}@*
  Pointer to a buffer for the completed connection string. Upon successful 
  connection to the target data source, this buffer contains the completed 
  connection string. Applications should allocate at least 1,024 bytes for this 
  buffer.

@code{BufferLength [Input]}@*
  Length of the *OutConnectionString buffer.

@code{StringLength2Ptr [Output]}@*
  Pointer to a buffer in which to return the total number of characters 
  (excluding the null-termination character) available to return in 
  *OutConnectionString. If the number of characters available to return is 
  greater than or equal to BufferLength, the completed connection string in 
  *OutConnectionString is truncated to BufferLength minus the length of a 
  null-termination character.

@code{DriverCompletion [Input]}@*
  Flag that indicates whether the Driver Manager or driver must prompt for more 
  connection information:
  SQL_DRIVER_PROMPT,
  SQL_DRIVER_COMPLETE,
  SQL_DRIVER_COMPLETE_REQUIRED, or
  SQL_DRIVER_NOPROMPT.

@subsubheading Comments
For information about how an application uses SQLDriverConnect to connect to 
MySQL server, see "Connecting with SQLDriverConnect" in Chapter 3 under 
the @ref{Establishing a connection using MyODBC}.


@node SQLBrowseConnect,  , SQLDriverConnect, Establishing a connection
@subsection SQLBrowseConnect
@code{Not supported}.



@node Retrieving Driver and Data Source Information, Setting and Retrieving Driver Attributes, Establishing a connection, MyODBC API Reference
@section Retrieving Driver and Data Source Information


@menu
* SQLDataSources::              
* SQLDrivers::                  
* SQLGetInfo::                  
* SQLGetFunctions::             
* SQLGetTypeInfo::              
@end menu

@node SQLDataSources, SQLDrivers, Retrieving Driver and Data Source Information, Retrieving Driver and Data Source Information
@subsection SQLDataSources
@strong{SQLDataSources} returns information about a data source. This function is implemented solely by the Driver Manager. For more information about this API, refer to the driver manager documentation.



@node SQLDrivers, SQLGetInfo, SQLDataSources, Retrieving Driver and Data Source Information
@subsection SQLDrivers
@strong{SQLDrivers} lists driver descriptions and driver attribute keywords. This function is implemented solely by the Driver Manager. For more information about this API, refer to the driver manager documentation.


@node SQLGetInfo, SQLGetFunctions, SQLDrivers, Retrieving Driver and Data Source Information
@subsection SQLGetInfo
@strong{SQLGetInfo} returns general information about the driver and the server 
associated with a connection.
  
@subsubheading Syntax
@example
  SQLRETURN SQLGetInfo(
       SQLHDBC        ConnectionHandle,
       SQLUSMALLINT   InfoType,
       SQLPOINTER     InfoValuePtr,
       SQLSMALLINT    BufferLength,
       SQLSMALLINT *  StringLengthPtr);
@end example

@subsubheading Arguments
@code{ConnectionHandle [Input]}@*
  Connection handle.

@code{InfoType [Input]}@*
  Type of information, described in the “comments” section

@code{InfoValuePtr [Output]}@*
  Pointer to a buffer in which to return the information. Depending on the 
  InfoType requested, the information returned will be one of the following: a 
  null-terminated character string, an SQLUSMALLINT value, an SQLUINTEGER 
  bitmask, an SQLUINTEGER flag, or a SQLUINTEGER binary value.

  If the InfoType argument is SQL_DRIVER_HDESC or SQL_DRIVER_HSTMT, the 
  InfoValuePtr argument is both input and output. (See the SQL_DRIVER_HDESC or 
  SQL_DRIVER_HSTMT descriptors later in this function description for more 
  information.)

@code{BufferLength [Input]}@*
  Length of the *InfoValuePtr buffer. If the value in *InfoValuePtr is not a 
  character string or if InfoValuePtr is a null pointer, the BufferLength 
  argument is ignored. The driver assumes that the size of *InfoValuePtr is 
  SQLUSMALLINT or SQLUINTEGER, based on the InfoType. If *InfoValuePtr is a 
  Unicode string (when calling SQLGetInfoW), the BufferLength argument must be 
  an even number; if not, SQLSTATE HY090 (Invalid string or buffer length) is 
  returned.

@code{StringLengthPtr [Output]}@*
  Pointer to a buffer in which to return the total number of bytes (excluding 
  the null-termination character for character data) available to return in 
  *InfoValuePtr.

  For character data, if the number of bytes available to return is greater than 
  or equal to BufferLength, the information in *InfoValuePtr is truncated to 
  BufferLength bytes minus the length of a null-termination character and is 
  null-terminated by the driver.

  For all other types of data, the value of BufferLength is ignored and the 
  driver assumes the size of *InfoValuePtr is SQLUSMALLINT or SQLUINTEGER, 
  depending on the InfoType.  



@node SQLGetFunctions, SQLGetTypeInfo, SQLGetInfo, Retrieving Driver and Data Source Information
@subsection SQLGetFunctions
@strong{SQLGetFunctions} returns information about whether a driver supports a specific 
ODBC function.
    
@subsubheading Syntax
@example
  SQLRETURN SQLGetFunctions(
       SQLHDBC         ConnectionHandle,
       SQLUSMALLINT    FunctionId,
       SQLUSMALLINT *  SupportedPtr);
@end example

@subsubheading Arguments
@code{ConnectionHandle [Input]}@*
  Connection handle.

@code{FunctionId [Input]}@*
  SQL_API_ODBC3_ALL_FUNCTIONS or SQL_API_ALL_FUNCTIONS. 

  SQL_API_ODBC3_ALL_FUNCTIONS is used by an ODBC 3.x application to determine 
  support of ODBC 3.x and earlier functions. SQL_API_ALL_FUNCTIONS is used by an 
  ODBC 2.x application to determine support of ODBC 2.x and earlier functions. 
  Or even application can pass individual function id to determine whether the 
  driver supports that function or not.

@code{SupportedPtr [Output]}@*
  If FunctionId identifies a single ODBC function, SupportedPtr points to a 
  single SQLUSMALLINT value that is SQL_TRUE if the specified function is 
  supported by the driver, and SQL_FALSE if it is not supported.

  If FunctionId is SQL_API_ODBC3_ALL_FUNCTIONS, SupportedPtr points to a 
  SQLSMALLINT array with a number of elements equal to 
  SQL_API_ODBC3_ALL_FUNCTIONS_SIZE. An ODBC 3.x application can call 
  SQLGetFunctions with SQL_API_ODBC3_ALL_FUNCTIONS against either an ODBC 3.x or 
  ODBC 2.x driver.

  If FunctionId is SQL_API_ALL_FUNCTIONS, SupportedPtr points to an SQLUSMALLINT 
  array of 100 elements. An element is SQL_TRUE if it identifies an ODBC 2.x or 
  earlier function supported by the driver. It is SQL_FALSE if it identifies an 
  ODBC function not supported by the driver or does not identify an ODBC 
  function.

  The arrays returned in *SupportedPtr use zero-based indexing.


@node SQLGetTypeInfo,  , SQLGetFunctions, Retrieving Driver and Data Source Information
@subsection SQLGetTypeInfo
@strong{SQLGetTypeInfo} returns information about data types supported by the server. 
The driver returns the information in the form of an SQL result set. The data 
types are intended for use in Data Definition Language (DDL) statements.
Important   Applications must use the type names returned in the TYPE_NAME 
column of the SQLGetTypeInfo result set in ALTER TABLE and CREATE TABLE 
statements. SQLGetTypeInfo may return more than one row with the same value in 
the DATA_TYPE column.

@subsubheading Syntax
@example
  SQLRETURN  SQLGetTypeInfo(
       SQLHSTMT     StatementHandle,
       SQLSMALLINT  DataType);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
Statement handle for the result set.

@code{DataType [Input]}@*
The SQL data type. SQL_ALL_TYPES specifies that information about all data 
types should be returned.



@node Setting and Retrieving Driver Attributes, Preparing SQL requests, Retrieving Driver and Data Source Information, MyODBC API Reference
@section Setting and Retrieving Driver Attributes


@menu
* SQLSetConnectAttr::           
* SQLGetConnectAttr::           
* SQLSetConnectOption::         
* SQLGetConnectOption::         
* SQLSetEnvAttr::               
* SQLGetEnvAttr::               
* SQLSetStmtAttr::              
* SQLGetStmtAttr::              
* SQLSetStmtOption::            
* SQLGetStmtOption::            
@end menu

@node SQLSetConnectAttr, SQLGetConnectAttr, Setting and Retrieving Driver Attributes, Setting and Retrieving Driver Attributes
@subsection SQLSetConnectAttr
@strong{SQLSetConnectAttr} sets attributes that govern aspects of connections.

@subsubheading Syntax
@example
  SQLRETURN SQLSetConnectAttr(
       SQLHDBC       ConnectionHandle,
       SQLINTEGER    Attribute,
       SQLPOINTER    ValuePtr,
       SQLINTEGER    StringLength);
@end example

@subsubheading Arguments
@code{ConnectionHandle [Input]}@*
  Connection handle.

@code{Attribute [Input]}@*
  Attribute to set, listed in "Comments."

@code{ValuePtr [Input]}@*
  Pointer to the value to be associated with Attribute. Depending on the value 
  of Attribute, ValuePtr will be a 32-bit unsigned integer value or will point 
  to a null-terminated character string. Note that if the Attribute argument is 
  a driver-specific value, the value in ValuePtr may be a signed integer.

@code{StringLength [Input]}@*
If Attribute is an ODBC-defined attribute and ValuePtr points to a character 
string or a binary buffer, this argument should be the length of *ValuePtr.
@* 
If Attribute is an ODBC-defined attribute and ValuePtr is an integer, 
StringLength is ignored.

@itemize @bullet
@item
If ValuePtr is a pointer to a character string, then StringLength is 
the length of the string or SQL_NTS.
@item
If ValuePtr is a pointer to a binary buffer, then the application 
places the result of the SQL_LEN_BINARY_ATTR(length) macro in StringLength. 
This places a negative value in StringLength.
@item
If ValuePtr is a pointer to a value other than a character string or 
a binary string, then StringLength should have the value SQL_IS_POINTER.
@item
If ValuePtr contains a fixed-length value, then StringLength is 
 either SQL_IS_INTEGER or SQL_IS_UINTEGER, as appropriate.
@end itemize

@subsubheading Comments
Here are the lists of connection attributes that are supported by MyODBC 3.51 
driver:

@multitable @columnfractions .1 .9
@item @strong{Attribute} @tab @strong{Contents of ValuePtr}
@item SQL_ATTR_ACCESS_MODE @tab An SQLUINTEGER value, and driver does not allow the 
        user to set this attribute to other than SQL_MODE_READ_WRITE. 
@item SQL_ATTR_ASYNC_ENABLE @tab An SQLUINTEGER value that specifies the 
        asynchronous execution. Driver does not support asynchronous execution, 
        so one can only set it to SQL_ASYNC_ENABLE_OFF 
        SQL_ATTR_AUTO_IPD A read-only SQLUINTEGER value, and driver returns the 
        default as SQL_FALSE 
@item SQL_ATTR_AUTOCOMMIT @tab An SQLUINTEGER value that specifies whether to use 
        autocommit or manual-commit mode:@*
        SQL_AUTOCOMMIT_OFF = The driver uses manual-commit mode, and the 
        application must explicitly commit or roll back transactions with 
        SQLEndTran. @*
        SQL_AUTOCOMMIT_ON = The driver uses autocommit mode. Each statement is 
        committed immediately after it is executed. This is the default. Any 
        open transactions on the connection are committed when 
        SQL_ATTR_AUTOCOMMIT is set to SQL_AUTOCOMMIT_ON to change from 
        manual-commit mode to autocommit mode. 
@item SQL_ATTR_CONNECTION_DEAD @tab An SQLUINTERGER value that indicates the state 
        of the connection. If SQL_CD_TRUE, the connection has been lost. If 
        SQL_CD_FALSE, the connection is still active. 
@item SQL_ATTR_CONNECTION_TIMEOUT @tab An SQLUINTEGER value corresponding to the 
        number of seconds to wait for any request on the connection to complete 
        before returning to the application. The driver should return SQLSTATE 
        HYT00 (Timeout expired) anytime that it is possible to time out in a 
        situation not associated with query execution or login. @*
        If ValuePtr is equal to 0 (the default), there is no timeout.
@item SQL_ATTR_CURRENT_CATALOG @tab A character string containing the name of the 
        catalog to be used by the data source. For example, in SQL Server, the 
        catalog is a database, so the driver sends a @strong{USE} database statement 
        to the data source, where database is the database specified in *ValuePtr. 
        For a single-tier driver, the catalog might be a directory, so the 
        driver changes its current directory to the directory specified in 
        *ValuePtr 
@item SQL_ATTR_LOGIN_TIMEOUT @tab An SQLUINTEGER value corresponding to the number 
        of seconds to wait for a login request to complete before returning to 
        the application. The default is driver-dependent. If ValuePtr is 0, the 
        timeout is disabled and a connection attempt will wait indefinitely. 
        If the specified timeout exceeds the maximum login timeout in the data 
        source, the driver substitutes that value and returns SQLSTATE 01S02 
        (Option value changed). 
@item SQL_ATTR_METADATA_ID @tab An SQLUINTEGER value that determines how the string 
        arguments of catalog functions are treated. Driver supports only to SQL_FALSE.
@item SQL_ATTR_ODBC_CURSORS @tab An SQLUINTEGER value specifying how the Driver 
        Manager uses the ODBC cursor library, and is supported by Driver Manager not
        by the driver.
@item SQL_ATTR_PACKET_SIZE @tab An SQLUINTEGER value specifying the network packet 
        size in bytes.
@item SQL_ATTR_QUIET_MODE @tab A 32-bit window handle (hwnd). 
        If the window handle is a null pointer, the driver does not display any 
        dialog boxes. 
        If the window handle is not a null pointer, it should be the parent 
        window handle of the application. This is the default. The driver uses 
        this handle to display dialog boxes 
@item SQL_ATTR_TRACE @tab An SQLUINTEGER value telling the Driver Manager whether 
        to perform tracing: @*
        SQL_OPT_TRACE_OFF = Tracing off (the default) @*
        SQL_OPT_TRACE_ON = Tracing on
@item SQL_ATTR_TRACEFILE @tab A null-terminated character string containing the name of the trace file
@item SQL_ATTR_TRANSLATE_LIB @tab A null-terminated character string containing the 
        name of a library containing the functions @strong{SQLDriverToDataSource} and 
        @strong{SQLDataSourceToDriver} that the driver accesses to perform tasks such as 
        character set translation 
@item SQL_ATTR_TRANSLATE_OPTION @tab A 32-bit flag value that is passed to the 
        translation DLL 
@item SQL_ATTR_TXN_ISOLATION @tab A 32-bit bit mask that sets the transaction 
        isolation level for the current connection. An application must call 
        SQLEndTran to commit or roll back all open transactions on a connection, 
        before calling SQLSetConnectAttr with this option. @*
        The valid values for ValuePtr can be determined by calling SQLGetInfo 
        with InfoType equal to SQL_TXN_ISOLATION_OPTIONS. For a description of 
        transaction isolation levels, see the description of the 
        SQL_DEFAULT_TXN_ISOLATION information type in SQLGetInfo 
@end multitable



@node SQLGetConnectAttr, SQLSetConnectOption, SQLSetConnectAttr, Setting and Retrieving Driver Attributes
@subsection SQLGetConnectAttr
@strong{SQLGetConnectAttr} returns the current setting of a connection attribute.

@subsubheading Syntax
@example
  SQLRETURN SQLGetConnectAttr(
       SQLHDBC       ConnectionHandle,
       SQLINTEGER    Attribute,
       SQLPOINTER    ValuePtr,
       SQLINTEGER    BufferLength,
       SQLINTEGER *  StringLengthPtr);
@end example

@subsubheading Arguments
@code{ConnectionHandle [Input]}@*
  Connection handle.

@code{Attribute [Input]}@*
  Attribute to retrieve. For the list of connection attributes, refer to 
  @ref{SQLSetConnectAttr}

@code{ValuePtr [Input]}@*
  A pointer to memory in which to return the current value of the attribute 
  specified by Attribute.

@code{BufferLength [Input]}@*
If Attribute is an ODBC-defined attribute and ValuePtr points to a character 
string or a binary buffer, this argument should be the length of *ValuePtr. If 
Attribute is an ODBC-defined attribute and *ValuePtr is an integer, 
BufferLength is ignored.
@itemize bullet
@item
If *ValuePtr is a pointer to a character string, then BufferLength is 
the length of the string or SQL_NTS.
@item
If *ValuePtr is a pointer to a binary buffer, then the application 
places the result of the SQL_LEN_BINARY_ATTR(length) macro in BufferLength. 
This places a negative value in BufferLength.
@item
If *ValuePtr is a pointer to a value other than a character string or 
binary string, then BufferLength should have the value SQL_IS_POINTER.
@item
If *ValuePtr contains a fixed-length data type, then BufferLength is 
either SQL_IS_INTEGER or SQL_IS_UINTEGER, as appropriate.
@end itemize

@code{StringLengthPtr [Output]}@*
A pointer to a buffer in which to return the total number of bytes (excluding 
the null-termination character) available to return in *ValuePtr. If *ValuePtr 
is a null pointer, no length is returned. If the attribute value is a 
character string and the number of bytes available to return is greater than 
BufferLength minus the length of the null-termination character, the data in 
*ValuePtr is truncated to BufferLength minus the length of the 
null-termination character and is null-terminated by the driver.



@node SQLSetConnectOption, SQLGetConnectOption, SQLGetConnectAttr, Setting and Retrieving Driver Attributes
@subsection SQLSetConnectOption
In ODBC 3.x, @strong{SQLSetConnectAttr} has replaced @strong{SQLSetConnectOption}. For more 
information, see @ref{SQLSetConnectAttr}

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.


@node SQLGetConnectOption, SQLSetEnvAttr, SQLSetConnectOption, Setting and Retrieving Driver Attributes
@subsection SQLGetConnectOption
In ODBC 3.x, @strong{SQLGetConnectAttr} has replaced @strong{SQLGetConnectOption}. For more 
information, see @ref{SQLGetConnectAttr}

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.


@node SQLSetEnvAttr, SQLGetEnvAttr, SQLGetConnectOption, Setting and Retrieving Driver Attributes
@subsection SQLSetEnvAttr
@strong{SQLSetEnvAttr} sets attributes that govern aspects of environments.

@subsubheading Syntax
@example
  SQLRETURN SQLSetEnvAttr(
       SQLHENV        EnvironmentHandle,
       SQLINTEGER     Attribute,
       SQLPOINTER     ValuePtr,
       SQLINTEGER     StringLength);
@end example

@subsubheading Arguments
@code{EnvironmentHandle [Input]}@*
Environment handle.

@code{Attribute [Input]}@*
Attribute to set, listed in "Comments."

@code{ValuePtr [Input]}@*
Pointer to the value to be associated with Attribute. Depending on the 
value of Attribute, ValuePtr will be a 32-bit integer value or point to a 
null-terminated character string.

@code{StringLength [Input]}@*
If ValuePtr points to a character string or a binary buffer, this 
argument should be the length of *ValuePtr. If ValuePtr is an integer, 
StringLength is ignored.

@subsubheading Comments
An application can call SQLSetEnvAttr only if no connection handle is 
allocated on the environment. All environment attributes successfully set by 
the application for the environment persist until SQLFreeHandle is called on 
the environment. The following table lists the different environment 
attributes supported by the driver:

@multitable @columnfractions .1 .9
@item @strong{Attribute} @tab @strong{Contents of ValuePtr}

@item SQL_ATTR_CONNECTION_POOLING @tab A 32-bit SQLUINTEGER value that enables or 
      disables connection pooling. 
@item SQL_ATTR_CP_MATCH @tab A 32-bit SQLUINTEGER value that determines how a 
      connection is chosen from a connection pool. Refer to Driver Manager help 
      about the connection pooling, 
@item SQL_ATTR_ODBC_VERSION @tab A 32-bit integer that determines whether certain 
      functionality exhibits ODBC 2.x behavior or ODBC 3.x behavior. The 
      following values are used to set the value of this attribute:@*
      @code{SQL_OV_ODBC3}@*
      @code{SQL_OV_ODBC2}@*
      For more information, refer to @ref{Declaring the Application ODBC Version} 
@item SQL_ATTR_OUTPUT_NTS @tab  A 32-bit integer that determines how the driver 
      returns string data. If SQL_TRUE, the driver returns string data 
      null-terminated. If SQL_FALSE, the driver does not return string data 
      null-terminated. Driver supports only to default value SQL_TRUE. 
@end multitable


@node SQLGetEnvAttr, SQLSetStmtAttr, SQLSetEnvAttr, Setting and Retrieving Driver Attributes
@subsection SQLGetEnvAttr
@strong{SQLGetEnvAttr} returns the current setting of an environment attribute.

@subsubheading Syntax
@example
  SQLRETURN SQLGetEnvAttr(
       SQLHENV        EnvironmentHandle,
       SQLINTEGER     Attribute,
       SQLPOINTER     ValuePtr,
       SQLINTEGER     BufferLength,
       SQLINTEGER *   StringLengthPtr);
@end example

@subsubheading Arguments

@code{EnvironmentHandle [Input]}@*
Environment handle.

@code{Attribute [Input]}@*
Attribute to retrieve, refer to @ref{SQLSetEnvAttr} the list of environment
attributes.

@code{ValuePtr [Output]}@*
Pointer to a buffer in which to return the current value of the attribute 
specified by Attribute.

@code{BufferLength [Input]}@*
If ValuePtr points to a character string, this argument should be the length 
of *ValuePtr. If *ValuePtr is an integer, BufferLength is ignored. If the 
attribute value is not a character string, BufferLength is unused.

@code{StringLength [Output]}@*
A pointer to a buffer in which to return the total number of bytes (excluding 
the null-termination character) available to return in *ValuePtr. If ValuePtr 
is a null pointer, no length is returned. If the attribute value is a 
character string and the number of bytes available to return is greater than 
or equal to BufferLength, the data in *ValuePtr is truncated to BufferLength 
minus the length of a null-termination character and is null-terminated by the 
driver.



@node SQLSetStmtAttr, SQLGetStmtAttr, SQLGetEnvAttr, Setting and Retrieving Driver Attributes
@subsection SQLSetStmtAttr
@strong{SQLSetStmtAttr} sets attributes related to a statement.

@subsubheading Syntax
@example
  SQLRETURN SQLSetStmtAttr(
       SQLHSTMT       StatementHandle,
       SQLINTEGER     Attribute,
       SQLPOINTER     ValuePtr,
       SQLINTEGER     StringLength);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
 Statement handle.

@code{Attribute [Input]}@*
Option to set, listed in "Comments."

@code{ValuePtr [Input]}@*
Pointer to the value to be associated with Attribute. Depending on the 
value of Attribute, ValuePtr will be a 32-bit unsigned integer value or a 
pointer to a null-terminated character string, a binary buffer, or a 
driver-defined value. If the Attribute argument is a driver-specific value, 
ValuePtr may be a signed integer.

@code{StringLength [Input]}@*
If Attribute is an ODBC-defined attribute and ValuePtr points to a 
character string or a binary buffer, this argument should be the length of 
*ValuePtr. If Attribute is an ODBC-defined attribute and ValuePtr is an 
integer, StringLength is ignored.
If Attribute is a driver-defined attribute, the application indicates the 
nature of the attribute to the Driver Manager by setting the StringLength 
argument. StringLength can have the following values:
@itemize @bullet
@item If ValuePtr is a pointer to a character string, then StringLength is 
  the length of the string or SQL_NTS.
@item If ValuePtr is a pointer to a binary buffer, then the application 
  places the result of the SQL_LEN_BINARY_ATTR(length) macro in StringLength. 
  This places a negative value in StringLength.
@item If ValuePtr is a pointer to a value other than a character string or 
  a binary string, then StringLength should have the value SQL_IS_POINTER.
@item If ValuePtr contains a fixed-length value, then StringLength is 
  either SQL_IS_INTEGER or SQL_IS_UINTEGER, as appropriate.
@end itemize

@subsubheading Comments
Statement attributes for a statement remain in effect until they are changed 
by another call to SQLSetStmtAttr or until the statement is dropped by 
calling @ref{SQLFreeHandle}. 

@multitable @columnfractions .1 .9
@item @strong{Attribute} @tab @strong{Contents of ValuePtr}
@item SQL_ATTR_APP_PARAM_DESC @tab  Not supported 
@item SQL_ATTR_APP_ROW_DESC @tab Not supported 
@item SQL_ATTR_ASYNC_ENABLE  @tab An SQLUINTEGER value that specifies whether 
      a function called with the 
      specified statement is executed asynchronously: @*
      @code{SQL_ASYNC_ENABLE_OFF = Off (the default)}@*
      @code{SQL_ASYNC_ENABLE_ON = On}@*
      Driver does not support asynchronous execution, so application can only 
      set it to default value. 
@item SQL_ATTR_CONCURRENCY @tab 
      An SQLUINTEGER value that specifies the cursor concurrency:@*
      @code{SQL_CONCUR_READ_ONLY:} Cursor is read-only. No updates are allowed.@*
      @code{SQL_CONCUR_LOCK:} Cursor uses the lowest level of locking sufficient to 
      ensure that the row can be updated.@* 
      @code{SQL_CONCUR_ROWVER:} Cursor uses optimistic concurrency control.@* 
      @code{SQL_CONCUR_VALUES:} Cursor uses optimistic concurrency control, comparing 
      values. @*
      The default value for @code{SQL_ATTR_CONCURRENCY} is @code{SQL_CONCUR_READ_ONLY}. 
      Driver only supports @code{SQL_CONCUR_ROWVER}. 
@item SQL_ATTR_CURSOR_SCROLLABLE @tab
      An SQLUINTEGER value that specifies the level of support that the 
      application requires. Setting this attribute affects subsequent calls to 
      SQLExecDirect and SQLExecute.@*
      @code{SQL_NONSCROLLABLE:} Scrollable cursors are not required on the statement 
      handle. If the application calls SQLFetchScroll on this handle, the only 
      valid value of FetchOrientation is @code{SQL_FETCH_NEXT}. This is the default.@*
      @code{SQL_SCROLLABLE:} Scrollable cursors are required on the statement handle. 
      When calling SQLFetchScroll, the application may specify any valid value 
      of FetchOrientation, achieving cursor positioning in modes other than the 
      sequential mode. 
@item SQL_ATTR_CURSOR_SENSITIVITY @tab  
      An SQLUINTEGER value that specifies whether cursors on the statement 
      handle make visible the changes made to a result set by another cursor. 
      Setting this attribute affects subsequent calls to SQLExecDirect and 
      SQLExecute. An application can read back the value of this attribute to 
      obtain its initial state or its state as most recently set by the 
      application. @*
      @code{SQL_UNSPECIFIED:} It is unspecified what the cursor type is and whether 
      cursors on the statement handle make visible the changes made to a result 
      set by another cursor. Cursors on the statement handle may make visible 
      none, some, or all such changes. This is the default.@*
      @code{SQL_INSENSITIVE:} All cursors on the statement handle show the result set 
      without reflecting any changes made to it by any other cursor. Insensitive 
      cursors are read-only. This corresponds to a static cursor, which has a 
      concurrency that is read-only.@*
      @code{SQL_SENSITIVE:} All cursors on the statement handle make visible all 
      changes made to a result set by another cursor.@*
      Driver supports only @code{SQL_SENSITIVE} or @code{SQL_INSENSITIVE} 
@item SQL_ATTR_CURSOR_TYPE @tab
      An SQLUINTEGER value that specifies the cursor type:@*
      @code{SQL_CURSOR_FORWARD_ONLY:}@* The cursor only scrolls forward.@*
      @code{SQL_CURSOR_STATIC:}@* The data in the result set is static.@* 
      @code{SQL_CURSOR_KEYSET_DRIVEN:}@* The driver saves and uses the keys for the 
      number of rows specified in the @code{SQL_ATTR_KEYSET_SIZE} statement attribute.@* 
      @code{SQL_CURSOR_DYNAMIC:}@* The driver saves and uses only the keys for the rows 
      in the rowset.@* 
      The default value is @code{SQL_CURSOR_FORWARD_ONLY}. This attribute cannot be 
      specified after the SQL statement has been prepared. Driver does support 
      only forward-only and static cursor types.@* 
@item SQL_ATTR_KEYSET_SIZE @tab
      An SQLUINTEGER that specifies the number of rows in the keyset for a 
      keyset-driven cursor. As driver does not support keyset-driven cursors, 
      this attribute is ignored 
@item SQL_ATTR_MAX_LENGTH @tab
      An SQLUINTEGER value that specifies the maximum amount of data that the 
      driver returns from a character or binary column. If ValuePtr is less than 
      the length of the available data, SQLFetch or SQLGetData truncates the 
      data and returns SQL_SUCCESS. If ValuePtr is 0 (the default), the driver 
      attempts to return all available data. 
@item SQL_ATTR_MAX_ROWS @tab
      An SQLUINTEGER value corresponding to the maximum number of rows to return 
      to the application for a SELECT statement. If *ValuePtr equals 0 (the 
      default), the driver returns all rows. 
@item SQL_ATTR_METADATA_ID @tab
      An SQLUINTEGER value that determines how the string arguments of catalog 
      functions are treated.@* 
      If @code{SQL_TRUE}, the string argument of catalog functions are treated as identifiers. The case is not significant.@*
      @code{SQL_FALSE}, the string arguments of catalog functions are not treated as identifiers. The case is significant. They can either contain a string      search pattern or not, depending on the argument. @*
      The default value is SQL_FALSE, and driver supports only to default value 
@item SQL_ATTR_NOSCAN @tab
      An SQLUINTEGER value that indicates whether the driver should scan SQL 
      strings for escape sequences:@* 
      @code{SQL_NOSCAN_OFF:} The driver scans SQL strings for escape sequences (the 
      default). @*
      @code{SQL_NOSCAN_ON:} The driver does not scan SQL strings for escape sequences. 
      Instead, the driver sends the statement directly to the data source. 
@item SQL_ATTR_PARAM_BIND_OFFSET_PTR @tab
      An SQLUINTEGER * value that points to an offset added to pointers to 
      change binding of dynamic parameters. Not supported by the driver 
@item  SQL_ATTR_PARAM_BIND_TYPE @tab
      An SQLUINTEGER value that indicates the binding orientation to be used for 
      dynamic parameters.@*
      This field is set to @code{SQL_PARAM_BIND_BY_COLUMN} (the default) to select 
      column-wise binding. 
      To select row-wise binding, this field is set to the length of the 
      structure or an instance of a buffer that will be bound to a set of 
      dynamic parameters. This length must include space for all of the bound 
      parameters and any padding of the structure or buffer to ensure that when 
      the address of a bound parameter is incremented with the specified length, 
      the result will point to the beginning of the same parameter in the next 
      set of parameters. 
@item SQL_ATTR_PARAM_OPERATION_PTR @tab
      An SQLUSMALLINT * value that points to an array of SQLUSMALLINT values 
      used to ignore a parameter during execution of an SQL statement. Each 
      value is set to either @code{SQL_PARAM_PROCEED} (for the parameter to be 
      executed) or @code{SQL_PARAM_IGNORE} (for the parameter to be ignored).@*
      A set of parameters can be ignored during processing by setting the status 
      value in the array pointed to by @code{SQL_DESC_ARRAY_STATUS_PTR} in the APD to 
      @code{SQL_PARAM_IGNORE}. A set of parameters is processed if its status value is 
      set to @code{SQL_PARAM_PROCEED} or if no elements in the array are set.@* 
      This statement attribute can be set to a null pointer, in which case the 
      driver does not return parameter status values. This attribute can be set 
      at any time, but the new value is not used until the next time 
      SQLExecDirect or SQLExecute is called. 
@item SQL_ATTR_PARAM_STATUS_PTR @tab
      An SQLUSMALLINT * value that points to an array of SQLUSMALLINT values 
      containing status information for each row of parameter values after a 
      call to SQLExecute or SQLExecDirect. This field is required only if 
      @code{PARAMSET_SIZE} is greater than 1.@* 
      The status values can contain the following values:@* 
      @code{SQL_PARAM_SUCCESS:} The SQL statement was successfully executed for this 
      set of parameters. @*
      @code{SQL_PARAM_SUCCESS_WITH_INFO:} The SQL statement was successfully executed 
      for this set of parameters; however, warning information is available in 
      the diagnostics data structure. @*
      @code{SQL_PARAM_ERROR:} There was an error in processing this set of parameters. 
      Additional error information is available in the diagnostics data 
      structure. @*
      @code{SQL_PARAM_UNUSED:} This parameter set was unused, possibly due to the fact 
      that some previous parameter set caused an error that aborted further 
      processing, or because @code{SQL_PARAM_IGNORE} was set for that set of parameters 
      in the array specified by the @code{SQL_ATTR_PARAM_OPERATION_PTR}. @*
      @code{SQL_PARAM_DIAG_UNAVAILABLE:} The driver treats arrays of parameters as a 
      monolithic unit and so does not generate this level of error information. 
      This statement attribute can be set to a null pointer, in which case the 
      driver does not return parameter status values. This attribute can be set 
      at any time, but the new value is not used until the next time SQLExecute 
      or SQLExecDirect is called. Note that setting this attribute can affect 
      the output parameter behavior implemented by the driver. @*
@item SQL_ATTR_PARAMS_PROCESSED_PTR @tab
      An SQLUINTEGER * record field that points to a buffer in which to return 
      the number of sets of parameters that have been processed, including error 
      sets. No number will be returned if this is a null pointer.
@item SQL_ATTR_PARAMSET_SIZE @tab An SQLUINTEGER value that specifies the number of 
      values for each parameter. 
@item SQL_ATTR_QUERY_TIMEOUT @tab
      An SQLUINTEGER value corresponding to the number of seconds to wait for an 
      SQL statement to execute before returning to the application. If ValuePtr 
      is equal to 0 (default), there is no timeout. @*
@item SQL_ATTR_RETRIEVE_DATA @tab
      An SQLUINTEGER value: @*
      @code{SQL_RD_ON:} SQLFetchScroll and, in ODBC 3.x, SQLFetch retrieve data after 
      it positions the cursor to the specified location. This is the default. 
      @code{SQL_RD_OFF:} SQLFetchScroll and, in ODBC 3.x, SQLFetch do not retrieve 
      data after it positions the cursor. @*
      Driver supports only the default value. 
@item SQL_ATTR_ROW_ARRAY_SIZE @tab
      An SQLUINTEGER value that specifies the number of rows returned by each 
      call to SQLFetch or SQLFetchScroll. It is also the number of rows in a 
      bookmark array used in a bulk bookmark operation in SQLBulkOperations. The 
      default value is 1. 
@item SQL_ATTR_ROW_BIND_OFFSET_PTR @tab 
      An SQLUINTEGER * value that points to an 
      offset added to pointers to change binding of column data 
@item SQL_ATTR_ROW_BIND_TYPE @tab
      An SQLUINTEGER value that sets the binding orientation to be used when 
      SQLFetch or SQLFetchScroll is called on the associated statement. @*
      Column-wise binding is selected by setting the value to 
      @code{SQL_BIND_BY_COLUMN}. Row-wise binding is selected by setting the value to 
      the length of a structure or an instance of a buffer into which result 
      columns will be bound. 
@item SQL_ATTR_ROW_NUMBER @tab
      An SQLUINTEGER value that is the number of the current row in the entire 
      result set. If the number of the current row cannot be determined or there 
      is no current row, the driver returns 0. @*
      This attribute can be retrieved by a call to SQLGetStmtAttr but not set by 
      a call to SQLSetStmtAttr. 
@item SQL_ATTR_ROW_OPERATION_PTR @tab
      An SQLUSMALLINT * value that points to an array of SQLUSMALLINT values 
      used to ignore a row during a bulk operation using SQLSetPos. Each value 
      is set to either @code{SQL_ROW_PROCEED} (for the row to be included in the bulk 
      operation) or @code{SQL_ROW_IGNORE} (for the row to be excluded from the bulk 
      operation). (Rows cannot be ignored by using this array during calls to 
      SQLBulkOperations.) @*
      This statement attribute can be set to a null pointer, in which case the 
      driver does not return row status values. This attribute can be set at any 
      time, but the new value is not used until the next time SQLSetPos is 
      called. 
@item SQL_ATTR_ROW_STATUS_PTR @tab
      An SQLUSMALLINT * value that points to an array of SQLUSMALLINT values 
      containing row status values after a call to SQLFetch or SQLFetchScroll. 
      The array has as many elements as there are rows in the rowset. @*
      This statement attribute can be set to a null pointer, in which case the 
      driver does not return row status values. This attribute can be set at any 
      time, but the new value is not used until the next time SQLBulkOperations, 
      SQLFetch, SQLFetchScroll, or SQLSetPos is called. 
@item SQL_ATTR_ROWS_FETCHED_PTR @tab
      An SQLUINTEGER * value that points to a buffer in which to return the 
      number of rows fetched after a call to SQLFetch or SQLFetchScroll; the 
      number of rows affected by a bulk operation performed by a call to 
      SQLSetPos with an Operation argument of @code{SQL_REFRESH}; or the number of rows 
      affected by a bulk operation performed by SQLBulkOperations. This number 
      includes error rows. 
@item SQL_ATTR_SIMULATE_CURSOR @tab
      An SQLUINTEGER value that specifies whether drivers that simulate 
      positioned update and delete statements guarantee that such statements 
      affect only one single row. @*
      @code{SQL_SC_NON_UNIQUE:} The driver does not guarantee that simulated 
      positioned update or delete statements will affect only one row; @*
      @code{SQL_SC_TRY_UNIQUE:} The driver attempts to guarantee that simulated 
      positioned update or delete statements affect only one row @*
      @code{SQL_SC_UNIQUE:} The driver guarantees that simulated positioned update or 
      delete statements affect only one row. 
@item SQL_ATTR_USE_BOOKMARKS @tab
      Bookmarks are not supported. 
@end multitable




@node SQLGetStmtAttr, SQLSetStmtOption, SQLSetStmtAttr, Setting and Retrieving Driver Attributes
@subsection SQLGetStmtAttr
@strong{SQLGetStmtAttr} returns the current setting of a statement attribute

@subsubheading Syntax
@example
  SQLRETURN SQLGetStmtAttr(
       SQLHSTMT       StatementHandle,
       SQLINTEGER     Attribute,
       SQLPOINTER     ValuePtr,
       SQLINTEGER     BufferLength,
       SQLINTEGER *   StringLengthPtr);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
Statement handle.

@code{Attribute [Input]}@*
Attribute to retrieve. Refer to @ref{SQLSetStmtAttr} for the list of attributes

@code{ValuePtr [Output]}@*
Pointer to a buffer in which to return the value of the attribute 
specified in Attribute

@code{BufferLength [Input]}@*
If Attribute is an ODBC-defined attribute and ValuePtr points to a 
character string or a binary buffer, this argument should be the length of 
*ValuePtr. If Attribute is an ODBC-defined attribute and *ValuePtr is an 
integer, BufferLength is ignored.@*
BufferLength can have the following values:
@itemize @bullet
@item If Attribute is an ODBC-defined attribute and *ValuePtr is an 
  integer, BufferLength is ignored. BufferLength can have the following values:
@item If *ValuePtr is a pointer to a character string, then BufferLength is 
  the length of the string or SQL_NTS.
@item If *ValuePtr is a pointer to a binary buffer, then the application 
  places the result of the SQL_LEN_BINARY_ATTR(length) macro in BufferLength. 
  This places a negative value in BufferLength.
@item If *ValuePtr is a pointer to a value other than a character string or 
  binary string, then BufferLength should have the value SQL_IS_POINTER.
@item If *ValuePtr is contains a fixed-length data type, then BufferLength is 
  either SQL_IS_INTEGER or SQL_IS_UINTEGER, as appropriate.
@end itemize

@code{StringLength [Output]}@*
A pointer to a buffer in which to return the total number of bytes 
(excluding the null-termination character) available to return in *ValuePtr. 
If ValuePtr is a null pointer, no length is returned. If the attribute value 
is a character string, and the number of bytes available to return is greater 
than or equal to BufferLength, the data in *ValuePtr is truncated to 
BufferLength minus the length of a null-termination character and is 
null-terminated by the driver.



@node SQLSetStmtOption, SQLGetStmtOption, SQLGetStmtAttr, Setting and Retrieving Driver Attributes
@subsection SQLSetStmtOption
In ODBC 3.x, @strong{SQLSetStmtAttr} has replaced @strong{SQLStmtOption}. For more 
information, see @ref{SQLSetStmtAttr}

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.


@node SQLGetStmtOption,  , SQLSetStmtOption, Setting and Retrieving Driver Attributes
@subsection SQLGetStmtOption
In ODBC 3.x, @strong{SQLGetStmtAttr} has replaced @strong{SQLCetStmtOption}. For more 
information, see @ref{SQLGetStmtAttr}

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.




@node Preparing SQL requests, Executing SQL statements, Setting and Retrieving Driver Attributes, MyODBC API Reference
@section Preparing SQL requests



@menu
* SQLAllocStmt::                
* SQLPrepare::                  
* SQLBindParameter::            
* SQLGetCursorName::            
* SQLSetCursorName::            
* SQLSetScrollOptions::         
@end menu

@node SQLAllocStmt, SQLPrepare, Preparing SQL requests, Preparing SQL requests
@subsection SQLAllocStmt
@strong{SQLAllocStmt} allocates memory for a statement handle.

@subsubheading Syntax
@example
SQLRETURN SQLAllocStmt (
     HDBC    ConnectionHandle,
     HSTMT*  StatementHandle);
@end example

@subsubheading Comments
In ODBC 3.x, SQLAllocHandle has replaced the ODBC 2.x function SQLAllocStmt.
For more information on how to allocate environment handle using SQLAllocHandle,
 @xref{SQLAllocHandle}, description.

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.


@node SQLPrepare, SQLBindParameter, SQLAllocStmt, Preparing SQL requests
@subsection SQLPrepare
@strong{SQLPrepare} prepares an SQL string for execution.

@subsubheading Syntax
@example
  SQLRETURN SQLPrepare(
       SQLHSTMT      StatementHandle,
       SQLCHAR *     StatementText,
       SQLINTEGER    TextLength);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{StatementText [Input]}@*
  SQL text string.

@code{TextLength [Input]}@*
  Length of *StatementText. 
    
@subsubheading Comments
For more information, refer to @ref{Prepared Execution}.



@node SQLBindParameter, SQLGetCursorName, SQLPrepare, Preparing SQL requests
@subsection SQLBindParameter
@strong{SQLBindParameter} binds a buffer to a parameter marker in an SQL statement. 
SQLBindParameter supports binding to a Unicode C data type, even if the 
underlying driver does not support Unicode data.

@subsubheading Syntax
@example
  SQLRETURN SQLBindParameter(
       SQLHSTMT        StatementHandle,
       SQLUSMALLINT    ParameterNumber,
       SQLSMALLINT     InputOutputType,
       SQLSMALLINT     ValueType,
       SQLSMALLINT     ParameterType,
       SQLUINTEGER     ColumnSize,
       SQLSMALLINT     DecimalDigits,
       SQLPOINTER      ParameterValuePtr,
       SQLINTEGER      BufferLength,
       SQLINTEGER *    StrLen_or_IndPtr);    
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ParameterNumber [Input]}@*
  Parameter number, ordered sequentially in increasing parameter order, starting 
  at 1.

@code{InputOutputType [Input]}@*
  The type of the parameter.

@code{ValueType [Input]}@*
  The C data type of the parameter.

@code{ParameterType [Input]}@*
  The SQL data type of the parameter

@code{ColumnSize [Input]}@*
  The size of the column or expression of the corresponding parameter marker

@code{DecimalDigits [Input]}@*
  The decimal digits of the column or expression of the corresponding parameter 
  marker.

@code{ParameterValuePtr [Deferred Input]}@*
  A pointer to a buffer for the parameter's data.

@code{BufferLength [Input/Output]}@*
  Length of the ParameterValuePtr buffer in bytes.

@code{StrLen_or_IndPtr [Deferred Input]}@*
  A pointer to a buffer for the parameter's length. 


@node SQLGetCursorName, SQLSetCursorName, SQLBindParameter, Preparing SQL requests
@subsection SQLGetCursorName
@strong{SQLGetCursorName} returns the cursor name associated with a specified 
statement.

@subsubheading Syntax
@example
  SQLRETURN SQLGetCursorName(
       SQLHSTMT        StatementHandle,
       SQLCHAR *       CursorName,
       SQLSMALLINT     BufferLength,
       SQLSMALLINT *   NameLengthPtr);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{CursorName [Output]}@*
  Pointer to a buffer in which to return the cursor name.

@code{BufferLength [Input]}@*
  Length of *CursorName, in bytes.

@code{NameLengthPtr [Output]}@*
  Pointer to memory in which to return the total number of bytes (excluding the 
  null-termination character) available to return in *CursorName. If the number 
  of bytes available to return is greater than or equal to BufferLength, the 
  cursor name in *CursorName is truncated to BufferLength minus the length of a 
  null-termination character.


@node SQLSetCursorName, SQLSetScrollOptions, SQLGetCursorName, Preparing SQL requests
@subsection SQLSetCursorName
@strong{SQLSetCursorName} associates a cursor name with an active statement. If an 
application does not call SQLSetCursorName, the driver generates cursor names 
as needed for SQL statement processing.
    
@subsubheading Syntax
@example
  SQLRETURN SQLSetCursorName(
       SQLHSTMT        StatementHandle,
       SQLCHAR *       CursorName,
       SQLSMALLINT     NameLength);
@end example

@subsubheading Arguments

@code{StatementHandle [Input]}@*
  Statement handle.

@code{CursorName [Input]}@*
  Cursor name. For efficient processing, the cursor name should not include any 
  leading or trailing spaces in the cursor name, and if the cursor name includes 
  a delimited identifier, the delimiter should be positioned as the first 
  character in the cursor name.

@code{NameLength [Input]}@*
  Length of *CursorName.

@subsubheading Comments
For more information about how to set and get the cursors, refer to 
@ref{Positioned update and delete,Positioned update and delete operation}. 


@node SQLSetScrollOptions,  , SQLSetCursorName, Preparing SQL requests
@subsection SQLSetScrollOptions

In ODBC 3.x, @strong{SQLSetSetScrollOptions} has been replaced by 
calls to @ref{SQLSetStmtAttr}, and @ref{SQLGetInfo}.


Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.




@node Executing SQL statements, Resultset, Preparing SQL requests, MyODBC API Reference
@section Executing SQL statements



@menu
* SQLExecute::                  
* SQLExecDirect::               
* SQLNativeSql::                
* SQLDescribeParam::            
* SQLNumParams::                
* SQLParamData::                
* SQLPutData::                  
@end menu

@node SQLExecute, SQLExecDirect, Executing SQL statements, Executing SQL statements
@subsection SQLExecute
@strong{SQLExecute} executes a prepared statement, using the current values of the 
parameter marker variables if any parameter markers exist in the statement. 
  
@subsubheading Syntax
@example
  SQLRETURN SQLExecute(
       SQLHSTMT     StatementHandle);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
Statement handle.

@subsubheading Comments
SQLExecute executes a statement prepared by SQLPrepare. For more information 
refer to @ref{Prepared Execution}.


@node SQLExecDirect, SQLNativeSql, SQLExecute, Executing SQL statements
@subsection SQLExecDirect
@strong{SQLExecDirect} executes a preparable statement, using the current values of the 
parameter marker variables if any parameters exist in the statement. 
SQLExecDirect is the fastest way to submit an SQL statement for one-time 
execution. 
  
@subsubheading Syntax
@example
  SQLRETURN SQLExecDirect(
       SQLHSTMT     StatementHandle,
       SQLCHAR *    StatementText,
       SQLINTEGER   TextLength);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{StatementText [Input]}@*
  SQL statement to be executed.

@code{TextLength [Input]}@*
  Length of *StatementText.

@subsubheading Comments
The application calls SQLExecDirect to send an SQL statement to the MySQL 
server. For more information about direct execution refer @ref{Direct Execution}.

@node SQLNativeSql, SQLDescribeParam, SQLExecDirect, Executing SQL statements
@subsection SQLNativeSql
@strong{SQLNativeSql} returns the SQL string as modified by the driver. SQLNativeSql 
does not execute the SQL statement. 
  
@subsubheading Syntax
@example
  SQLRETURN SQLNativeSql(
       SQLHDBC       ConnectionHandle,
       SQLCHAR *     InStatementText,
       SQLINTEGER    TextLength1,
       SQLCHAR *     OutStatementText,
       SQLINTEGER    BufferLength,
       SQLINTEGER *  TextLength2Ptr);
@end example

@subsubheading Arguments
@code{ConnectionHandle [Input]}@*
  Connection handle.

@code{InStatementText [Input]}@*
  SQL text string to be translated.

@code{TextLength1 [Input]}@*
  Length of *InStatementText text string.

@code{OutStatementText [Output]}@*
  Pointer to a buffer in which to return the translated SQL string.

@code{BufferLength [Input]}@*
  Length of the *OutStatementText buffer.

@code{TextLength2Ptr [Output]}@*
Pointer to a buffer in which to return the total number of bytes (excluding 
the null-termination byte) available to return in *OutStatementText. If the 
number of bytes available to return is greater than or equal to BufferLength, 
the translated SQL string in *OutStatementText is truncated to BufferLength 
minus the length of a null-termination character.


@node SQLDescribeParam, SQLNumParams, SQLNativeSql, Executing SQL statements
@subsection SQLDescribeParam
@strong{SQLDescribeParam} returns the description of a parameter marker associated with 
a prepared SQL statement.

@subsubheading Syntax
@example
  SQLRETURN SQLDescribeParam(
       SQLHSTMT          StatementHandle,
       SQLUSMALLINT      ParameterNumber,
       SQLSMALLINT *     DataTypePtr,
       SQLUINTEGER *     ParameterSizePtr,
       SQLSMALLINT *     DecimalDigitsPtr,
       SQLSMALLINT *     NullablePtr);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ParameterNumber [Input]}@*
  Parameter marker number ordered sequentially in increasing parameter order, 
  starting at 1.

@code{DataTypePtr [Output]}@*
  Pointer to a buffer in which to return the SQL data type of the parameter.
  In ODBC 3.x, SQL_TYPE_DATE, SQL_TYPE_TIME, or SQL_TYPE_TIMESTAMP will be 
  returned in *DataTypePtr for date, time, or timestamp data, respectively; in 
  ODBC 2.x, SQL_DATE, SQL_TIME, or SQL_TIMESTAMP will be returned

@code{ParameterSizePtr [Output]}@*
  Pointer to a buffer in which to return the size of the column or expression of 
  the corresponding parameter marker as defined by the server.

@code{DecimalDigitsPtr [Output]}@*
  Pointer to a buffer in which to return the number of decimal digits of the 
  column or expression of the corresponding parameter as defined by the server.

@code{NullablePtr [Output]}@*
  Pointer to a buffer in which to return a value that indicates whether the 
  parameter allows NULL values. This value is read from the SQL_DESC_NULLABLE 
  field of the IPD. One of the following:
@itemize @bullet
@item @code{SQL_NO_NULLS:} The parameter does not allow NULL values (this is the default 
    value). 
@item @code{SQL_NULLABLE:} The parameter allows NULL values. 
@item @code{SQL_NULLABLE_UNKNOWN:} The driver cannot determine if the parameter allows 
    NULL values. 
@end itemize


@node SQLNumParams, SQLParamData, SQLDescribeParam, Executing SQL statements
@subsection SQLNumParams
@strong{SQLNumParams} returns the number of parameters in an SQL statement. 

@subsubheading Syntax
@example
  SQLRETURN SQLNumParams(
       SQLHSTMT        StatementHandle,
       SQLSMALLINT *   ParameterCountPtr);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ParameterCountPtr [Output]}@*
  Pointer to a buffer in which to return the number of parameters in the 
  statement.


@node SQLParamData, SQLPutData, SQLNumParams, Executing SQL statements
@subsection SQLParamData
@strong{SQLParamData} is used in conjunction with @ref{SQLPutData} to 
supply parameter data at statement execution time. 
  
@subsubheading Syntax
@example
  SQLRETURN SQLParamData(
       SQLHSTMT       StatementHandle,
       SQLPOINTER *   ValuePtrPtr);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ValuePtrPtr [Output]}@*
  Pointer to a buffer in which to return the address of the ParameterValuePtr 
  buffer specified in SQLBindParameter (for parameter data) or the address of 
  the TargetValuePtr buffer specified in SQLBindCol (for column data), as 
  contained in the SQL_DESC_DATA_PTR descriptor record field.


@node SQLPutData,  , SQLParamData, Executing SQL statements
@subsection SQLPutData
@strong{SQLPutData} allows an application to send data for a parameter or column to the 
  driver at statement execution time. This function can be used to send 
  character or binary data values in parts to a column with a character, binary, 
  or data source–specific data type (for example, parameters of the 
  SQL_LONGVARBINARY or SQL_LONGVARCHAR types). SQLPutData supports binding to a 
  Unicode C data type, even if the underlying driver does not support Unicode 
  data. 
  
@subsubheading Syntax
@example
  SQLRETURN SQLPutData(
       SQLHSTMT     StatementHandle,
       SQLPOINTER   DataPtr,
       SQLINTEGER   StrLen_or_Ind);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{DataPtr [Input]}@*
  Pointer to a buffer containing the actual data for the parameter or column. 
  The data must be in the C data type specified in the ValueType argument of 
  SQLBindParameter (for parameter data) or the TargetType argument of SQLBindCol 
  (for column data).

@code{StrLen_or_Ind [Input]}@*
  Length of *DataPtr. Specifies the amount of data sent in a call to SQLPutData. 
  The amount of data can vary with each call for a given parameter or column. 
  StrLen_or_Ind is ignored unless it meets one of the following conditions:
@itemize @bullet
@item StrLen_or_Ind is SQL_NTS, SQL_NULL_DATA, or SQL_DEFAULT_PARAM.
@item The C data type specified in SQLBindParameter or SQLBindCol is 
  SQL_C_CHAR or SQL_C_BINARY.
@item The C data type is SQL_C_DEFAULT, and the default C data type for 
  the specified SQL data type is SQL_C_CHAR or SQL_C_BINARY.
  For all other types of C data, if StrLen_or_Ind is not SQL_NULL_DATA or 
  SQL_DEFAULT_PARAM, the driver assumes that the size of the *DataPtr buffer is 
  the size of the C data type specified with ValueType or TargetType and sends 
  the entire data value.
@end itemize



@node Resultset, Diagnostic Information, Executing SQL statements, MyODBC API Reference
@section Retrieving results and information about results



@menu
* SQLRowCount::                 
* SQLNumResultCols::            
* SQLDescribeCol::              
* SQLColAttribute::             
* SQLColAttributes::            
* SQLBindCol::                  
* SQLFetch::                    
* SQLFetchScroll::              
* SQLExtendedFetch::            
* SQLGetData::                  
* SQLSetPos::                   
* SQLBulkOperations::           
@end menu


@node SQLRowCount, SQLNumResultCols, Resultset, Resultset
@subsection SQLRowCount
@strong{SQLRowCount} returns the number of rows affected by an UPDATE, INSERT,
or DELETES statement; an SQL_ADD operation in @ref{SQLBulkOperations}; or an 
SQL_UPDATE or SQL_DELETE operation in @ref{SQLSetPos}. 

@subsubheading Syntax
@example
  SQLRETURN SQLRowCount(
       SQLHSTMT      StatementHandle,
       SQLINTEGER *  RowCountPtr);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ RowCountPtr [Output]}@*
  Points to a buffer in which to return a row count. For UPDATE, INSERT, and 
  DELETE statements, for the SQL_ADD operations in SQLBulkOperations, and for 
  the SQL_UPDATE or SQL_DELETE operations in SQLSetPos, the value returned in 
  *RowCountPtr is either the number of rows affected by the request or –1 if the 
  number of affected rows is not available.@*

  When SQLExecute, SQLExecDirect, SQLBulkOperations, SQLSetPos, or 
  SQLMoreResults is called, the SQL_DIAG_ROW_COUNT field of the diagnostic data 
  structure is set to the row count, and the row count is cached in an 
  implementation-dependent way. SQLRowCount returns the cached row count value. 
  The cached row count value is valid until the statement handle is set back to 
  the prepared or allocated state, the statement is reexecuted, or 
  SQLCloseCursor is called. Note that if a function has been called since the 
  SQL_DIAG_ROW_COUNT field was set, the value returned by SQLRowCount might be 
  different from the value in the SQL_DIAG_ROW_COUNT field because the 
  SQL_DIAG_ROW_COUNT field is reset to 0 by any function call.@*

  For other statements and functions, the driver may define the value returned 
  in *RowCountPtr. For example, some data sources may be able to return the 
  number of rows returned by a SELECT statement or a catalog function before 
  fetching the rows.@*

  @code{Note}  Many data sources cannot return the number of rows in a result set 
  before fetching them; for maximum interoperability, applications should not 
  rely on this behavior.


@node SQLNumResultCols, SQLDescribeCol, SQLRowCount, Resultset
@subsection SQLNumResultCols
@strong{SQLNumResultCols} returns the number of columns in a result set. 

@subsubheading Syntax
@example
@end example
  SQLRETURN SQLNumResultCols(
       SQLHSTMT        StatementHandle,
       SQLSMALLINT *   ColumnCountPtr);

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ColumnCountPtr [Output]}@*
  Pointer to a buffer in which to return the number of columns in the result 
  set. This count does not include a bound bookmark column.


@node SQLDescribeCol, SQLColAttribute, SQLNumResultCols, Resultset
@subsection SQLDescribeCol
@strong{SQLDescribeCol} returns the result descriptor-column name, 
type, column size, decimal digits, and nullability-for one column in 
the result set. This information also is available in the fields of the IRD. 

@subsubheading Syntax
@example
  SQLRETURN SQLDescribeCol(
       SQLHSTMT       StatementHandle,
       SQLSMALLINT    ColumnNumber,
       SQLCHAR *      ColumnName,
       SQLSMALLINT    BufferLength,
       SQLSMALLINT *  NameLengthPtr,
       SQLSMALLINT *  DataTypePtr,
       SQLUINTEGER *  ColumnSizePtr,
       SQLSMALLINT *  DecimalDigitsPtr,
       SQLSMALLINT *  NullablePtr);    
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ColumnNumber [Input]}@*
  Column number of result data, ordered sequentially in increasing column order, 
  starting at 1. The ColumnNumber argument can also be set to 0 to describe the 
  bookmark column.

@code{ColumnName [Output]}@*
  Pointer to a buffer in which to return the column name. This value is read 
  from the SQL_DESC_NAME field of the IRD. If the column is unnamed or the 
  column name cannot be determined, the driver returns an empty string.

@code{BufferLength [Input]}@*
  Length of the *ColumnName buffer, in characters.

@code{NameLengthPtr [Output]}@*
  Pointer to a buffer in which to return the total number of bytes (excluding 
  the null-termination byte) available to return in *ColumnName. If the number 
  of bytes available to return is greater than or equal to BufferLength, the 
  column name in *ColumnName is truncated to BufferLength minus the length of a 
  null-termination character.

@code{DataTypePtr [Output]}@*
  Pointer to a buffer in which to return the SQL data type of the column. This 
  value is read from the SQL_DESC_CONCISE_TYPE field of the IRD. If the data 
  type cannot be determined, the driver returns SQL_UNKNOWN_TYPE.
@itemize @bullet
  @item In ODBC 3.x, SQL_TYPE_DATE, SQL_TYPE_TIME, or SQL_TYPE_TIMESTAMP is returned 
  in *DataTypePtr for date, time, or timestamp data, respectively; @*

  @item in ODBC 2.x, SQL_DATE, SQL_TIME, or SQL_TIMESTAMP is returned. The Driver Manager performs 
  the required mappings when an ODBC 2.x application is working with an ODBC 3.x 
  driver or when an ODBC 3.x application is working with an ODBC 2.x driver.@*
  
  @item When ColumnNumber is equal to 0 (for a bookmark column), SQL_BINARY is 
  returned in *DataTypePtr for variable-length bookmarks. (SQL_INTEGER is 
  returned if bookmarks are used by an ODBC 3.x application working with an ODBC 
  2.x driver or by an ODBC 2.x application working with an ODBC 3.x driver.)@*
@end itemize
@code{ColumnSizePtr [Output]}@*
  Pointer to a buffer in which to return the size of the column on the data 
  source. If the column size cannot be determined, the driver returns 0.

@code{DecimalDigitsPtr [Output]}@*
  Pointer to a buffer in which to return the number of decimal digits of the 
  column on the data source. If the number of decimal digits cannot be 
  determined or is not applicable, the driver returns 0.

@code{NullablePtr [Output]}@*
  Pointer to a buffer in which to return a value that indicates whether the 
  column allows NULL values. This value is read from the SQL_DESC_NULLABLE field 
  of the IRD. The value is one of the following:
@itemize @bullet
  @item @code{SQL_NO_NULLS:} The column does not allow NULL values.
  @item @code{SQL_NULLABLE:} The column allows NULL values.
  @item @code{SQL_NULLABLE_UNKNOWN:} The driver cannot determine if the column allows NULL 
  values.
@end itemize


@node SQLColAttribute, SQLColAttributes, SQLDescribeCol, Resultset
@subsection SQLColAttribute
@strong{SQLColAttribute} returns descriptor information for a column in a result set. 
Descriptor information is returned as a character string, a 32-bit 
descriptor-dependent value, or an integer value. 

@subsubheading Syntax
@example
  SQLRETURN SQLColAttribute (
       SQLHSTMT        StatementHandle,
       SQLUSMALLINT    ColumnNumber,
       SQLUSMALLINT    FieldIdentifier,
       SQLPOINTER      CharacterAttributePtr,
       SQLSMALLINT     BufferLength,
       SQLSMALLINT *   StringLengthPtr,
       SQLPOINTER      NumericAttributePtr);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ColumnNumber [Input]}@*
  The number of the record in the IRD from which the field value is to be 
  retrieved. This argument corresponds to the column number of result data, 
  ordered sequentially in increasing column order, starting at 1. Columns can be 
  described in any order.@*
  Column 0 can be specified in this argument, but all values except 
  SQL_DESC_TYPE and SQL_DESC_OCTET_LENGTH will return undefined values.

@code{FieldIdentifier [Input]}@*
  The field in row ColumnNumber of the IRD that is to be returned (see 
  "Comments").

@code{CharacterAttributePtr [Output]}@*
  Pointer to a buffer in which to return the value in the FieldIdentifier field 
  of the ColumnNumber row of the IRD, if the field is a character string. 
  Otherwise, the field is unused.

@code{BufferLength [Input]}@*
  If FieldIdentifier is an ODBC-defined field and CharacterAttributePtr points 
  to a character string or binary buffer, this argument should be the length of 
  *CharacterAttributePtr. If FieldIdentifier is an ODBC-defined field and 
  *CharacterAttributePtr is an integer, this field is ignored. If the 
  *CharacterAttributePtr is a Unicode string (when calling SQLColAttributeW), 
  the BufferLength argument must be an even number. 

  If FieldIdentifier is a  driver-defined field, the application indicates the 
  nature of the field to the Driver Manager by setting the BufferLength argument. 
  BufferLength can have the following values:
@itemize @bullet
@item If CharacterAttributePtr is a pointer to a pointer, BufferLength should have 
    the value SQL_IS_POINTER. 
@item If CharacterAttributePtr is a pointer to a character string, the 
    BufferLength is the length of the buffer. 
@item If CharacterAttributePtr is a pointer to a binary buffer, the application 
    places the result of the SQL_LEN_BINARY_ATTR(length) macro in BufferLength. 
    This places a negative value in BufferLength. 
@item If CharacterAttributePtr is a pointer to a fixed-length data type, 
    BufferLength must be one of the following: SQL_IS_INTEGER, SQL_IS_UNINTEGER, 
    SQL_SMALLINT, or SQLUSMALLINT. 
@end itemize

@code{StringLengthPtr [Output]}@*
  Pointer to a buffer in which to return the total number of bytes (excluding 
  the null-termination byte for character data) available to return in 
  *CharacterAttributePtr.

  For character data, if the number of bytes available to return is greater than 
  or equal to BufferLength, the descriptor information in *CharacterAttributePtr 
  is truncated to BufferLength minus the length of a null-termination character 
  and is null-terminated by the driver.

  For all other types of data, the value of BufferLength is ignored and the 
  driver assumes the size of *CharacterAttributePtr is 32 bits.

@code{NumericAttributePtr [Output]}@*
  Pointer to an integer buffer in which to return the value in the 
  FieldIdentifier field of the ColumnNumber row of the IRD, if the field is a 
  numeric descriptor type, such as SQL_DESC_COLUMN_LENGTH. Otherwise, the field 
  is unused.


@node SQLColAttributes, SQLBindCol, SQLColAttribute, Resultset
@subsection SQLColAttributes
In ODBC 3.x, @strong{SQLColAttributes} has replaced @strong{SQLColAttribute}. For more 
information, see @ref{SQLColAttribute}

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.


@node SQLBindCol, SQLFetch, SQLColAttributes, Resultset
@subsection SQLBindCol
@strong{SQLBindCol} binds application data buffers to columns in the result set. 

@subsubheading Syntax
@example
  SQLRETURN SQLBindCol(
       SQLHSTMT        StatementHandle,
       SQLUSMALLINT    ColumnNumber,
       SQLSMALLINT     TargetType,
       SQLPOINTER      TargetValuePtr,
       SQLINTEGER      BufferLength,
       SQLLEN *        StrLen_or_Ind);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{ColumnNumber [Input]}@*
  Number of the result set column to bind. Columns are numbered in increasing 
  column order starting at 0, where column 0 is the bookmark column. If 
  bookmarks are not used—that is, the SQL_ATTR_USE_BOOKMARKS statement attribute 
  is set to SQL_UB_OFF—then column numbers start at 1.

@code{TargetType [Input]}@*
  The identifier of the C data type of the *TargetValuePtr buffer. When 
  retrieving data from the data source with SQLFetch, SQLFetchScroll, 
  SQLBulkOperations, or SQLSetPos, the driver converts the data to this type; 
  when sending data to the data source with SQLBulkOperations or SQLSetPos, the 
  driver converts the data from this type..

@code{TargetValuePtr [Deferred Input/Output]}@*
  Pointer to the data buffer to bind to the column. SQLFetch and SQLFetchScroll 
  return data in this buffer. SQLBulkOperations, it retrieves data from this 
  buffer when Operation is SQL_ADD. SQLSetPos returns data in this buffer when 
  Operation is SQL_REFRESH; it retrieves data from this buffer when Operation is 
  SQL_UPDATE.

  If TargetValuePtr is a null pointer, the driver unbinds the data buffer for 
  the column. An application can unbind all columns by calling SQLFreeStmt with 
  the SQL_UNBIND option. An application can unbind the data buffer for a column 
  but still have a length/indicator buffer bound for the column, if the 
  TargetValuePtr argument in the call to SQLBindCol is a null pointer but the 
  StrLen_or_IndPtr argument is a valid value. 

@code{BufferLength [Input]}@*
  Length of the *TargetValuePtr buffer in bytes.
  The driver uses BufferLength to avoid writing past the end of the 
  *TargetValuePtr buffer when returning variable-length data, such as character 
  or binary data. Note that the driver counts the null-termination character 
  when returning character data to *TargetValuePtr. *TargetValuePtr must 
  therefore contain space for the null-termination character or the driver will 
  truncate the data.

  When the driver returns fixed-length data, such as an integer or a date 
  structure, the driver ignores BufferLength and assumes the buffer is large 
  enough to hold the data. It is therefore important for the application to 
  allocate a large enough buffer for fixed-length data or the driver will write 
  past the end of the buffer.

  SQLBindCol returns SQLSTATE HY090 (Invalid string or buffer length) when 
  BufferLength is less than 0 but not when BufferLength is 0. However, if 
  TargetType specifies a character type, an application should not set 
  BufferLength to 0, because ISO CLI–compliant drivers return SQLSTATE HY090 
  (Invalid string or buffer length) in that case.

@code{StrLen_or_IndPtr [Deferred Input/Output]}@*
  Pointer to the length/indicator buffer to bind to the column. SQLFetch and 
  SQLFetchScroll return a value in this buffer. SQLBulkOperations retrieves a 
  value from this buffer when Operation is SQL_ADD. SQLSetPos returns a value in 
  this buffer when Operation is SQL_REFRESH; it retrieves a value from this 
  buffer when Operation is SQL_UPDATE. SQLFetch, SQLFetchScroll, 
  SQLBulkOperations, and SQLSetPos can return the following values in the 
  length/indicator buffer:
@itemize @bullet
  @item The length of the data available to return
  @item SQL_NO_TOTAL
  @item SQL_NULL_DATA
@end itemize
  The application can place the following values in the length/indicator buffer 
  for use with SQLBulkOperations or SQLSetPos:
@itemize @bullet
  @item The length of the data being sent
  @item SQL_NTS
  @item SQL_NULL_DATA
  @item SQL_DATA_AT_EXEC
  @item The result of the SQL_LEN_DATA_AT_EXEC macro
  @item  SQL_COLUMN_IGNORE (It is not supported by MyODBC, and is only by MyODBC 3.51)
@end itemize

  If the indicator buffer and the length buffer are separate buffers, the 
  indicator buffer can return only SQL_NULL_DATA, while the length buffer can 
  return all other values.
  If StrLen_or_IndPtr is a null pointer, no length or indicator value is used. 
  This is an error when fetching data and the data is NULL.



@node SQLFetch, SQLFetchScroll, SQLBindCol, Resultset
@subsection SQLFetch
@strong{SQLFetch} fetches the next rowset of data from the result set and returns data 
for all bound columns. 

@subsubheading Syntax
@example
  SQLRETURN SQLFetch(
       SQLHSTMT     StatementHandle);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@subsubheading Comments
SQLFetch returns the next rowset in the result set. It can be called only 
while a result set exists i.e. after a call that creates a result set and 
before the cursor over that result set is closed. If any columns are bound, it 
returns the data in those columns. If the application has specified a pointer 
to a row status array or a buffer in which to return the number of rows 
fetched, SQLFetch returns this information as well. Calls to SQLFetch can be 
mixed with calls to SQLFetchScroll but cannot be mixed with calls to 
SQLExtendedFetch.


@node SQLFetchScroll, SQLExtendedFetch, SQLFetch, Resultset
@subsection SQLFetchScroll
@strong{SQLFetchScroll} fetches the specified rowset of data from the result set and 
returns data for all bound columns. Rowsets can be specified at an absolute or 
relative position or by bookmark. @*
When working with an ODBC 2.x driver, the Driver Manager maps this function to 
SQLExtendedFetch.

@subsubheading Syntax
@example
  SQLRETURN SQLFetchScroll(
       SQLHSTMT      StatementHandle,
       SQLSMALLINT   FetchOrientation,
       SQLINTEGER    FetchOffset);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{FetchOrientation [Input]}@*
  Type of fetch:
@itemize @bullet
      @item SQL_FETCH_NEXT
      @item SQL_FETCH_PRIOR
      @item SQL_FETCH_FIRST
      @item SQL_FETCH_LAST
      @item SQL_FETCH_ABSOLUTE
      @item SQL_FETCH_RELATIVE
      @item SQL_FETCH_BOOKMARK
@end itemize
  
  For more information, see "Comments".@*

  
@code{FetchOffset [Input]}@*
  Number of the row to fetch. The interpretation of this argument depends on the 
  value of the FetchOrientation argument. For more information, see "Comments" 
  section.

@subsubheading Comments
SQLFetchScroll returns a specified rowset from the result set. Rowsets can be 
  specified by absolute or relative position or by bookmark. SQLFetchScroll can 
  be called only while a result set exists—that is, after a call that creates a 
  result set and before the cursor over that result set is closed. If any 
  columns are bound, it returns the data in those columns. If the application 
  has specified a pointer to a row status array or a buffer in which to return 
  the number of rows fetched, SQLFetchScroll returns this information as well. 
  Calls to SQLFetchScroll can be mixed with calls to SQLFetch but cannot be 
  mixed with calls to SQLExtendedFetch.@*
    
  When the result set is created, the cursor is positioned before the start of 
  the result set. SQLFetchScroll positions the block cursor based on the values 
  of the FetchOrientation and FetchOffset arguments as shown in the following 
  table.

@multitable @columnfractions .1 .9
@item @strong{FetchOritentation} @tab @strong{Meaning}
@item @code{SQL_FETCH_NEXT} @tab Return the next rowset. This is equivalent to calling 
      SQLFetch. SQLFetchScroll ignores the value of FetchOffset. 
@item @code{SQL_FETCH_PRIOR} @tab Return the prior rowset. SQLFetchScroll ignores the value 
      of FetchOffset. 
@item @code{SQL_FETCH_RELATIVE} @tab Return the rowset FetchOffset from the start of the 
      current rowset. 
@item @code{SQL_FETCH_ABSOLUTE} @tab Return the rowset starting at row FetchOffset. 
@item @code{SQL_FETCH_FIRST} @tab Return the first rowset in the result set. SQLFetchScroll 
      ignores the value of FetchOffset. 
@item @code{SQL_FETCH_LAST} @tab Return the last complete rowset in the result set. 
      SQLFetchScroll ignores the value of FetchOffset. 
@end multitable


@node SQLExtendedFetch, SQLGetData, SQLFetchScroll, Resultset
@subsection SQLExtendedFetch
@strong{SQLExtendedFetch} fetches the specified rowset of data from the result set and 
returns data for all bound columns. Rowsets can be specified at an absolute or 
by relative position.

@code{Note} In ODBC 3.x, SQLExtendedFetch has been replaced by SQLFetchScroll. ODBC 
3.x applications should not call SQLExtendedFetch; instead they should call 
SQLFetchScroll. Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, @xref{Mappping Deprecated Functions}.

@subsubheading Syntax
@example
  SQLRETURN SQLExtendedFetch(
       SQLHSTMT       StatementHandle,
       SQLUSMALLINT   FetchOrientation,
       SQLINTEGER     FetchOffset,
       SQLUINTEGER *  RowCountPtr,
       SQLUSMALLINT * RowStatusArray);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{FetchOrientation [Input]}@*
  Type of fetch. This is the same as FetchOrientation in SQLFetchScroll.

@code{FetchOffset [Input]}@*
  Number of the row to fetch. This is the same as FetchOffset in SQLFetchScroll, 
  with one exception.

@code{RowCountPtr [Output]}@*
  Pointer to a buffer in which to return the number of rows actually fetched. 
  This buffer is used in the same manner as the buffer specified by the 
  SQL_ATTR_ROWS_FETCHED_PTR statement attribute. This buffer is used only by 
  SQLExtendedFetch. It is not used by SQLFetch or SQLFetchScroll.

@code{RowStatusArray [Output]}@*
  Pointer to an array in which to return the status of each row. This array is 
  used in the same manner as the array specified by the SQL_ATTR_ROW_STATUS_PTR 
  statement attribute.

  However, the address of this array is not stored in the 
  SQL_DESC_STATUS_ARRAY_PTR field in the IRD. Furthermore, this array is used 
  only by SQLExtendedFetch and by SQLBulkOperations with an Operation of SQL_ADD 
  or SQLSetPos when it is called after SQLExtendedFetch. SQLFetch or 
  SQLFetchScroll does not use it, and SQLBulkOperations or SQLSetPos does not 
  use it when they are called after SQLFetch or SQLFetchScroll. It is also not 
  used when SQLBulkOperations with an Operation of SQL_ADD is called before any 
  fetch function is called. Applications should provide a valid pointer in the 
  RowStatusArray argument; if not, the behavior of SQLExtendedFetch and the 
  behavior of calls to SQLBulkOperations or SQLSetPos after SQLExtendedFetch has 
  positioned a cursor are undefined.

@subsubheading Comments
The behavior of SQLExtendedFetch is identical to that of SQLFetchScroll, with 
the following exceptions:
@itemize @bullet
@item    SQLExtendedFetch and SQLFetchScroll use different methods to return the 
    number of rows fetched. SQLExtendedFetch returns the number of rows fetched 
    in *RowCountPtr; SQLFetchScroll returns the number of rows fetched directly 
    to the buffer pointed to by SQL_ATTR_ROWS_FETCHED_PTR. For more information, 
    see the RowCountPtr argument. 
@item    SQLExtendedFetch and SQLFetchScroll return the status of each row in 
    different arrays. For more information, see the RowStatusArray argument. 
@item    SQLExtendedFetch does not support variable-length bookmarks or fetching 
    rowsets at an offset other than 0 from a bookmark. For more information, see 
    the FetchOffset argument. 
@item    SQLExtendedFetch and SQLFetchScroll use different rowset sizes. 
    SQLExtendedFetch uses the value of the SQL_ROWSET_SIZE statement attribute, 
    and SQLFetchScroll uses the value of the SQL_ATTR_ROW_ARRAY_SIZE statement 
    attribute. 
@item    SQLExtendedFetch has slightly different error handling semantics than 
    SQLFetchScroll. 
@item    SQLExtendedFetch does not support binding offsets (the 
    SQL_ATTR_ROW_BIND_OFFSET_PTR statement attribute). 
@item    Calls to SQLExtendedFetch cannot be mixed with calls to SQLFetch or 
    SQLFetchScroll, and if SQLBulkOperations is called before any fetch function 
    is called, SQLExtendedFetch cannot be called until the cursor is closed and 
    reopened 
@end itemize


@node SQLGetData, SQLSetPos, SQLExtendedFetch, Resultset
@subsection SQLGetData
@strong{SQLGetData} retrieves data for a single column in the result set. It can be 
called multiple times to retrieve variable-length data in parts. 

@subsubheading Syntax
@example
  SQLRETURN SQLGetData(
       SQLHSTMT        StatementHandle,
       SQLUSMALLINT    ColumnNumber,
       SQLSMALLINT     TargetType,
       SQLPOINTER      TargetValuePtr,
       SQLINTEGER      BufferLength,
       SQLINTEGER *    StrLen_or_IndPtr);
@end example

@subsubheading Arguments

@code{StatementHandle [Input]}@*
  Statement handle.

@code{ColumnNumber [Input]}@*
  Number of the column for which to return data. Result set columns are numbered 
  in increasing column order starting at 1. The bookmark column is column number 
  0; this can be specified only if bookmarks are enabled.  

@code{TargetType [Input]}@*
  The type identifier of the C data type of the *TargetValuePtr buffer. If it is 
  SQL_C_DEFAULT, the driver selects the default C data type based on the SQL 
  data type of the source.  

@code{TargetValuePtr [Input]}@*
  Pointer to the buffer in which to return the data.

@code{BufferLength [Input]}@*
  Length of the *TargetValuePtr buffer in bytes.
  The driver uses BufferLength to avoid writing past the end of the 
  *TargetValuePtr buffer when returning variable-length data, such as character 
  or binary data. Note that the driver counts the null-termination character 
  when returning character data to *TargetValuePtr. *TargetValuePtr must 
  therefore contain space for the null-termination character or the driver will 
  truncate the data.

  When the driver returns fixed-length data, such as an integer or a date 
  structure, the driver ignores BufferLength and assumes the buffer is large 
  enough to hold the data. It is therefore important for the application to 
  allocate a large enough buffer for fixed-length data or the driver will write 
  past the end of the buffer.

  SQLGetData returns SQLSTATE HY090 (Invalid string or buffer length) when 
  BufferLength is less than 0 but not when BufferLength is 0.If TargetValuePtr 
  is set to a null pointer, BufferLength is ignored by the driver.

@code{StrLen_or_IndPtr [Deferred Input/Output]}@*
  Pointer to the buffer in which to return the length or indicator value. If 
  this is a null pointer, no length or indicator value is returned. This returns 
  an error when the data being fetched is NULL.
  SQLGetData can return the following values in the length/indicator buffer:
@itemize @bullet
  @item The length of the data available to return
  @item SQL_NO_TOTAL
  @item SQL_NULL_DATA
@end itemize


@node SQLSetPos, SQLBulkOperations, SQLGetData, Resultset
@subsection SQLSetPos
@strong{SQLSetPos} sets the cursor position in a rowset and allows an application to 
refresh data in the rowset or to update or delete data in the result set. 

@subsubheading Syntax
@example
  SQLRETURN SQLSetPos(
       SQLHSTMT         StatementHandle,
       SQLUSMALLINT     RowNumber,
       SQLUSMALLINT     Operation,
       SQLUSMALLINT     LockType);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]]}@*
  Statement handle.

@code{RowNumber [Input]}@*
  Position of the row in the rowset on which to perform the operation specified 
  with the Operation argument. If RowNumber is 0, the operation applies to every 
  row in the rowset. For additional information, see "Comments."

@code{Operation [Input]}@*
  Operation to perform:
@itemize @bullet
            @item SQL_POSITION
            @item SQL_REFRESH
            @item SQL_UPDATE
            @item SQL_DELETE
@end itemize

@code{LockType [Input]}@*
  Specifies how to lock the row after performing the operation specified in the 
  Operation argument.
@itemize @bullet
            @item SQL_LOCK_NO_CHANGE
            @item SQL_LOCK_EXCLUSIVE
            @item SQL_LOCK_UNLOCK
@end itemize    

@subsubheading Comments
@strong{Row Number:}
  The RowNumber argument specifies the number of the row in the rowset on which 
  to perform the operation specified by the Operation argument. If RowNumber is 
  0, the operation applies to every row in the rowset. RowNumber must be a value 
  from 0 to the number of rows in the rowset.
    
  Note   In the C language, arrays are 0-based and the RowNumber argument is 
  1-based. For example, to update the fifth row of the rowset, an application 
  modifies the rowset buffers at array index 4 but specifies a RowNumber of 5.
  All operations position the cursor on the row specified by RowNumber. The 
  following operations require a cursor position:
@itemize @bullet
    @item Positioned update and delete statements. 
    @item Calls to SQLGetData. 
    @item Calls to SQLSetPos with the SQL_DELETE, SQL_REFRESH, and SQL_UPDATE options. 
@end itemize

  For example, if RowNumber is 2 for a call to SQLSetPos with an Operation of 
  SQL_DELETE, the cursor is positioned on the second row of the rowset and that 
  row is deleted. The entry in the implementation row status array (pointed to 
  by the SQL_ATTR_ROW_STATUS_PTR statement attribute) for the second row is 
  changed to SQL_ROW_DELETED.

  An application can specify a cursor position when it calls SQLSetPos. 
  Generally, it calls SQLSetPos with the SQL_POSITION or SQL_REFRESH operation 
  to position the cursor before executing a positioned update or delete 
  statement or calling SQLGetData.
    
@strong{Operation argument:}
  The Operation argument supports the following operations. To determine which 
  options are supported by a data source, an application calls SQLGetInfo with 
  the SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1 and SQL_STATIC_CURSOR_ATTRIBUTES1 
  information type.

@multitable @columnfractions .1 .9
@item @strong{Argument} @tab @strong{Operation}
@item SQL_POSITION @tab The driver positions the cursor on the row specified by Row 
      Number. The contents of the row status array pointed to by the 
      SQL_ATTR_ROW_OPERATION_PTR statement attribute are ignored for the 
      SQL_POSITION Operation. 
@item SQL_REFRESH @tab The driver positions the cursor on the row specified by Row 
      Number and refreshes data in the rowset buffers for that row.
      SQLSetPos with an Operation of SQL_REFRESH updates the status and content 
      of the rows within the current fetched rowset.  Because the data in the 
      buffers is refreshed but not re-fetched, the membership in the rowset is 
      fixed. This is different from the refresh performed by a call to 
      SQLFetchScroll with a FetchOrientation of SQL_FETCH_RELATIVE and a Row 
      Number equal to 0, which re-fetches the rowset from the result set so that 
      it can show added data and remove deleted data if those operations are 
      supported by the driver and the cursor. 
@item SQL_UPDATE @tab The driver positions the cursor on the row specified by Row 
      Number and updates the underlying row of data with the values in the 
      rowset buffers (the TargetValuePtr argument in SQLBindCol). 
@item SQL_DELETE @tab The driver positions the cursor on the row specified by Row 
      Number and deletes the underlying row of data. It changes the 
      corresponding element of the row status array to SQL_ROW_DELETED. After 
      the row has been deleted, the following are not valid for the row: 
      positioned update and delete statements, calls to SQLGetData, and calls to 
      SQLSetPos with Operation set to anything except SQL_POSITION. 
@end multitable


@node SQLBulkOperations,  , SQLSetPos, Resultset
@subsection SQLBulkOperations
@strong{SQLBulkOperations} performs bulk insertions and bulk bookmark operations, 
including update, delete, and fetch by bookmark. 

@subsubheading Syntax
@example
  SQLRETURN SQLBulkOperations(
       SQLHSTMT      StatementHandle,
       SQLUSMALLINT  Operation);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{Operation [Input]}@*
  Operation to perform:@*
  @code{SQL_ADD}.@* 
  
Note no bookmark operations supported yet by the driver.

@subsubheading Comments
@strong{Performing Bulk Inserts:}

To insert data with SQLBulkOperations, an application performs the following 
sequence of steps:

@itemize 
@enumerate

@item Executes a query that returns a result set. 
@item Sets the SQL_ATTR_ROW_ARRAY_SIZE statement attribute to the number of rows 
    that it wants to insert. 
@item Calls @code{SQLBindCol} to bind the data that it wants to insert. The data is bound 
    to an array with a size equal to the value of SQL_ATTR_ROW_ARRAY_SIZE. 

  Note   The size of the array pointed to by the SQL_ATTR_ROW_STATUS_PTR 
  statement attribute should either be equal to SQL_ATTR_ROW_ARRAY_SIZE or 
  SQL_ATTR_ROW_STATUS_PTR should be a null pointer.

@item Calls @code{SQLBulkOperations} (StatementHandle, @code{SQL_ADD}) to 
perform the insertion. 

@item If the application has set the SQL_ATTR_ROW_STATUS_PTR statement attribute, 
  it can inspect this array to see the result of the operation Getting Meta 
  Data Information
@end enumerate
@end itemize




@node Diagnostic Information, Meta Data Information, Resultset, MyODBC API Reference
@section Retrieving error or diagnostic information



@menu
* SQLError::                    
* SQLGetDiagField::             
* SQLGetDiagRec::               
@end menu

@node SQLError, SQLGetDiagField, Diagnostic Information, Diagnostic Information
@subsection SQLError
@strong{SQLError} returns error or status information. An application typically calls 
SQLError when a previous ODBC function returns SQL_ERROR or 
SQL_SUCCESS_WITH_INFO. In ODBC 3.x, SQLGetDiagRec has replaced the ODBC 2.0 
function SQLError. For more information, refer to @ref{SQLGetDiagRec}.@*

    
Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, refer to @xref{Mappping Deprecated Functions}.



@node SQLGetDiagField, SQLGetDiagRec, SQLError, Diagnostic Information
@subsection SQLGetDiagField
@strong{SQLGetDiagField} returns the current value of a field of a record of the 
diagnostic data structure (associated with a specified handle) that contains 
error, warning, and status information. 

@subsubheading Syntax
@example
  SQLRETURN SQLGetDiagField(
       SQLSMALLINT     HandleType,
       SQLHANDLE       Handle,
       SQLSMALLINT     RecNumber,
       SQLSMALLINT     DiagIdentifier,
       SQLPOINTER      DiagInfoPtr,
       SQLSMALLINT     BufferLength,
       SQLSMALLINT *   StringLengthPtr);
@end example

@subsubheading Arguments
@code{HandleType [Input]}@*
  A handle type identifier that describes the type of handle for which 
  diagnostics are required. Must be one of the following:@*
  SQL_HANDLE_ENV@*
  SQL_HANDLE_DBC@*
  SQL_HANDLE_STMT@*
  SQL_HANDLE_DESC (not supported )

@code{Handle [Input]}@*
  A handle for the diagnostic data structure, of the type indicated by 
  HandleType.

@code{RecNumber [Input]}@*
  Indicates the status record from which the application seeks information. 
  Status records are numbered from 1. If the DiagIdentifier argument indicates 
  any field of the diagnostics header, RecNumber is ignored. If not, it should 
  be greater than 0.

@code{DiagIdentifier [Input]}@*
  Indicates the field of the diagnostic whose value is to be returned. For more 
  information, see the "DiagIdentifier Argument" section in "Comments."

@code{DiagInfoPtr [Output]}@*
  Pointer to a buffer in which to return the diagnostic information. The data 
  type depends on the value of DiagIdentifier.

@code{BufferLength [Input]}@*
  If DiagIdentifier is an ODBC-defined diagnostic and DiagInfoPtr points to a 
  character string or a binary buffer, this argument should be the length of 
  *DiagInfoPtr. If DiagIdentifier is an ODBC-defined field and *DiagInfoPtr is 
  an integer, BufferLength is ignored.
 
  BufferLength can have the following values:
@itemize @bullet
    @item If *ValuePtr is a pointer to a character string, then BufferLength is the 
    length of the string or SQL_NTS. 
    @item If *ValuePtr is a pointer to a binary buffer, then the application places 
    the result of the SQL_LEN_BINARY_ATTR(length) macro in BufferLength. This 
    places a negative value in BufferLength. 
    @item If *ValuePtr is a pointer to a value other than a character string or binary 
    string, then BufferLength should have the value SQL_IS_POINTER. 
    @item If *ValuePtr is contains a fixed-length data type, then BufferLength is 
    SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT, or SQL_IS_USMALLINT, as 
    appropriate. 
@end itemize

@code{StringLengthPtr [Output]}@*
  Pointer to a buffer in which to return the total number of bytes (excluding 
  the number of bytes required for the null-termination character) available to 
  return in *DiagInfoPtr, for character data. If the number of bytes available 
  to return is greater than BufferLength, the text in *DiagInfoPtr is truncated 
  to BufferLength minus the length of a null-termination character.

@subsubheading Comments
@strong{SQLGetDiagField} does not post diagnostic records for itself. It uses the 
  following return values to report the outcome of its own execution:
@itemize @bullet

@item  SQL_SUCCESS: The function successfully returned diagnostic information. 
@item  SQL_SUCCESS_WITH_INFO: *DiagInfoPtr was too small to hold the requested 
    diagnostic field, so the data in the diagnostic field was truncated. To 
    determine that a truncation occurred, the application must compare 
    BufferLength to the actual number of bytes available, which is written to 
    *StringLengthPtr. 
@item SQL_INVALID_HANDLE: The handle indicated by HandleType and Handle was not a 
    valid handle. 
@item  SQL_ERROR: One of the following occurred: 
@itemize @bullet
      @item The DiagIdentifier argument was not one of the valid values. 
      @item The DiagIdentifier argument was SQL_DIAG_CURSOR_ROW_COUNT, 
      SQL_DIAG_DYNAMIC_FUNCTION, SQL_DIAG_DYNAMIC_FUNCTION_CODE, or 
      SQL_DIAG_ROW_COUNT, but Handle was not a statement handle. (The Driver 
      Manager returns this diagnostic.) 
      @item The RecNumber argument was negative or 0 when DiagIdentifier indicated a 
      field from a diagnostic record. RecNumber is ignored for header fields. 
      The value requested was a character string and BufferLength was less than 
      zero. 
@end itemize
@item  SQL_NO_DATA: RecNumber was greater than the number of diagnostic records 
    that existed for the handle specified in Handle. The function also returns 
    SQL_NO_DATA for any positive RecNumber if there are no diagnostic records 
    for Handle. 
@end itemize
  An application typically calls SQLGetDiagField to accomplish one of three 
  goals: 
@itemize @bullet
@enumerate
@item To obtain specific error or warning information when a function call has 
    returned SQL_ERROR or SQL_SUCCESS_WITH_INFO. 
@item  To find out the number of rows in the data source that were affected when 
    insert, delete, or update operations were performed with a call to 
    SQLExecute, SQLExecDirect, SQLBulkOperations, or SQLSetPos (from the 
    SQL_DIAG_ROW_COUNT header field), or to find out the number of rows that 
    exist in the current open cursor, if the driver is able to provide this 
    information (from the SQL_DIAG_CURSOR_ROW_COUNT header field). 
@end enumerate
@end itemize

@strong{DiagIdentifier:}@*
  The following are the list of diagnostic identifiers supported by the driver.
@multitable @columnfractions .2 .2 .6
@item @strong{DiagIdentifier} @tab @strong{ReturnType} @tab @strong{Returns}
    
@item SQL_DIAG_CURSOR_ROW_COUNT @tab SQLINTEGER @tab This field contains the count of rows in the cursor. 
      SQL_DIAG_NUMBER SQLINTEGER The number of status records that are available 
      for the specified handle. At present, driver returns 1. 
@item SQL_DIAG_RETURNCODE @tab SQLRETURN @tab Return code returned by the function.

@item SQL_DIAG_ROW_COUNT @tab SQLINTEGER @tab The number of rows affected by an insert, delete, or update 
      performed by SQLExecute, SQLExecDirect, SQLBulkOperations, or SQLSetPos. 

@item SQL_DIAG_CLASS_ORIGIN @tab SQLCHAR * @tab A string that indicates the document that 
      defines the class portion of the SQLSTATE value in this record. Its value 
      is "ISO 9075" for all SQLSTATEs defined by X/Open and ISO call-level 
      interface. For ODBC-specific SQLSTATEs (all those whose SQLSTATE class is 
      "IM"), its value is "ODBC 3.0". 

@item SQL_DIAG_COLUMN_NUMBER @tab SQLINTEGER @tab If the SQL_DIAG_ROW_NUMBER field is a 
      valid row number in a row set or a set of parameters, this field contains 
      the value that represents the column number in the result set or the 
      parameter number in the set of parameters. Result set column numbers 
      always start at 1; if this status record pertains to a bookmark column, 
      the field can be zero. Parameter numbers start at 1. It has the value 
      SQL_NO_COLUMN_NUMBER if the status record is not associated with a column 
      number or parameter number. If the driver cannot determine the column 
      number or parameter number that this record is associated with, this field 
      has the value SQL_COLUMN_NUMBER_UNKNOWN. @*
      The contents of this field are defined only for statement handles. 
      
@item SQL_DIAG_CONNECTION_ NAME @tab SQLCHAR * @tab A string that indicates the name of the connection that the 
      diagnostic record relates to. Driver returns DSN as the connection name 
      and for DSN-less connection, this field is a zero-length string. 

@item SQL_DIAG_MESSAGE_TEXT @tab SQLCHAR * @tab An informational message on the error or 
      warning. For list of error messages returned by the driver, see "Error 
      Codes” 

@item SQL_DIAG_NATIVE @tab SQLINTEGER @tab A driver/data source–specific native error 
      code. If there is no native error code, the driver returns 0. For list of 
      error codes returned by the driver, see "Error Codes” 

@item SQL_DIAG_ROW_NUMBER @tab SQLINTEGER @tab This field contains the row number in the 
      row set, or the parameter number in the set of parameters, with which the 
      status record is associated. Row numbers and parameter numbers start with 
      1. This field has the value SQL_NO_ROW_NUMBER if this status record is not 
      associated with a row number or parameter number. If the driver cannot 
      determine the row number or parameter number that this record is 
      associated with, this field has the value SQL_ROW_NUMBER_UNKNOWN. 
      The contents of this field are defined only for statement handles. 

@item SQL_DIAG_SERVER_NAME @tab SQLCHAR * @tab A string that indicates the server name 
      that the diagnostic record relates to. It is the same as the value 
      returned for a call to SQLGetInfo with the SQL_DATA_SOURCE_NAME option. 

@item SQL_DIAG_SQLSTATE @tab SQLCHAR * @tab A five-character SQLSTATE diagnostic code. For 
      list of SQLSTATEs returned by the driver, see "Error Codes” 

@item SQL_DIAG_SUBCLASS_ORIGIN @tab SQLCHAR * @tab A string with the same format and valid 
      values as SQL_DIAG_CLASS_ORIGIN, which identifies the defining portion of 
      the subclass portion of the SQLSTATE code. The ODBC-specific SQLSTATES for 
      which "ODBC 3.0" is returned.
@end multitable


@node SQLGetDiagRec,  , SQLGetDiagField, Diagnostic Information
@subsection SQLGetDiagRec
@strong{SQLGetDiagRec} returns the current values of multiple fields of a diagnostic 
  record that contains error, warning, and status information. Unlike 
  SQLGetDiagField, which returns one diagnostic field per call, SQLGetDiagRec 
  returns several commonly used fields of a diagnostic record, including the 
  SQLSTATE, the native error code, and the diagnostic message text. 

@subsubheading Syntax
@example
  SQLRETURN SQLGetDiagRec(
       SQLSMALLINT     HandleType,
       SQLHANDLE       Handle,
       SQLSMALLINT     RecNumber,
       SQLCHAR *       Sqlstate,
       SQLINTEGER *    NativeErrorPtr,
       SQLCHAR *       MessageText,
       SQLSMALLINT     BufferLength,
       SQLSMALLINT *   TextLengthPtr);   
@end example

@subsubheading Arguments
@code{HandleType [Input]}@*
  A handle type identifier that describes the type of handle for which 
  diagnostics are required. Must be one of the following:@*
  @code{SQL_HANDLE_ENV}@*
  @code{ SQL_HANDLE_DBC}@*
  @code{SQL_HANDLE_STMT}@*
  @code{SQL_HANDLE_DESC} (not supported)

@code{Handle [Input]}@*
  A handle for the diagnostic data structure, of the type indicated by 
  HandleType.

@code{RecNumber [Input]}@*
  Indicates the status record from which the application seeks information. 
  Status records are numbered from 1.

@code{SQLState [Output]}@*
  Pointer to a buffer in which to return a five-character SQLSTATE code 
  pertaining to the diagnostic record RecNumber..

@code{NativeErrorPtr [Output]}@*
  Pointer to a buffer in which to return the native error code, specific to the 
  data source. This information is contained in the SQL_DIAG_NATIVE diagnostic 
  field.

@code{MessageText [Output]}@*
  Pointer to a buffer in which to return the diagnostic message text string. 
  This information is contained in the SQL_DIAG_MESSAGE_TEXT diagnostic field.

@code{BufferLength [Input]}@*
  Length of the *MessageText buffer in characters. There is no maximum length of 
  the diagnostic message text.

@code{TextLengthPtr [Output]}@*
  Pointer to a buffer in which to return the total number of bytes (excluding 
  the number of bytes required for the null-termination character) available to 
  return in *MessageText. If the number of bytes available to return is greater 
  than BufferLength, the diagnostic message text in *MessageText is truncated to 
  BufferLength minus the length of a null-termination character.

@subsubheading Comments
An application typically calls SQLGetDiagRec when a previous call to an ODBC 
function has returned SQL_SUCCESS or SQL_SUCCESS_WITH_INFO. However, because 
any ODBC function can post zero or more diagnostic records each time it is 
called, an application can call SQLGetDiagRec after any ODBC function call.


@node Meta Data Information, Performing Transaction , Diagnostic Information, MyODBC API Reference
@section Getting Meta Data Information



@menu
* SQLColumnPrivileges::         
* SQLColumns::                  
* SQLForeignKeys::              
* SQLPrimaryKeys::              
* SQLSpecialColumns::           
* SQLStatistics::               
* SQLTablePrivileges::          
* SQLTables::                   
@end menu

@node SQLColumnPrivileges, SQLColumns, Meta Data Information, Meta Data Information
@subsection SQLColumnPrivileges
@strong{SQLColumnPrivileges} returns a list of columns and associated privileges for 
the specified table. The driver returns the information as a result set on the 
specified StatementHandle. 

@subsubheading Syntax
@example
  SQLRETURN SQLColumnPrivileges(
       SQLHSTMT      StatementHandle,
       SQLCHAR *     CatalogName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     SchemaName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     TableName,
       SQLSMALLINT   NameLength3,
       SQLCHAR *     ColumnName,
       SQLSMALLINT   NameLength4);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{CatalogName [Input]}@*
  Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength1 [Input]}@*
  Length of *CatalogName.

@code{SchemaName [Input]}@*
  Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength2 [Input]}@*
  Length of *SchemaName.

@code{TableName [Input]}@*
  Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength3 [Input]}@*
  Length of *TableName.

@code{ColumnName [Input]}@*
  String search pattern for column names.

@code{NameLength4 [Input]}@*
  Length of *ColumnName.



@node SQLColumns, SQLForeignKeys, SQLColumnPrivileges, Meta Data Information
@subsection SQLColumns
@strong{SQLColumns} returns the list of column names in specified tables. The driver 
returns this information as a result set on the specified StatementHandle. 
    
@subsubheading Syntax
@example
  SQLRETURN SQLColumns(
       SQLHSTMT      StatementHandle,
       SQLCHAR *     CatalogName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     SchemaName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     TableName,
       SQLSMALLINT   NameLength3,
       SQLCHAR *     ColumnName,
       SQLSMALLINT   NameLength4);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{CatalogName [Input]}@*
  Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength1 [Input]}@*
  Length of *CatalogName.

@code{SchemaName [Input]}@*
  Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength2 [Input]}@*
  Length of *SchemaName.

@code{TableName [Input]}@*
  Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength3 [Input]}@*
  Length of *TableName.

@code{ColumnName [Input]}@*
  String search pattern for column names.

@code{NameLength4 [Input]}@*
  Length of *ColumnName.


@node SQLForeignKeys, SQLPrimaryKeys, SQLColumns, Meta Data Information
@subsection SQLForeignKeys
@strong{SQLForeignKeys} can return:
@itemize @bullet
@item A list of foreign keys in the specified table (columns in the specified 
    table that refer to primary keys in other tables). 
@item A list of foreign keys in other tables that refer to the primary key in the 
    specified table. 
@end itemize
The driver returns each list as a result set on the specified statement.

@subsubheading Syntax
@example
  SQLRETURN SQLForeignKeys(
       SQLHSTMT      StatementHandle,
       SQLCHAR *     PKCatalogName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     PKSchemaName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     PKTableName,
       SQLSMALLINT   NameLength3,
       SQLCHAR *     FKCatalogName,
       SQLSMALLINT   NameLength4,
       SQLCHAR *     FKSchemaName,
       SQLSMALLINT   NameLength5,
       SQLCHAR *     FKTableName,
       SQLSMALLINT   NameLength6);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{PKCatalogName [Input]}@*
  Primary key table Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength1 [Input]}@*
  Length of *PKCatalogName, in bytes.

@code{PKSchemaName [Input]}@*
  Primary key table Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength2 [Input]}@*
  Length of *PKSchemaName, in bytes.

@code{PKTableName [Input]}@*
  Primary key Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength3 [Input]}@*
  Length of *PKTableName, in bytes.

@code{PKCatalogName [Input]}@*
  Foreign key table Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength4 [Input]}@*
  Length of *FKCatalogName, in bytes.

@code{PKSchemaName [Input]}@*
  Foriegn key table Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength5 [Input]}@*
  Length of *FKSchemaName, in bytes.

@code{FKTableName [Input]}@*
  Foreign key Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength6 [Input]}@*
  Length of *FKTableName, in bytes.


@node SQLPrimaryKeys, SQLSpecialColumns, SQLForeignKeys, Meta Data Information
@subsection SQLPrimaryKeys
@strong{SQLPrimaryKeys} returns the column names that make up the primary key for a 
  table. The driver returns the information as a result set. This function does 
  not support returning primary keys from multiple tables in a single call. 

@subsubheading Syntax
@example
  SQLRETURN SQLPrimaryKeys(
       SQLHSTMT      StatementHandle,
       SQLCHAR *     CatalogName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     SchemaName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     TableName,
       SQLSMALLINT   NameLength3);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{CatalogName [Input]}@*
  Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength1 [Input]}@*
  Length of *CatalogName.

@code{SchemaName [Input]}@*
  Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength2 [Input]}@*
  Length of *SchemaName.

@code{TableName [Input]}@*
  Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength3 [Input]}@*
  Length of *TableName.


@node SQLSpecialColumns, SQLStatistics, SQLPrimaryKeys, Meta Data Information
@subsection SQLSpecialColumns
@strong{SQLSpecialColumns} retrieves the following information about columns within a 
  specified table: 
@itemize @bullet
@item The optimal set of columns that uniquely identify a row in the table. 
@item Columns that are automatically updated when any value in the row is updated 
    by a transaction. 
@end itemize

@subsubheading Syntax
@example
  SQLRETURN SQLSpecialColumns(
       SQLHSTMT      StatementHandle,
       SQLSMALLINT   IdentifierType,
       SQLCHAR *     CatalogName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     SchemaName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     TableName,
       SQLSMALLINT   NameLength3,
       SQLSMALLINT   Scope,
       SQLSMALLINT   Nullable);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{IdentifierType [Input]}@*
  Type of column to return. Must be one of the following values:
@itemize @bullet
  @item @code{SQL_BEST_ROWID:} Returns the optimal column or set of columns that, by 
  retrieving values from the column or columns, allows any row in the specified 
  table to be uniquely identified. A column can be either a pseudo-column 
  specifically designed for this purpose or the column or columns of any unique 
  index for the table.
@item @code{SQL_ROWVER:} Returns the column or columns in the specified table, if any, that 
  are automatically updated by the data source when any value in the row is 
  updated by any transaction.
@end itemize

@code{CatalogName [Input]}@*
  Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength1 [Input]}@*
  Length of *CatalogName.

@code{SchemaName [Input]}@*
  Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength2 [Input]}@*
  Length of *SchemaName.

@code{TableName [Input]}@*
  Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength3 [Input]}@*
  Length of *TableName.

@code{Scope [Input]}@*
  Minimum required scope of the rowid. The returned rowid may be of greater 
  scope. Must be one of the following:
@itemize @bullet
@item  @code{SQL_SCOPE_CURROW:} The rowid is guaranteed to be valid only while positioned on 
  that row. A later reselect using rowid may not return a row if the row was 
  updated or deleted by another transaction.@*
@item  @code{SQL_SCOPE_TRANSACTION:} The rowid is guaranteed to be valid for the duration of 
  the current transaction.@*
@item  @code{SQL_SCOPE_SESSION:} The rowid is guaranteed to be valid for the duration of the 
  session (across transaction boundaries).
@end itemize

@code{Nullable [Input]}@*
  Determines whether to return special columns that can have a NULL value. Must 
  be one of the following:
@itemize @bullet
@item  @code{SQL_NO_NULLS:} Exclude special columns that can have NULL values. Some drivers 
  cannot support SQL_NO_NULLS, and these drivers will return an empty result set 
  if SQL_NO_NULLS was specified. Applications should be prepared for this case 
  and request SQL_NO_NULLS only if it is absolutely required.@*
@item  @code{SQL_NULLABLE:} Return special columns even if they can have NULL values.
@end itemize


@node SQLStatistics, SQLTablePrivileges, SQLSpecialColumns, Meta Data Information
@subsection SQLStatistics
@strong{SQLStatistics} retrieves a list of statistics about a single table and the 
indexes associated with the table. The driver returns the information as a 
result set.

@subsubheading Syntax
@example
  SQLRETURN SQLStatistics(
       SQLHSTMT      StatementHandle,
       SQLCHAR *     CatalogName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     SchemaName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     TableName,
       SQLSMALLINT   NameLength3,
       SQLUSMALLINT  Unique,
       SQLUSMALLINT  Reserved);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{CatalogName [Input]}@*
  Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength1 [Input]}@*
  Length of *CatalogName.

@code{SchemaName [Input]}@*
  Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength2 [Input]}@*
  Length of *SchemaName.

@code{TableName [Input]}@*
  Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength3 [Input]}@*
  Length of *TableName.

@code{Unique [Input]}@*
  Type of index: SQL_INDEX_UNIQUE or SQL_INDEX_ALL.

@code{Reserved [Input]}@*
  Indicates the importance of the CARDINALITY and PAGES columns in the result 
  set. The following options affect the return of the CARDINALITY and PAGES 
  columns only; index information is returned even if CARDINALITY and PAGES are 
  not returned.
@itemize @bullet
@item @code{SQL_ENSURE} requests that the driver unconditionally retrieve the statistics. 
  (Drivers that conform only to the X/Open standard and do not support ODBC 
  extensions will not be able to support SQL_ENSURE.)
@item @code{SQL_QUICK} requests that the driver retrieve the CARDINALITY and PAGES only if 
  they are readily available from the server. In this case, the driver does not 
  ensure that the values are current. (Applications that are written to the 
  X/Open standard will always get SQL_QUICK behavior from ODBC 3.x-compliant 
  drivers.)
@end itemize


@node SQLTablePrivileges, SQLTables, SQLStatistics, Meta Data Information
@subsection SQLTablePrivileges
@strong{SQLTablePrivileges} returns a list of tables and the privileges associated with 
each table. The driver returns the information as a result set on the 
specified statement. 

@subsubheading Syntax
@example
  SQLRETURN SQLTablePrivileges(
       SQLHSTMT      StatementHandle,
       SQLCHAR *     CatalogName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     SchemaName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     TableName,
       SQLSMALLINT   NameLength3);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{CatalogName [Input]}@*
  Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength1 [Input]}@*
  Length of *CatalogName.

@code{SchemaName [Input]}@*
  Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength2 [Input]}@*
  Length of *SchemaName.

@code{TableName [Input]}@*
  Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength3 [Input]}@*
  Length of *TableName.


@node SQLTables,  , SQLTablePrivileges, Meta Data Information
@subsection SQLTables
@strong{SQLTables} returns the list of table, catalog, or schema names, and table 
types, stored in a specific data source. The driver returns the information as 
a result set. 

@subsubheading Syntax
@example
  SQLRETURN SQLTables(
       SQLHSTMT      StatementHandle,
       SQLCHAR *     CatalogName,
       SQLSMALLINT   NameLength1,
       SQLCHAR *     SchemaName,
       SQLSMALLINT   NameLength2,
       SQLCHAR *     TableName,
       SQLSMALLINT   NameLength3,
       SQLCHAR *     TableType,
       SQLSMALLINT   NameLength4);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@code{CatalogName [Input]}@*
  Catalog name. If a driver supports names for some catalogs but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those catalogs that do not have names. CatalogName cannot contain 
  a string search pattern. 

@code{NameLength1 [Input]}@*
  Length of *CatalogName.

@code{SchemaName [Input]}@*
  Schema name. If a driver supports schemas for some tables but not for others, 
  such as when the driver retrieves data from different DBMSs, an empty string 
  ("") denotes those tables that do not have schemas. SchemaName cannot contain 
  a string search pattern.

@code{NameLength2 [Input]}@*
  Length of *SchemaName.

@code{TableName [Input]}@*
  Table name. This argument cannot be a null pointer. TableName cannot contain a 
  string search pattern.

@code{NameLength3 [Input]}@*
  Length of *TableName.

@code{Table Type [Input]}@*
  List of table types to match

@code{NameLength4 [Input]}@*
  Length of *TableType.



@node Performing Transaction , Termination, Meta Data Information, MyODBC API Reference
@section Performing Transaction 



@menu
* SQLTransact::                 
* SQLEndTran::                  
@end menu

@node SQLTransact, SQLEndTran, Performing Transaction , Performing Transaction
@subsection SQLTransact

@strong{SQLTransact} requests a commit or rollback operation for all active operations 
on all statements associated with a connection. SQLTransact can also request 
that a commit or rollback operation be performed for all connections 
associated with the environment.
    
In ODBC 3.x, SQLEndTran has replaced the ODBC 2.x function SQLTransact. For 
more information refer to @ref{SQLEndTran}.@*
    
Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, refer to @xref{Mappping Deprecated Functions}.


@node SQLEndTran,  , SQLTransact, Performing Transaction
@subsection SQLEndTran
@strong{SQLEndTran} requests a commit or rollback operation for all active operations 
on all statements associated with a connection. SQLEndTran can also request 
that a commit or rollback operation be performed for all connections 
associated with an environment. 

@subsubheading Syntax
@example
  SQLRETURN SQLEndTran(
       SQLSMALLINT   HandleType,
       SQLHANDLE     Handle,
       SQLSMALLINT   CompletionType);
@end example

@subsubheading Arguments
@code{HandleType [Input]}@*
  Handle type identifier. Contains either SQL_HANDLE_ENV (if Handle is an 
  environment handle) or SQL_HANDLE_DBC (if Handle is a connection handle).

@code{Handle [Input]}@*
  The handle, of the type indicated by HandleType, indicating the scope of the 
  transaction.

@code{CompletionType [Input]}@*
  One of the following two values:
@itemize @bullet
    @item @code{SQL_COMMIT}
    @item @code{SQL_ROLLBACK}
@end itemize



@node Termination,  , Performing Transaction , MyODBC API Reference
@section Terminating the Statement and Connection



@menu
* SQLFreeStmt::                 
* SQLCloseCursor::              
* SQLCancel::                   
* SQLDisconnect::               
* SQLFreeHandle::               
* SQLFreeConnect::              
* SQLFreeEnv::                  
@end menu

@node SQLFreeStmt, SQLCloseCursor, Termination, Termination
@subsection SQLFreeStmt
@strong{SQLFreeStmt} stops processing associated with a specific statement, closes any 
open cursors associated with the statement, discards pending results, or, 
optionally, frees all resources associated with the statement handle. 

@subsubheading Syntax
@example
  SQLRETURN SQLFreeStmt(
       SQLHSTMT         StatementHandle,
       SQLUSMALLINT     Option);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle

@code{Option [Input]}@*
  One of the following options:

@multitable @columnfractions .1 .9
@item @strong{Option} @tab @strong{Operation}
@item @code{SQL_CLOSE} @tab Closes the cursor associated with StatementHandle (if one was 
      defined) and discards all pending results. The application can reopen this 
      cursor later by executing a SELECT statement again with the same or 
      different parameter values. If no cursor is open, this option has no 
      effect for the application. SQLCloseCursor can also be called to close a 
      cursor 
@item  @code{SQL_DROP} @tab Releases the statement handle, by@*
      - Freeing all resources associated with it @*
      - Closing the cursor, and @*
      - Discards all pending operations @*
      The statement handle must be reallocated for the reuse. @*
        
      This option is deprecated in MyODBC 3.51. A call to SQLFreeStmt with an 
      Option of @code{SQL_DROP} is mapped to @ref{SQLFreeHandle}
@item @code{SQL_UNBIND} @tab Releases all column buffers bound by SQLBindCol for the given 
      statement handle. 
@item @code{SQL_RESET_PARAMS} @tab Release all parameter buffers set by SQLBindParameter for 
      the given statement handle
@end multitable




@node SQLCloseCursor, SQLCancel, SQLFreeStmt, Termination
@subsection SQLCloseCursor
@strong{SQLCloseCursor} closes a cursor that has been opened on a statement and 
discards pending results. 

@subsubheading Syntax
@example
  SQLRETURN SQLCloseCursor(
       SQLHSTMT     StatementHandle);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.


@node SQLCancel, SQLDisconnect, SQLCloseCursor, Termination
@subsection SQLCancel
@strong{SQLCancel} cancels the processing on a statement. 

@subsubheading Syntax
@example
  SQLRETURN SQLCancel(
       SQLHSTMT     StatementHandle);
@end example

@subsubheading Arguments
@code{StatementHandle [Input]}@*
  Statement handle.

@subsubheading Comments
SQLCancel can cancel the following types of processing on a statement:
@itemize @bullet
@item A function on a statement that needs data. 
@item A function running on the statement on another thread. 
@item A function running asynchronously on the statement, and the driver does not 
    support any asynchronous execution. 
@end itemize
  In ODBC 2.x, if an application calls SQLCancel when no processing is being 
  done on the statement, SQLCancel has the same effect as SQLFreeStmt with the 
  SQL_CLOSE option; this behavior is defined only for completeness and 
  applications should call SQLFreeStmt or SQLCloseCursor to close cursors


@node SQLDisconnect, SQLFreeHandle, SQLCancel, Termination
@subsection SQLDisconnect
@strong{SQLDisconnect} closes the connection associated with a specific connection 
handle. 

@subsubheading Syntax
@example
  SQLRETURN SQLDisconnect(
       SQLHDBC     ConnectionHandle);
@end example

@subsubheading Arguments
@code{ConnectionHandle [Input]}@*
  Connection handle.

@subsubheading Comments
  If an application calls SQLDisconnect while there is an incomplete transaction 
  associated with the connection handle, the driver returns SQLSTATE 25000 
  (Invalid transaction state), indicating that the transaction is unchanged and 
  the connection is open. An incomplete transaction is one that has not been 
  committed or rolled back with SQLEndTran.

    
  If an application calls SQLDisconnect before it has freed all statements 
  associated with the connection, the driver, after it successfully disconnects 
  from the server, frees those statements and all descriptors that have been 
  explicitly allocated on the connection.


@node SQLFreeHandle, SQLFreeConnect, SQLDisconnect, Termination
@subsection SQLFreeHandle
@strong{SQLFreeHandle} frees resources associated with a specific environment, 
  connection, statement, or descriptor handle.
    

  @code{Note}   This function is a generic function for freeing handles. It replaces 
  the ODBC 2.0 functions SQLFreeConnect (for freeing a connection handle) and 
  SQLFreeEnv (for freeing an environment handle). SQLFreeConnect and SQLFreeEnv 
  are both deprecated in ODBC 3.x. SQLFreeHandle also replaces the ODBC 2.0 
  function SQLFreeStmt (with the SQL_DROP Option) for freeing a statement 
  handle. 

@subsubheading Syntax
@example
  SQLRETURN SQLFreeHandle(
       SQLSMALLINT   HandleType,
       SQLHANDLE     Handle);
@end example

@subsubheading Arguments
@code{HandleType [Input]}@*
  The type of handle to be freed by SQLFreeHandle. Must be one of the following 
  values:
@itemize @bullet
  @item @code{SQL_HANDLE_ENV}
  @item @code{SQL_HANDLE_DBC}
  @item @code{SQL_HANDLE_STMT}
  @item @code{SQL_HANDLE_DESC} (not supported)
@end itemize
  If HandleType is not one of these values, SQLFreeHandle returns 
  SQL_INVALID_HANDLE.@*
  
@code{Handle [Input]}@*
  The handle to be freed.

@subsubheading Comments
@strong{Freeing an Environment Handle:}@*
  Prior to calling SQLFreeHandle with a HandleType of SQL_HANDLE_ENV, an 
  application must call SQLFreeHandle with a HandleType of SQL_HANDLE_DBC for 
  all connections allocated under the environment. Otherwise, the call to 
  SQLFreeHandle returns SQL_ERROR and the environment and any active connection 
  remains valid.@*

@strong{Freeing a Connection Handle:}@*
  Prior to calling SQLFreeHandle with a HandleType of SQL_HANDLE_DBC, an 
  application must call SQLDisconnect for the connection if there is a 
  connection on this handle. Otherwise, the call to SQLFreeHandle returns 
  SQL_ERROR and the connection remain valid.@*

@strong{Freeing a Statement Handle:}@*
  A call to SQLFreeHandle with a HandleType of SQL_HANDLE_STMT frees all 
  resources that were allocated by a call to SQLAllocHandle with a HandleType of 
  SQL_HANDLE_STMT. When an application calls SQLFreeHandle to free a statement 
  that has pending results, the pending results are deleted. Note that 
  SQLDisconnect automatically drops any statements and descriptors open on the 
  connection.


@node SQLFreeConnect, SQLFreeEnv, SQLFreeHandle, Termination
@subsection SQLFreeConnect
@strong{SQLFreeConnect} releases a connection handle and frees all memory associated 
with the handle. In ODBC 3.x, SQLFreeHandle has replaced the ODBC 2.0 function 
SQLFreeConnect. For more information, see @ref{SQLFreeHandle}

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, refer to @xref{Mappping Deprecated Functions}.


@node SQLFreeEnv,  , SQLFreeConnect, Termination
@subsection SQLFreeEnv
@strong{SQLFreeEnv} frees the environment handle and releases all memory associated 
with the environment handle. In ODBC 3.x, SQLFreeHandle has replaced the ODBC 
2.0 function SQLFreeEnv. For more information, see @ref{SQLFreeHandle}

Also, for more information on how to map deprecated functions in MyODBC 3.51 
driver, refer to @xref{Mappping Deprecated Functions}.


@c
@c APPENDIX - B
@c


@node MyODBC Data Types, MyODBC Error Codes, MyODBC API Reference, Top
@appendix MyODBC Data Types

The following table illustrates how driver maps the server data types to default 
SQL and C data types:

@multitable @columnfractions .2 .2 .9
@item @strong{Native Value} @tab @strong{SQL Type} @tab @strong{C Type}

@item  bit @tab SQL_BIT @tab SQL_C_BIT
@item  tinyint @tab SQL_TINYINT @tab SQL_C_STINYINT
@item  tinyint unsigned @tab SQL_TINYINT @tab SQL_C_UTINYINT
@item  bigint  @tab SQL_BIGINT @tab SQL_C_SBIGINT
@item  bigint unsigned @tab SQL_BIGINT @tab SQL_C_UBIGINT
@item  long varbinary @tab SQL_LONGVARBINARY @tab SQL_C_BINARY
@item  blob @tab SQL_VARBINARY @tab SQL_C_BINARY
@item  longblob @tab SQL_VARBINARY @tab SQL_C_BINARY
@item  tinyblob @tab SQL_BINARY @tab SQL_C_BINARY
@item  mediumblob @tab SQL_LONGVARBINARY @tab SQL_C_BINARY
@item  long varchar @tab SQL_LONGVARCHAR @tab SQL_C_CHAR
@item  text @tab SQL_LONGVARCHAR @tab SQL_C_CHAR
@item  mediumtext @tab SQL_LONGVARCHAR @tab SQL_C_CHAR
@item  char @tab SQL_CHAR @tab SQL_C_CHAR
@item  numeric @tab SQL_NUMERIC @tab SQL_C_CHAR
@item  decimal @tab SQL_DECIMAL @tab SQL_C_CHAR
@item  integer @tab SQL_INTEGER @tab SQL_C_SLONG
@item  integer unsigned @tab SQL_INTEGER @tab SQL_C_ULONG
@item  int @tab SQL_INTEGER @tab SQL_C_SLONG
@item  int unsigned @tab SQL_INTEGER @tab SQL_C_ULONG
@item  mediumint @tab SQL_INTEGER @tab SQL_C_SLONG
@item  mediumint unsigned @tab SQL_INTEGER @tab SQL_C_ULONG
@item  smallint @tab SQL_SMALLINT @tab SQL_C_SSHORT
@item  smallint unsigned @tab SQL_SMALLINT @tab SQL_C_USHORT
@item  real @tab SQL_FLOAT @tab SQL_C_DOUBLE
@item  double @tab SQL_FLOAT @tab SQL_C_DOUBLE
@item  float @tab SQL_REAL @tab SQL_C_FLOAT
@item  double prec @tab SQL_DOUBLE @tab SQL_C_DOUBLE
@item  date @tab SQL_DATE @tab SQL_C_DATE
@item  time @tab SQL_TIME @tab SQL_C_TIME
@item  year @tab SQL_SMALLINT @tab SQL_C_SHORT
@item  datetime @tab SQL_TIMESTAMP @tab SQL_C_TIMESTAMP
@item  timestamp @tab SQL_TIMESTAMP @tab SQL_C_TIMESTAMP
@item  text @tab SQL_VARCHAR @tab SQL_C_CHAR
@item  varchar @tab SQL_VARCHAR @tab SQL_C_CHAR
@item  enum @tab SQL_VARCHAR @tab SQL_C_CHAR
@item  set @tab SQL_VARCHAR @tab SQL_C_CHAR
@item  bit @tab SQL_CHAR @tab SQL_C_CHAR
@item  bool @tab SQL_CHAR @tab SQL_C_CHAR
@end multitable


@c
@c APPENDIX - C
@c

@node MyODBC Error Codes, MyODBC With VB, MyODBC Data Types, Top
@appendix MyODBC Error Codes

The following tables lists the error codes returned by the driver apart 
from the server errors.

@multitable @columnfractions .1 .1 .1 .2
@item @strong{NATIVE CODE} @tab @strong{SQLSTATE 2} @tab @strong{SQLSTATE 3} @tab @strong{ERROR MESSAGE}
@item 500 @tab 01000 @tab 01000 @tab General warning
@item 501 @tab 01004 @tab 01004 @tab String data, right truncated
@item 502 @tab 01S02 @tab 01S02 @tab Option value changed
@item 503 @tab 01S03 @tab 01S03 @tab No rows updated/deleted
@item 504 @tab 01S04 @tab 01S04 @tab More than one row updated/deleted
@item 505 @tab 01S06 @tab 01S06 @tab Attempt to fetch before the result set returned the first row set
@item 506 @tab 07001 @tab 07002 @tab SQLBindParameter not used for all parameters
@item 507 @tab 07005 @tab 07005 @tab Prepared statement not a cursor-specification
@item 508 @tab 07009 @tab 07009 @tab Invalid descriptor index
@item 509 @tab 08002 @tab 08002 @tab Connection name in use
@item 510 @tab 08003 @tab 08003 @tab Connection does not exist
@item 511 @tab 24000 @tab 24000 @tab Invalid cursor state
@item 512 @tab 25000 @tab 25000 @tab Invalid transaction state
@item 513 @tab 25S01 @tab 25S01 @tab Transaction state unknown
@item 514 @tab 34000 @tab 34000 @tab Invalid cursor name
@item 515 @tab S1000 @tab HY000 @tab General driver defined error
@item 516 @tab S1001 @tab HY001 @tab Memory allocation error
@item 517 @tab S1002 @tab HY002 @tab Invalid column number
@item 518 @tab S1003 @tab HY003 @tab Invalid application buffer type
@item 519 @tab S1004 @tab HY004 @tab Invalid SQL data type
@item 520 @tab S1009 @tab HY009 @tab Invalid use of null pointer
@item 521 @tab S1010 @tab HY010 @tab Function sequence error
@item 522 @tab S1011 @tab HY011 @tab Attribute can not be set now
@item 523 @tab S1012 @tab HY012 @tab Invalid transaction operation code
@item 524 @tab S1013 @tab HY013 @tab Memory management error
@item 525 @tab S1015 @tab HY015 @tab No cursor name available
@item 526 @tab S1024 @tab HY024 @tab Invalid attribute value
@item 527 @tab S1090 @tab HY090 @tab Invalid string or buffer length
@item 528 @tab S1091 @tab HY091 @tab Invalid descriptor field identifier
@item 529 @tab S1092 @tab HY092 @tab Invalid attribute/option identifier
@item 530 @tab S1093 @tab HY093 @tab Invalid parameter number
@item 531 @tab S1095 @tab HY095 @tab Function type out of range
@item 532 @tab S1106 @tab HY106 @tab Fetch type out of range
@item 533 @tab S1117 @tab HY117 @tab Row value out of range
@item 534 @tab S1109 @tab HY109 @tab Invalid cursor position
@item 535 @tab S1C00 @tab HYC00 @tab Optional feature not implemented
@item 0 @tab 21S01 @tab 21S01 @tab Column count does not match value count
@item 0 @tab 23000 @tab 23000 @tab Integrity constraint violation
@item 0 @tab 42000 @tab 42000 @tab Syntax error or access violation
@item 0 @tab 42S02 @tab 42S02 @tab Base table or view not found
@item 0 @tab 42S12 @tab 42S12 @tab Index not found
@item 0 @tab 42S21 @tab 42S21 @tab Column already exists
@item 0 @tab 42S22 @tab 42S22 @tab Column not found
@item 0 @tab 08S01 @tab 08S01 @tab Communication link failure
@end multitable



@c
@c APPENIX - D
@c


@node MyODBC With VB, MyODBC With .NET, MyODBC Error Codes, Top
@appendix MyODBC With VB - ADO, DAO and RDO


This chapter contains simple samples on the usage of MySQL ODBC 3.51 Driver with ADO, DAO and RDO.

@menu
* ADO - rs.addNew::             
* DAO - rs.addNew::             
* RDO - rs.addNew and rs.update ::  
@end menu

@node ADO - rs.addNew, DAO - rs.addNew, MyODBC With VB, MyODBC With VB
@appendixsec ADO - rs.addNew, rs.delete and rs.update 


The following @strong{ADO}@code{(ActiveX Data Objects)} sample creates a table 
my_ado and demonstrates the usage of rs.addNew, rs.delete and rs.update.

@example
Private Sub myodbc_ado_Click()
   
  Dim conn As ADODB.Connection
  Dim rs As ADODB.Recordset
  Dim fld As ADODB.Field
  Dim sql As String

  'connect to MySQL server using MySQL ODBC 3.51 Driver
  Set conn = New ADODB.Connection
  conn.ConnectionString = "DRIVER=@{MySQL ODBC 3.51 Driver@};"_
                        & "SERVER=localhost;"_ 
                        & " DATABASE=test;"_
                        & "UID=venu;PWD=venu; OPTION=35"

  conn.Open

  'create table
  conn.Execute "DROP TABLE IF EXISTS my_ado"
  conn.Execute "CREATE TABLE my_ado(id int not null primary key, name varchar(20)," _
                                 & "txt text, dt date, tm time, ts timestamp)"

  'direct insert
  conn.Execute "INSERT INTO my_ado(id,name,txt) values(1,100,'venu')"
  conn.Execute "INSERT INTO my_ado(id,name,txt) values(2,200,'MySQL')"
  conn.Execute "INSERT INTO my_ado(id,name,txt) values(3,300,'Delete')"

  Set rs = New ADODB.Recordset
  rs.CursorLocation = adUseServer

  'fetch the initial table ..
  rs.Open "SELECT * FROM my_ado", conn
    Debug.Print rs.RecordCount
    rs.MoveFirst
    Debug.Print String(50, "-") & "Initial my_ado Result Set " & String(50, "-")
    For Each fld In rs.Fields
      Debug.Print fld.Name,
      Next
      Debug.Print

      Do Until rs.EOF
      For Each fld In rs.Fields
      Debug.Print fld.Value,
      Next
      rs.MoveNext
      Debug.Print
    Loop
  rs.Close

  'rs insert
  rs.Open "select * from my_ado", conn, adOpenDynamic, adLockOptimistic
  rs.AddNew
  rs!Name = "Monty"
  rs!txt = "Insert row"
  rs.Update
  rs.Close

  'rs update
  rs.Open "SELECT * FROM my_ado"
  rs!Name = "update"
  rs!txt = "updated-row"
  rs.Update
  rs.Close

  'rs update second time..
  rs.Open "SELECT * FROM my_ado"
  rs!Name = "update"
  rs!txt = "updated-second-time"
  rs.Update
  rs.Close

  'rs delete
  rs.Open "SELECT * FROM my_ado"
  rs.MoveNext
  rs.MoveNext
  rs.Delete
  rs.Close

  'fetch the updated table ..
  rs.Open "SELECT * FROM my_ado", conn
    Debug.Print rs.RecordCount
    rs.MoveFirst
    Debug.Print String(50, "-") & "Updated my_ado Result Set " & String(50, "-")
    For Each fld In rs.Fields
      Debug.Print fld.Name,
      Next
      Debug.Print

      Do Until rs.EOF
      For Each fld In rs.Fields
      Debug.Print fld.Value,
      Next
      rs.MoveNext
      Debug.Print
    Loop
  rs.Close
  conn.Close
End Sub
@end example


@node DAO - rs.addNew, RDO - rs.addNew and rs.update , ADO - rs.addNew, MyODBC With VB
@appendixsec DAO - rs.addNew, rs.update and scrolling 


The following @strong{DAO} @code{(Data Access Objects)} sample creates a 
table my_dao and demonstrates the usage of rs.addNew, rs.update, and 
result set scrolling.

@example
Private Sub myodbc_dao_Click()

  Dim ws As Workspace
  Dim conn As Connection
  Dim queryDef As queryDef
  Dim str As String

  'connect to MySQL using MySQL ODBC 3.51 Driver
  Set ws = DBEngine.CreateWorkspace("", "venu", "venu", dbUseODBC)
  str = "odbc;DRIVER=@{MySQL ODBC 3.51 Driver@};"_
                        & "SERVER=localhost;"_ 
                        & " DATABASE=test;"_
                        & "UID=venu;PWD=venu; OPTION=35"
  Set conn = ws.OpenConnection("test", dbDriverNoPrompt, False, str)

  'Create table my_dao
  Set queryDef = conn.CreateQueryDef("", "drop table if exists my_dao")
  queryDef.Execute

  Set queryDef = conn.CreateQueryDef("", "create table my_dao(Id INT AUTO_INCREMENT PRIMARY KEY, " _
                                                           & "Ts TIMESTAMP(14) NOT NULL, Name varchar(20), Id2 INT)")
  queryDef.Execute

  'Insert new records using rs.addNew
  Set rs = conn.OpenRecordset("my_dao")
  Dim i As Integer

    For i = 10 To 15
    rs.AddNew
    rs!Name = "insert record" & i
    rs!Id2 = i
    rs.Update
    Next i
             rs.Close

  'rs update..
  Set rs = conn.OpenRecordset("my_dao")
  rs.Edit
  rs!Name = "updated-string"
  rs.Update
  rs.Close

  'fetch the table back...
  Set rs = conn.OpenRecordset("my_dao", dbOpenDynamic)
  str = "Results:"
  rs.MoveFirst
  While Not rs.EOF
  str = " " & rs!Id & " , " & rs!Name & ", " & rs!Ts & ", " & rs!Id2
  Debug.Print "DATA:" & str
  rs.MoveNext
  Wend

  'rs Scrolling
  rs.MoveFirst
  str = " FIRST ROW: " & rs!Id & " , " & rs!Name & ", " & rs!Ts & ", " & rs!Id2
  Debug.Print str

  rs.MoveLast
  str = " LAST ROW: " & rs!Id & " , " & rs!Name & ", " & rs!Ts & ", " & rs!Id2
  Debug.Print str

  rs.MovePrevious
  str = " LAST-1 ROW: " & rs!Id & " , " & rs!Name & ", " & rs!Ts & ", " & rs!Id2
  Debug.Print str

  'free all resources
  rs.Close
  queryDef.Close
  conn.Close
  ws.Close
   
End Sub
@end example


@node RDO - rs.addNew and rs.update ,  , DAO - rs.addNew, MyODBC With VB
@appendixsec RDO - rs.addNew and rs.update 


The following @strong{RDO} @code{(Remote Data Objects)} sample creates a table 
my_rdo and demonstrates the usage of rs.addNew and rs.update.

@example
Dim rs As rdoResultset
    Dim cn As New rdoConnection
    Dim cl As rdoColumn
    Dim SQL As String

    'cn.Connect = "DSN=test;"
    cn.Connect = "DRIVER=@{MySQL ODBC 3.51 Driver@};"_
                        & "SERVER=localhost;"_ 
                        & " DATABASE=test;"_
                        & "UID=venu;PWD=venu; OPTION=35"

    cn.CursorDriver = rdUseOdbc
    cn.EstablishConnection rdDriverPrompt


    'drop table my_rdo
    SQL = "drop table if exists my_rdo"
    cn.Execute SQL, rdExecDirect

    'create table my_rdo
    SQL = "create table my_rdo(id int, name varchar(20))"
    cn.Execute SQL, rdExecDirect

    'insert - direct
    SQL = "insert into my_rdo values (100,'venu')"
    cn.Execute SQL, rdExecDirect

    SQL = "insert into my_rdo values (200,'MySQL')"
    cn.Execute SQL, rdExecDirect

    'rs insert
    SQL = "select * from my_rdo"
    Set rs = cn.OpenResultset(SQL, rdOpenStatic, rdConcurRowVer, rdExecDirect)
    rs.AddNew
    rs!id = 300
    rs!Name = "Insert1"
    rs.Update
    rs.Close

    'rs insert
    SQL = "select * from my_rdo"
    Set rs = cn.OpenResultset(SQL, rdOpenStatic, rdConcurRowVer, rdExecDirect)
    rs.AddNew
    rs!id = 400
    rs!Name = "Insert 2"
    rs.Update
    rs.Close

    'rs update
    SQL = "select * from my_rdo"
    Set rs = cn.OpenResultset(SQL, rdOpenStatic, rdConcurRowVer, rdExecDirect)
    rs.Edit
    rs!id = 999
    rs!Name = "updated"
    rs.Update
    rs.Close 

    'fetch back...
    SQL = "select * from my_rdo"
    Set rs = cn.OpenResultset(SQL, rdOpenStatic, rdConcurRowVer, rdExecDirect)
    Do Until rs.EOF
    For Each cl In rs.rdoColumns
                Debug.Print cl.Value,
      Next
      rs.MoveNext
      Debug.Print
               Loop
    Debug.Print "Row count="; rs.RowCount

    'close
    rs.Close
    cn.Close
   
End Sub
@end example


@c 
@c APPENDIX - D
@c 

@node MyODBC With .NET, Credits, MyODBC With VB, Top
@appendix MyODBC with Microsoft .NET

This chapter contains simple samples to demonstrate the usage 
of MyODBC drivers with ODBC.NET

@menu
* ODBC.NET(C#)::                
* ODBC.NET(VB)::                
@end menu

@node ODBC.NET(C#), ODBC.NET(VB), MyODBC With .NET, MyODBC With .NET
@appendixsec ODBC.NET - CSHARP(C#)


The following sample creates a table my_odbc_net and 
demonstrates the usage in C#.

@example

 /**
 * @@sample    : mycon.cs
 * @@purpose   : Demo sample for ODBC.NET using MyODBC or MyODBC 3.51
 * @@author    : Venu, @email{venu@@mysql.com}
 *
 * (C) Copyright MySQL AB, 1995-2002
 *
 **/

 /* build command
  * 
  *  csc /t:exe 
  *      /out:mycon.exe mycon.cs 
  *      /r:Microsoft.Data.Odbc.dll 
  */ 

 using Console = System.Console;
 using Microsoft.Data.Odbc;

 namespace myodbc3
 @{
  class mycon
  @{
    static void Main(string[] args)
    @{
      try
      @{ 
        //Connection string for MyODBC 2.50
        /*string MyConString = "DRIVER=@{MySQL@};" + 
                             "SERVER=localhost;" +
                             "DATABASE=test;" +
                             "UID=venu;" +
                             "PASSWORD=venu;" +
                             "OPTION=3";
        */
        //Connection string for MyODBC 3.51
        string MyConString = "DRIVER=@{MySQL ODBC 3.51 Driver@};" + 
                             "SERVER=localhost;" +
                             "DATABASE=test;" +
                             "UID=venu;" +
                             "PASSWORD=venu;" +
                             "OPTION=3";
                    
        //Connect to MySQL using MyODBC
        OdbcConnection MyConnection = new OdbcConnection(MyConString);    
        MyConnection.Open();
  
        Console.WriteLine("\n !!! success, connected successfully !!!\n");    

        //Display connection information
        Console.WriteLine("Connection Information:");   
        Console.WriteLine("\tConnection String:" + MyConnection.ConnectionString);    
        Console.WriteLine("\tConnection Timeout:" + MyConnection.ConnectionTimeout);    
        Console.WriteLine("\tDatabase:" + MyConnection.Database);   
        Console.WriteLine("\tDataSource:" + MyConnection.DataSource);
        Console.WriteLine("\tDriver:" + MyConnection.Driver);
        Console.WriteLine("\tServerVersion:" + MyConnection.ServerVersion);

        //Create a sample table
        OdbcCommand MyCommand = new OdbcCommand("DROP TABLE IF EXISTS my_odbc_net",MyConnection);
        MyCommand.ExecuteNonQuery();
        MyCommand.CommandText = "CREATE TABLE my_odbc_net(id int, name varchar(20), idb bigint)";
        MyCommand.ExecuteNonQuery();

        //Insert
        MyCommand.CommandText = "INSERT INTO my_odbc_net VALUES(10,'venu', 300)";        
        Console.WriteLine("INSERT, Total rows affected:" + MyCommand.ExecuteNonQuery());;

        //Insert
        MyCommand.CommandText = "INSERT INTO my_odbc_net VALUES(20,'mysql',400)";        
        Console.WriteLine("INSERT, Total rows affected:" + MyCommand.ExecuteNonQuery());

        //Insert
        MyCommand.CommandText = "INSERT INTO my_odbc_net VALUES(20,'mysql',500)";        
        Console.WriteLine("INSERT, Total rows affected:" + MyCommand.ExecuteNonQuery());

        //Update
        MyCommand.CommandText = "UPDATE my_odbc_net SET id=999 WHERE id=20";        
        Console.WriteLine("Update, Total rows affected:" + MyCommand.ExecuteNonQuery());

        //COUNT(*)        
        MyCommand.CommandText = "SELECT COUNT(*) as TRows FROM my_odbc_net";        
        Console.WriteLine("Total Rows:" + MyCommand.ExecuteScalar());

        //Fetch
        MyCommand.CommandText = "SELECT * FROM my_odbc_net";                
        OdbcDataReader MyDataReader;
        MyDataReader =  MyCommand.ExecuteReader();
        while (MyDataReader.Read())
        @{
         if(string.Compare(MyConnection.Driver,"myodbc3.dll") == 0) @{
           Console.WriteLine("Data:" + MyDataReader.GetInt32(0) + " " +
                                       MyDataReader.GetString(1) + " " +
                                       MyDataReader.GetInt64(2)); //Supported only by MyODBC 3.51
         @}
         else @{            
           Console.WriteLine("Data:" + MyDataReader.GetInt32(0) + " " +
                                       MyDataReader.GetString(1) + " " +                                         
                                       MyDataReader.GetInt32(2)); //BIGINTs not supported by MyODBC
         @}
        @}

        //Close all resources
        MyDataReader.Close();
        MyConnection.Close();
      @}
      catch (OdbcException MyOdbcException)//Catch any ODBC exception ..
      @{
        for (int i=0; i < MyOdbcException.Errors.Count; i++)
        @{
          Console.Write("ERROR #" + i + "\n" +
            "Message: " + MyOdbcException.Errors[i].Message + "\n" +
            "Native: " + MyOdbcException.Errors[i].NativeError.ToString() + "\n" +
            "Source: " + MyOdbcException.Errors[i].Source + "\n" +
            "SQL: " + MyOdbcException.Errors[i].SQLState + "\n");
        @}
      @}
    @}
  @}
 @}
@end example

@node ODBC.NET(VB),  , ODBC.NET(C#), MyODBC With .NET
@appendixsec ODBC.NET - VB


The following sample creates a table my_vb_net and 
demonstrates the usage in VB.

@example
' @@sample    : myvb.vb
' @@purpose   : Demo sample for ODBC.NET using MyODBC or MyODBC 3.51
' @@author    : Venu, @email{venu@@mysql.com}
'
' (C) Copyright MySQL AB, 1995-2002
'
'

' 
' build command
'
' vbc /target:exe 
'     /out:myvb.exe 
'     /r:Microsoft.Data.Odbc.dll 
'     /r:System.dll 
'     /r:System.Data.dll 
'
 
Imports Microsoft.Data.Odbc
Imports System

Module myvb
    Sub Main()
        Try

            'MyODBC 3.51 connection string
            Dim MyConString As String = "DRIVER=@{MySQL ODBC 3.51 Driver@};" & _
                           "SERVER=localhost;" & _
                           "DATABASE=test;" & _
                           "UID=venu;" & _
                           "PASSWORD=venu;" & _
                           "OPTION=3;"

            'Connection
            Dim MyConnection As New OdbcConnection(MyConString)
            MyConnection.Open()

            Console.WriteLine ("Connection State::" & MyConnection.State.ToString)
            
            'Drop
            Console.WriteLine ("Dropping table")
            Dim MyCommand As New OdbcCommand()
            MyCommand.Connection = MyConnection
            MyCommand.CommandText = "DROP TABLE IF EXISTS my_vb_net"
            MyCommand.ExecuteNonQuery()
            
            'Create
            Console.WriteLine ("Creating....")
            MyCommand.CommandText = "CREATE TABLE my_vb_net(id int, name varchar(30))"
            MyCommand.ExecuteNonQuery()
            
            'Insert
            MyCommand.CommandText = "INSERT INTO my_vb_net VALUES(10,'venu')"    
            Console.WriteLine("INSERT, Total rows affected:" & MyCommand.ExecuteNonQuery())

            'Insert
            MyCommand.CommandText = "INSERT INTO my_vb_net VALUES(20,'mysql')"
            Console.WriteLine("INSERT, Total rows affected:" & MyCommand.ExecuteNonQuery())

            'Insert
            MyCommand.CommandText = "INSERT INTO my_vb_net VALUES(20,'mysql')"
            Console.WriteLine("INSERT, Total rows affected:" & MyCommand.ExecuteNonQuery())

            'Insert
            MyCommand.CommandText = "INSERT INTO my_vb_net(id) VALUES(30)"
            Console.WriteLine("INSERT, Total rows affected:" & MyCommand.ExecuteNonQuery())

            'Update
            MyCommand.CommandText = "UPDATE my_vb_net SET id=999 WHERE id=20"
            Console.WriteLine("Update, Total rows affected:" & MyCommand.ExecuteNonQuery())

            'COUNT(*)        
            MyCommand.CommandText = "SELECT COUNT(*) as TRows FROM my_vb_net"
            Console.WriteLine("Total Rows:" & MyCommand.ExecuteScalar())

            'Select              
            Console.WriteLine ("Select * FROM my_vb_net")
            MyCommand.CommandText = "SELECT * FROM my_vb_net"
            Dim MyDataReader As OdbcDataReader
            MyDataReader = MyCommand.ExecuteReader
            While MyDataReader.Read
                If MyDataReader("name") Is DBNull.Value Then
                    Console.WriteLine ("id = " & CStr(MyDataReader("id")) & "  name = " & _
                      "NULL")
                Else
                    Console.WriteLine ("id = " & CStr(MyDataReader("id")) & "  name = " & _
                                          CStr(MyDataReader("name")))
                End If
            End While
        
        'Catch ODBC Exception
        Catch MyOdbcException As OdbcException 
            Dim i As Integer
            Console.WriteLine (MyOdbcException.ToString)

        'Catch program exception
        Catch MyException As Exception
            Console.WriteLine (MyException.ToString)
    End Try
    End Sub
End Module
@end example

@node Credits, GPL license, MyODBC With .NET, Top
@appendix Credits

These are the developers that are working full time on MyODBC 
and MyODBC 3.51 Drivers from MySQL AB.

@itemize @bullet
@item
Micheal (Monty) Widenius, @email{monty@@mysql.com}
@item
Venu Anuganti, @email{venu@@mysql.com}
@*
@end itemize
List of contributors:



@node GPL license,  , Credits, Top
@appendix GNU GENERAL PUBLIC LICENSE

@cindex GPL, General Public License
@cindex GPL, GNU General Public License

@center Version 2, June 1991

@display
Copyright @copyright{} 1989, 1991 Free Software Foundation, Inc.
59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
@end display

@appendixsec Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software---to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

@iftex
@appendixsec TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
@end iftex
@ifinfo
@center GNU GENERAL PUBLIC LICENSE
@center TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
@end ifinfo

@enumerate 0
@item
This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The ``Program'', below,
refers to any such program or work, and a ``work based on the Program''
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term ``modification''.)  Each licensee is addressed as ``you''.

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

@item
You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

@item
You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

@enumerate a
@item
You must cause the modified files to carry prominent notices
stating that you changed the files and the date of any change.

@item
You must cause any work that you distribute or publish, that in
whole or in part contains or is derived from the Program or any
part thereof, to be licensed as a whole at no charge to all third
parties under the terms of this License.

@item
If the modified program normally reads commands interactively
when run, you must cause it, when started running for such
interactive use in the most ordinary way, to print or display an
announcement including an appropriate copyright notice and a
notice that there is no warranty (or else, saying that you provide
a warranty) and that users may redistribute the program under
these conditions, and telling the user how to view a copy of this
License.  (Exception: if the Program itself is interactive but
does not normally print such an announcement, your work based on
the Program is not required to print an announcement.)
@end enumerate

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

@item
You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

@enumerate a
@item
Accompany it with the complete corresponding machine-readable
source code, which must be distributed under the terms of Sections
1 and 2 above on a medium customarily used for software interchange; or,

@item
Accompany it with a written offer, valid for at least three
years, to give any third party, for a charge no more than your
cost of physically performing source distribution, a complete
machine-readable copy of the corresponding source code, to be
distributed under the terms of Sections 1 and 2 above on a medium
customarily used for software interchange; or,

@item
Accompany it with the information you received as to the offer
to distribute corresponding source code.  (This alternative is
allowed only for noncommercial distribution and only if you
received the program in object code or executable form with such
an offer, in accord with Subsection b above.)
@end enumerate

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

@item
You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

@item
You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

@item
Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

@item
If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

@item
If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

@item
The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and ``any
later version'', you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

@item
If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

@iftex
@heading NO WARRANTY
@end iftex
@ifinfo
@center NO WARRANTY
@end ifinfo

@item
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM ``AS IS'' WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

@item
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
@end enumerate

@iftex
@heading END OF TERMS AND CONDITIONS
@end iftex
@ifinfo
@center END OF TERMS AND CONDITIONS
@end ifinfo

@page
@appendixsec How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the ``copyright'' line and a pointer to where the full notice is found.

@smallexample
@var{one line to give the program's name and a brief idea of what it does.}
Copyright (C) @var{yyyy}  @var{name of author}

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
@end smallexample

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

@smallexample
Gnomovision version 69, Copyright (C) 19@var{yy} @var{name of author}
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
This is free software, and you are welcome to redistribute it
under certain conditions; type `show c' for details.
@end smallexample

The hypothetical commands @samp{show w} and @samp{show c} should show
the appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than @samp{show w} and
@samp{show c}; they could even be mouse-clicks or menu items---whatever
suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a ``copyright disclaimer'' for the program, if
necessary.  Here is a sample; alter the names:

@example
Yoyodyne, Inc., hereby disclaims all copyright interest in the program
`Gnomovision' (which makes passes at compilers) written by James Hacker.

@var{signature of Ty Coon}, 1 April 1989
Ty Coon, President of Vice
@end example

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.



@c @node Function Index,  , GPL license, Top
@c @unnumbered Command, type and function index

@c @printindex fn

@page


@c @node Concept Index,  , Function Index, Top
@c @unnumbered Concept Index

@c @printindex cp





@bye


