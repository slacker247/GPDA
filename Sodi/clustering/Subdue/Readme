

Subdue: README



The Subdue Knowledge Discovery System finds commonly occurring subgraphs in
an input graph using the Minimum Description Length principle and an inexact
graph match algorithm.  For more information, see:

	http://cygnus.uta.edu/subdue/index.html


Platforms

Subdue was developed and tested on RedHat Linux/Alpha 4.2 and RedHat 
Linux/x86 5.1 and 6.0 using the gcc compilers supplied with those systems. 
Starting with version 4.2.c.7, development has moved to Windows NT
platform using MS Visual C++, and therefore Subdue is WIN32 compatible.
The code conforms to ANSI C standards. Subdue supports timing by defining 
TIMING.

The parallel version has been tested on RedHat Linux/x86 5.1 systems using 
PVM version 3.3.11, and Windows NT 4.0 SP5 using PVM version 3.4.1, which 
can be obtained at:

	http://www.epm.ornl.gov/pvm/pvm_home.html

The classification lattice generated by the cluster option can be viewed with
AT&T Bell Lab's "dotty". Dotty and neato are distributed under the name
graphviz, and can be obtained (free of charge) at:

	http://www.research.att.com/sw/tools/graphviz/


Compilation

To build the single-processor (serial) version of Subdue, change the current
directory to subdue-[version number] and type "make" or "make Subdue".
Under Windows, the file make.bat is responsible for making the binaries.  It
is configured to be used the same way one uses the Unix make utility. It 
expects MS Visual C++ as the compiler.

To build the parallel version PVMSubdue, type "make PVMSubdue".  In order for 
this to work, PVM must be installed and configured on the system.  The
PVM_ROOT and PVM_ARCH variables must be defined.


Usage:   Subdue (or PVMSubdue) [-limit #] [-iterations #] [-threshold #]
          [-nsubs #] [-prune] [-prune2 #] [-beam #] [-overlap]
		  [-undirect] [-con connectivity] [-com compactness] [-cov coverage] 
		  [-alt] [-ps subsfile] [-size LowerBound UpperBound] [-output #]
          [-nproc #]  [-plot plotFile] [-oldeval] [-savesub] 
		  [-supervised] [-scratch] [-numpos #] [-minpercent #] [-negweight #]
		  [-cluster] [-truelabel] [-exhaust] graphfile

   [-limit #] The number of different substructures to consider in each
          iteration. Default is ( NumberOfVertices + NumberOfEdges ) / 2.
		  There is no limit set when clustering is enabled.

   [-iterations #] The number of iterations made over the input graph in
          which the best substructure from the previous iteration is used
	      to compress the graph for use in the next iteration.  Default
	      is one, which implies only one pass, no compression. If clustering
		  is set, the default is unlimited number of iterations. This can be
		  overridden by specifying the exact number of iterations using this
		  option.

   [-threshold #] The fraction of the size of an instance by which the
          instance can be different (according to the distortion
          costs) from the substructure definition.  I.e., the graphs
          match if matchcost(sub,inst) <= size(inst)*threshold.
          Default is 0.0, which implies graphs must match exactly.

   [-nsubs #] This argument specifies the maximum length of the list of best
          substructures found during the discovery.  The default value is 3.
		  If clustering is set, the default becomes 1.

   [-prune] If this argument is specified, Subdue will discard child 
          substructures that have less value than their parent substructure.
          This will greatly shrink the search space and speed up the program,
          but the discovered substructures are often smaller and less diverse.

   [-prune2 #] If this argument is specified, Subdue will detect minima in the
		  search space during the discovery process. Its integer parameter 
		  specifies how sensitive Subdue should be when detecting a minimum. 
		  This will greatly speed up the program by bailing out after finding
		  a minimum without eliminating portions of the search space (like 
		  -prune).

   [-beam #] This parameter specifies the beam width of Subdue's search.  It
          corresponds to the maximum number of classes of substructures in the
		  list of substructures waiting for expansion during the discovery 
		  process. By class we mean substructures having the same evaluation
		  value.
          Default is 4.
		  
   [-overlap] Subdue normally will not allow overlap among the instances
		  of a substructure.  Specifying this argument will allow overlap.
		  Note that when allowing overlap, compressing the instances of
		  a substructure requires extra information indicating where the
		  overlap occurs.  This tends to hinder compression due to the
		  additional bits needed to describe the overlap.  Also, if overlap
		  is allowed, substructures will have more instances, which tends
		  to inflate their heuristic value.

   [-undirect] Subdue assumes that edges in the input graph file defined
          using 'e' (and edges created to describe overlapping graphs) are
          directed edges.  Specifying this argument makes these edges
          undirected.  Note that graph file edges defined with 'u' are
          always undirected, and edges defined with 'd' are always directed.

   [-con connectivity] The exponent to the connectivity rule value of a
		  substructure and its instances.  The value measures the average
          number of connections between the instances and the rest of the
          input graph.  Default is 0.0, which implies this rule has no
          effect on the evaluation of a substructure.  A positive value
          favors substructures with low connectivity, and a negative
          value favors substructures with high connectivity.

   [-com compactness] The exponent to the compactness rule value of a
          substructure and its instances.  The value measures the average
		  compactness of the instances.  Default is 0.0, which implies this
          rule has no effect on the evaluation of a substructure.  A positive
		  value favors compact (closed) substructures, and a negative value
		  favors less dense substructures.

   [-cov coverage] The exponent to the coverage rule value of a substructure
          and its instances.  The value measures the fraction of the input
          graph covered by the instances.  Default is 0.0, which implies this
          rule has no effect on the evaluation of a substructure.  A positive
          value favors substructures with high coverage, and a negative value
	      favors substructures with low coverage.

   [-alt] If this argument is specified, Subdue will use groups of alternative
          string labels. Groups of labels may be specified anywhere in the input
          file for the global graph.  Each group specification has prefix "g",
          e.g. "g CH2 XX Y" means to consider labels CH2, XX, and Y as identical
          labels.  If option "-alt" is not specified, groups of alternative
          labels will be disregarded even if they are specified in the input
          file.

   [-ps subsfile] If this argument is specified, Subdue will search for
          predefined substructures that are specified in "subsfile".  On the
          first iteration Subdue will search the input graph for instances of
          the predefined substructures.  If more than one iteration has been
          specified, the graph is compressed with the best predefined
          substructure, and Subdue's normal substructure discovery algorithm is
          used on subsequent iterations.

   [-size Minimum Maximum] This argument is used to limit the size of
          considered/reported substructures.  Size here refers to the number of
          vertices in the substructure.  Only substructures that are larger than
          or equal to Minimum size and smaller than or equal to Maximum size
          will be inserted in the list of best substructures, and when -output
          is 2 or 3, only substructures in this size range will be printed 
          during discovery. This option is useful for stopping Subdue when 
          substructures reach Maximum size, when pruning is not activated
          (the default behavior).

   [-output #] Option controls the amount of Subdue's screen output.  Valid 
          values are:

		      1 - Print the best substructure found in the iteration. This is
			      the default for cluster analysis (-cluster).

              2 - Only print the best n substructures, where n is the value for
                  -nsubs.  This is the default output level.

              3 - Print the best n substructures, and intermediate
                  substructures as they are discovered.

              4 - Print the best n substructures with tables of instances, and
                  intermediate substructures as they are discovered.

              5 - For supervised Subdue: same as "-output 4", and also print 
                  out substructures as they are found in negative graph.

   [-nproc #] This argument specifies the number of processors on which to run
		  parallel Subdue. The PVMSubdue binary must be built to use this option;
          see the Makefile for compilation instructions. There should be a
          separate input graph file for each processor, and they should be 
          named according to the following scheme:
  
                     [root].graph.[#].part[#]

          where [root] is the common root suffix of the filenames, the first
          [#] is the number of processors, and the second [#] is the PVM group
          ID of the processor that will use this file; this number ranges from
          0 to nproc - 1. For example, if the graph is split into four 
          partitions, we would invoke Subdue with the following command:
    
                     PVMSubdue -nproc 4 example

          and with the following files in the working directory:

                     example.graph.4.part0
                     example.graph.4.part1
                     example.graph.4.part2
                     example.graph.4.part3


   [-plot plotFile] Saves information on compression to plotFile.  This file 
		  can later be used to plot this information (for example, by using Excel).

   [-oldeval] Uses the original MDL evaluation method over the newer one. The 
		  new one is the default which has been observed to behave more 
		  consistantly.

   [-savesub] Saves the best substructures and all its instances into files with
		  the following naming convention:
					
					Sub_n-i

		  where 'n' is the substructure number, and 'i' is its i-th instance.

   [-cluster] Perform cluster analysis on the input graph. Iterations with this
          option means the number of clusters to discover. This option generates
		  a file named inputFile.dot, which contains the classification lattice
		  generated by SUBDUE. It can be viewed with AT&T Bell Lab's graphviz
		  package, using dotty.

   [-truelabel] This option can be used with -cluster to print more descriptive
          node names for the classification lattice. This information is derived
		  from the definition of the subgraph the cluster corresponds to.
		  
   [-exhaust] This option can be used with -cluster to exhaustively analyze the
          graph.  That is, even if there is no compression, but there are 
		  original vertices to classify, clustering will continue.


  The following parameters apply only to supervised Subdue:

   [-supervised] Run serial Subdue as a supervised learner. In this mode, 
          Subdue discovers substructures in the graph of positive examples and 
          weights its evaluation of each substructure by the substructure's 
          value in the graph of negative examples. Both the positive and 
          negative graphs are read into the same Subdue process. The positive 
          and negative graph filenames must have the same root suffix;
          the positive graph must have extension ".pos", and the negative graph
          must have extension ".neg".  If the graph files are named 
          "example.pos" and "example.neg", we would start Subdue with the 
          command:

	  	     Subdue -supervised example

   [-scratch] Subdue's default behavior is to retain negative substructures
          in a list and extend them as their corresponding positive
          substructures are extended. If -scratch is specified, the negative
          substructures will be grown from scratch every time. This
          will increase the running time, but will reduce memory usage and
          in many cases will allow Subdue to find more fuzzy negative 
          instances.

   [-numpos #] The number of positive examples in the positive input graph.

   [-minpercent #] The fraction to multiply -numpos by to determine the minimum
          number of instances a sub must have to avoid being pruned
          from the search. If there are 20 positive examples in the positive 
          graph and we would like a sub to have at least 10 positive instances 
          if it is to be kept, we would use: -numpos 20 -minpercent 0.5

   [-negweight #] Specifies the weight of the negative example for supervised
          learning such a way that 
		  MDL = PositiveValue - (negativeWeight * NegativeValue), where 
		  PositiveValue is the sub's value in the positive graph, and 
		  NegativeValue is the sub's value in the negative graph.


Graph file format:

   Each line of a graph file defines either a vertex, an edge, or a group of
   equivalent labels.

   Vertices must be defined before they are used in edges.  Vertex lines
   have the form:

                     'v <#> <label>',
  
   where <#> is the vertex ID, and <label> is any string (no longer than 80
   characters) or numeric value with match type and match value.  Vertex IDs
   must start at 1 and must increase by 1 for each successive vertex.  For
   example, if a graph has 10 vertices, they should have vertex IDs 1 through
   10, and should appear in the graph file sorted by vertex ID.


   Numeric label format is as follows:

                     'LabelValue MatchType MatchValue',

   where LabelValue is a floating-point or integer value, MatchType is one of:
                    
                   e - for exact match 
                   t - for tolerance match (labels match if the absolute value
                        of their difference is less than MatchValue)
                   d - for difference match (match cost for two labels is 
                        ( 1.0 - exp( -1.0 * Difference * Difference /
			             ( MatchValue * MatchValue ) ) )

   and MatchValue is a floating-point or integer value.
                     
   An edge line has one of three forms: 

                     'e <v1> <v2> <label>' or
                     'd <v1> <v2> <label>' or 
                     'u <v1> <v2> <label>', 

   where <v1> and <v2> are the vertex ID's for the source vertex and the target
   vertex respectively, and <label> is any string (no longer than TOKENLEN - 1)
   or numeric value with match type and match cost.  Edges beginning with 'e' 
   are assumed directed unless parameter '-undirect' is specified at the command
   line, in which case all 'e' edges become undirected.  Edges beginning with 
   'd' are always directed, and edges beginning with 'u' are always undirected. 

   A group of equivalent string labels is specified on a single line:

                     'g label1 label2 label3 ...',

   where label1, label2 and label3 are to be regarded as being the same for the
   purpose of graph comparisons.  There can be no duplicate labels in a group,
   and a newline character cannot appear within a group.  The only limit to the
   number of labels that can be in a group is the number of unique labels in the
   graph. See the '-alt' option.
 
   Anything following the comment character ('%') on a line is ignored.

   See the files Sample.g and Sample-Run for an example of a graph file and
   the program's output when run on it.


Predefined substructures file format:

   Vertices and edges are defined as in the input graph file (above).  Each
   substructure is preceded by a line with an 's' or 'S' alone, followed by the
   vertices and edges of the substructure.  Vertex IDs for each substructure
   must start at 1 and increase by one for each vertex.  See the file Sample.ps
   for an example.


Credits:

   The Subdue system was developed at the University of Texas at Arlington by
   Dr. Lawrence B. Holder and Dr. Diane J. Cook.  Tom Lai implemented fuzzy 
   graph match.  The current implementation of the system was written mostly by 
   Gehad Galal.  Nataliya Bocharova added numeric labels, predefined 
   substructures with exact graph match, and label groups.  Ron Maglothin 
   tested and debugged the current version, added inexact graph match for 
   predefined substructures, and implemented the parallel and concept-learning
   versions. Andi Baritchi implemented probabilistic printouts for substructures.
   Istvan Jonyer did some further debugging, modified the search
   to be more efficient, and implemented clustering.


Published Subdue papers can be found at:

   http://cygnus.uta.edu/subdue/

   

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Ron Maglothin's debugging and testing notes:

2-3-98:   4.0a is a reformatted version of Nataliya Bocharova's NewFastSubdue28,
          (derived from Gehad Galal's LargeSubdue) with psdiscove.c from 
		  NewFastSubdue29.  Parameter types were added to the function 
          prototypes in subdue.h; PI2 was renamed TWO_PI, changed to 2.0 times 
          the 20-digit value for PI in the math.h library (calculated by hand in
          base 10) and moved to maths.c to avoid compiler complaints on
          Intel-Linux platforms. The type of the Godzilla Variable, GV, was 
          changed from TGlabalVariables to TGlobalVariables in all files. There
          is a type mismatch in the call to AddEdge() in the function 
          RegisterInTemplate() in tempop.c; this will be one of the first issues
          addressed in 4.0b.  Files inssort.c and sorting.c were removed.

2-8-98:	  4.0b: Removed unused variables, added DEBUG_TRACE conditional 
          compilation.  Switched from using getrusage() to using sysconf() and 
		  times() for obtaining execution timings in main.c: main().  The type
		  mismatch in the call to AddEdge() in tempop.c: RegisterInTemplate()
		  was fixed with code from Nataliya's NewFastSubdue29.

3-1-98:   4.0b: Added a statement to prntstct.c: PrintSubGraph() that prints the
          vertex index in the global graph of each substructure's first vertex.

3-2-98:   4.0.b.3: Changed prntstct.c: PrintSubGraph() to use printing modes,
          which currently include VERTICES, EDGES, and FIRST_VERTEX.

3-5-98:   4.0.c.0: Fixed a memory leak in main.c: CreateGraphTemplate() by 
          freeing arrays GV.GraphTemplate->VerticesTemplate and ->EdgesTemplate.
          Instances now printed as a table.

3-6-98:   4.0.d.0: To stop compiler warnings, did the following: removed 
          readgrph.c: PrintLabelLists(), added parentheses to && clause in
 		  compress.c: AddUncoveredEdges(), added return statements to the ends 
		  of newmatch.c: LabelMatchFactor() and SameLabel(), removed
		  predefsubop.c: PrintPredefinedSubsList().

3-17-98:  4.0.d.0: Removed BubbleSort() and GetRandomInRange() from fuzzymat.c
          for reasons of simplicity and efficiency; modified SortVertices() to
          only use QuickSortSubGraph(). Removed all GV.TraceDetails code from
          fuzzymat.c and main.c; only values 1 and 0 were used, and only in 
          FuzzyMatch(). Removed array InsertionHash from TGlobalMatchQueue and
          all code in matchq.c that referred to it (all but two of those lines
          of code were commented out earlier by someone else).

4-10-98:  4.0.d.1: This version is an aborted attempt to fix a TSubGraph memory 
          leak.  Code was added to free the TSubGraph data structures when their
          parent data structures (TSub, TExpandedInstanceE and VE, etc.) were 
          destroyed, but often there are multiple pointers pointing at a given
          SubGraph, and dereferencing one of those pointers after the SubGraph
          is destroyed crashes the program.

4-17-98:  4.0.d.2: A second, more successful fix of the TSubGraph memory leaks.
          Member RefCount was added to the TSubGraph structure, and it is 
          incremented when a new pointer is set to point to the subgraph, and 
          decremented (in nsubgpho.c: DestroySubGraph()) when such a pointer's
          parent data structure is destroyed.  The subgraph is destroyed when 
          RefCount reaches 1.  There is a 34MB per iteration memory leak when 
          running on data set pdb_model1_020698.out; while investigating this
          it became apparent that the leak occurred when compress.c: 
		  CompressUsing() fired, and that that function did not add edges from
          the original unchanged vertices to the new compressed vertex, which it
          should do.
 
4-23-98:  4.0.d.2: Removed nsubgpho.c: DestroyUnusedSubGraphs() because it was
          never called and subgraph garbage collection has already been taken
          care of with SubGraph->RefCount in nsubgpho.c: DestroySubGraph().

4-24-98:  4.0.d.2: All malloc'd data structures have been verified to have been
          freed later in the program, except for predefined substructures and 
          label groups, to be fixed later.  The iteration-related 34MB leak in
          compress.c: CompressUsing() remains, but it looks more like a memory 
          fragmentation problem rather than a leak.  This will be fixed when
          CompressUsing() is modified to add edges from the main graph vertices 
          to the compressed instances (version 4.0.e?).

4-24-98:  4.0.e.0: Moved main.c: CreateGraphTemplate() to tempop.c.  Moved
          ndiscove.c: Discover() to nsubdue.c and removed file ndiscove.c.
		  Made the following filename changes:

			newmatch.c   ->   lblmatch.c
	        nextend.c    ->   extend.c
			ngraphop.c   ->   graphop.c
			nsubdue.c    ->   subdue.c
			nsubgpho.c   ->   subgphop.c
			exptemp.c    ->   extemp.c
			psdiscove.c  ->   psdiscover.c

6-8-98:   4.0.e.0: Changed the command line parameter -minencode to -nominencode
          and  changed GV.MinEncode's default value to TRUE; i.e. the default 
          behavior is now to use the minimum graph encoding to judge the value 
          of a substructure.  Although this slows the program down 
          substantially, minimum encoding is necessary to compress the graph 
          appropriately.
          Moved graphop.c: ComputeGraphStat() to mdl.c.

6-9-98:   4.0.e.0: Moved InitialPredefinedSubs(), MatchPredefinedSub(), 
          GoodCandidate(), IsomorphicSubGraph() and EdgesMatch() from 
          predefsubop.c to psdiscover.c

6-10-98:  4.0.e.1: This version is a first attempt at implementing fuzzy graph 
          match for predefined substructures.  Removed psdiscover.c: 
	  IsomorphicSubGraph() and EdgesMatch().  Moved readgrph.c: 
	  DefineLabelType(), DefineMatchType(), PrintLabel() and GetLabelInfo()
	  to lblslist.c.  There is a segmentation fault problem when using the 
	  -ps (predefined substructures) option.

6-11-98:  4.0.e.1: Changed all occurrences of MDL in code to DL; DL is more
          semantically correct, since every Sub has a description length, but
	  only the best Sub has the minimum description length.  File mdl.c 
	  moved to dl.c; moved subgphop.c: ComputeSubGraphStat() to dl.c.

6-12-98:  4.0.e.2: Changed prntstct.c: PrintSub() to calculate compression as
          Sub->GlobalGraphCompressedWithSubDL / GV.GlobalGraphDL.  This is the
          definition for compression used in JAIR '94 (Cook & Holder).

6-16-98:  4.0.e.2: Changed main.c: main() to halt iterative compression when 
          BestSub's number of vertices is less than GV.MinSize. 

6-23-98:  4.0.e.2: The suspected compression error described on 4-17-98 turned
          out to be false; the graph is compressed correctly.  There is still a 
          memory fragmentation problem that is related to iterative compression
          of large graphs.

6-24-98:  4.0.e.3: The predefined substructures segmentation fault has been 
          fixed by saving the values of GV.NumberOfVerticesLabels and 
          GV.NumberOfNumericVerticesLabels before compressing the graph in
          eval.c: EvaluateSub() and restoring those values after compression is
          completed.

7-9-98:   4.0.f.0: Moved command line parsing from main.c: main() to main.c:
          ParseCommandLine()

7-17-98:  4.0.f.0: Cleaned up output and added -output option to control the
          amount of output the program generates. This version was released to 
          the public.

7-21-98  4.0.f.1: Added UNIX conditional compilation and fixed some union 
         assignment problems in tempop.c: RegisterInTemplate() so that the
         system now compiles under Microsoft Visual C++ 5.0.  Modified 
         prntstct.c: PrintSub() to output size and compression in terms of
         size when -nominencode option is  used.  Changed tempop.c: 
         CreateGraphTemplate() to use realloc, but this did not fix the 
         iteration-related memory fragmentation. 

7-27-98  4.0.f.2: Changed description length calculation in dl.c and eval.c to 
         mark the vertices and edges in the substructure instances so that 
         global graph compression is not necessary.  Accounting for overlapping
         instances was not implemented, and the program took ~4 times as long to
         run; this approach will not be kept in future versions.

///////// MINOR Version change: 4.1

8-13-98  4.1.a.0: Version 4.1 will include the parallel Subdue implementation
         using PVM.  Conditional compilation is used to select sequential or
         parallel Subdue, using the -D_PVM_SUBDUE_ flag in the Makefile.
         The parallel implementation is taken from Gehad Galal's LargePVMSubdue;
         it needs to be modified to use Nataliya's label handling code.

9-2-98   4.1.a.1: Fixed two memory leaks: added "DestroySub( CurrentSub )" to 
         subdue.c: Subdue() and removed "NewSubGraph->RefCount++" from 
         extemp.c: CreateVEInstanceSubGraph().

9-5-98   4.1.a.1: Fixed two memory leaks: added DestroySubGraph( NewInstance ) 
         in several places in extemp.c: AddVENoise() and AddENoise(), and 
         modified matchq.c: AddLocalMatches() to preserve dummy queue nodes.

9-8-98   4.1.a.1: Modified graphop.c, compress.c, and main.c to keep the entire
         ScratchGraph allocated when using minimum encoding in order to 
         waste less time mallocing and freeing the memory for graph
         compression.  This caused the program to use much more memory, as the 
         Edges and FanInVertices arrays for many vertices had to be expanded for
         each graph compression.  This approach will be abandoned.

9-8-98   4.1.a.2: This is the code from version 4.1.a.1 with compress.c and 
         graphop.c from 4.0.f.1 and other changes to use Gehad's methods of
         graph compression (i.e. destroying the entire graph after each 
         description length compression).

9-9-98   4.1.b.0: Minor changes to output; released to Dr. Holder.

9-12-98  4.1.b.1: Began integrating Gehad's parallel Subdue code into this 
         version; not yet functional.  Fixed a minor memory leak in fuzzymat.c:
         FuzzyMatch() (destroyed ExpandingNode after fuzzy match is finished) 
         and fixed a bug in matchq.c: RemoveNextLocalMatchNode() to preserve
         dummy queue nodes.  Predefined substructures don't work; vertex ID's 
         that differ from the GlobalGraph's will crash the program.  Predefined
         substructures code will be rewritten later to use Galal's AbstractSubs
         and subdue.c: DiscoverAbstractSub().

9-15-98  4.1.b.2: Modified/rewrote much of Nataliya's label handling code; 
         string and numeric labels are now all stored in the array GV.LabelList.
         Only the index of the appropriate label is stored in the SubGraphs.
         Files lblslist.c and lblmatch.c were replaced by labels.c.
         Modified readgrph.c to print out the bad line of the graph file when
         a graph input error occurs.

9-26-98  4.1.c.0: Predefined substructure search was implemented using Gehad's
         DiscoverAbstractSub() code.  Added file abstract.c.

9-30-98  4.1.c.1: Fixed a rare segmentation fault problem in extemp.c:
		 FastCompare() caused by NODE_DELETED values (defined to be -2) in the
         unsigned int arrays First and Second (NODE_DELETED became > 4 billion).
		 Changed all variables and arrays that might hold a NODE_DELETED value
		 (First[], Second[], PTSubGraph->MatchingOrder[] and 
		 PTVETemplate->SourceVertexMatchIndex) to type TInteger in files 
		 extemp.c, fuzzymat.c, and matchq.c, and added code to extemp.c:
		 FastCompare() to handle values of NODE_DELETED gracefully.

10-6-98  4.1.c.2: Changed subdue.c: Discover() to use two substructure lists.
         Substructures to be expanded are taken from the head of SubsList1, and
         all expanded children are inserted in SubsList2, ordered by Value. When
         SubsList1 has been emptied, SubsList1 and SubsList2 are switched. This
         gives each substructure a chance to be expanded, and all its children
         are in competition with children of their own "generation", which
         causes a wide variety of substructures to be considered. Under the old
	     method, newly expanded children almost always had a higher value than
         the "older" substructures on the list, so the old ones were pushed off,
         and the beam search actually focused on the descendents of the first
         substructure on the original list. The alternative value heuristic to
         MDL was also changed to value large subs with fewer instances higher 
         than smaller subs with more instances. In this version, Sub->Value =
         pow( SizeOf( Sub->Definition ), 3.0 ) * Sub->Instances->CurrentLength. 

10-19-98 4.1.c.3: Parallel version is working, but needs polishing and memory
         leak checking.  In this version, Sub->Value =
		 pow( SizeOf( Sub->Definition ), 2.0 ) + 
		 sqrt( Sub->Instances->CurrentLength ).

10-19-98 4.1.c.4: This version is 4.1.c.3 with execution timings for discovery
         functions GetBestSubs(), ExtendInstances(), GetStrongClasses(), 
         FuzzyMatch(), AddENoise(), and AddVENoise().  This is an attempt to 
         find which part of the discovery process takes so much longer as 
         substructures get larger.

10-20-98 4.1.d.0: Changed -output option to use 3 levels instead of 4. Removed
         -ssbeam option and set GV.SSBeamLength to GV.BeamLength.  Changed 
         option -noprune to -prune and made no pruning the default behavior.

11-7-98  4.1.d.1: Release version.

11-9-98  4.1.e.0: Added Positive/Negative Subdue functionality. Iterations not
         supported.

11-14-98 4.1.f.0: Versions 4.1.f.x are experimental modifications to the 
         substructure expansion code to improve performance and effectiveness of
         the search for fuzzy substructure instances. In 4.1.f.0, extemp.c:
         AddVENoise() and AddENoise() have been modified to use fuzzy match on
         all of the expansion templates. This greatly increases running time,
         but seems to improve numeric label matching. Alternative string label
         matching is still not working.

11-19-98 4.1.f.1: Implemented mapped fuzzy subgraph matching, which runs
         in time linear in the size of the subgraphs.  Only works for linear
         graphs (e.g. DNA) with directed edges.  Predefined substructure search
         not supported yet.

12-20-98 4.1.f.2: Made the 4.1.e.1 and 4.1.e.2 changes to 4.1.f.2. 
         Implemented mapped fuzzy match for predefined substructure search, as
         well as Positive/Negative functionality, to be referred to hereafter as
         concept learning, or CLSubdue.

12-29-98 4.1.f.3: Made substantial changes to CLSubdue. 4.1.f.2 starts the
         search for substructure instances in the negative graph from scratch 
         every time, thus redoing all the work it did previously in finding the
         instances of the substructure's parent. In concept.c, the negative
         process now stores the negative substructures in a list, and each is
         identified with an unsigned integer which represents the memory address
         of the corresponding Sub in the positive process. When the positive 
         process sends an abstract sub of the Sub it wants evaluated in the
         negative graph, it also send the address of the corresponding sub's
         parent as well as vertex and edge maps that map the parent's abstract
         sub to the new abstract sub.  The negative process can then find the
         corresponding negative sub in its list, use the mappings to set the 
         Covered values for the new abstract sub, and resume the predefined
         substructure search from the point it left off for the parent. Uses
         more memory, but saves much time, especially as the substructure
         definitions get large.

1-13-99  4.1.f.4: Changed eval.c: EvaluateSub() to normalize Sub->Value by 
         dividing it by GV.GlobalGraphDL, then taking the reciprocal. This 
         should get MDL heuristic values out of the 1.0e-6 range.  Changed type
         TReal from float to double for greater precision. Changed extemp.c:
		 AddFuzzyVEInstances() and AddFuzzyEInstances() to include instances
         whose MatchCost <= 1.0  and whose Size > 1 when GV.MatchCostMaxPercent
         > 0.0 . This pulls in instances with one distortion whose Size *
         GV.MatchCostMaxPercent < 1. 

12-7-98  4.1.e.1: Changed main.c and pvm.c to call CreateGraphTemplate() after 
         creating an abstract sub from a pvm message or a predefined 
         substructures file.  This is to avoid a segmentation fault in 
         extemp.c: DestroyExpTemp() when the graph template array is not as
         large as the LabelList.

12-19-98 4.1.e.2: Fixed a segmentation fault problem in PVMSubdue by changing
         pvm.c: Communicate() to test for NULL values in GV.BestSubAtProc[]
         before dereferencing its pointers.

1-13-99  4.1.e.3: Modified the changes of 12-7-98 to only reallocate the
         GV.ExpandTemplates array when a new label has been added to the label
         list (from a new abstract sub).

1-15-99  4.1.e.3: Changed eval.c: EvaluateSub() to calculate Sub->Value as the
         inverse of the Sub's graph compression value.  This effectively 
         "normalizes" Sub->Value to be always greater than 0, usually less than
         2, and less than 1 when the Sub does not compress the graph. This also 
         eliminates the problem in CLSubdue that arises when no instances of Sub
         are found in the negative graph. When this happened in previous
         versions, the negative process would return a value of 0 to the 
         positive process, and the positive process would not divide its 
         Sub->Value by anything, which would put that Sub's Value in the 1.0e-6
         range (using minimum encoding) instead of the 1.0e+0 range of the Subs
         that had instances in the negative graph. In this version, the negative
         process returns 1.0 when no instances are found. Type TReal was changed
         from float to double, for greater precision in heuristic calculation.

1-23-99  4.1.f.5: Changed concept.c: FindInstancesOfNegativeSub() to return
		 2.0 * GV.GlobalGraphDL() when no instances of the abstract sub are 
         found in the negative graph.  Also changed "Index++" to "Index--" in
		 abstract.c: AddEdgeToAbstractSub(), line 267, to stop segmentation
         faults when using -ps option.

2-6-99   4.1.e.3: Added a call to extemp.c: GetStrongClasses() in subdue.c:
         DiscoverTargetSub(). The search for AbstractSub instances was missing
         some instances of substructures whose definition had several isomorphic
         vertices; hopefully this will fix that problem. Also, CLSubdue's
         heuristic value calculation was modified; the negative process now
         returns 2.0 * GV.GlobalGraphDL when no instances of the sub are found
         in the negative graph.

2-8-99   4.1.e.4: Made substantial changes to CLSubdue. 4.1.e.3 starts the
         search for substructure instances in the negative graph from scratch 
         every time, thus redoing all the work it did previously in finding the
         instances of the substructure's parent. In concept.c, the negative
         process now stores the negative substructures in a list, and each is
         identified with an unsigned integer which represents the memory address
         of the corresponding Sub in the positive process. When the positive 
         process sends an abstract sub of the Sub it wants evaluated in the
         negative graph, it also send the address of the corresponding sub's
         parent as well as the definition indices of the vertex and edges that
         have been added to the new sub.  The negative process can then find the
         corresponding negative sub in its list, use the indices to set the 
         Covered values for the new abstract sub, and resume the predefined
         substructure search from the point it left off for the parent. Uses
         more memory, but saves much time, especially as the substructure
         definitions get large. Also changed eval.c: EvaluateSub() to calculate
         substructure values using the equations adopted by Dr. Cook in her
         code; see that function's header for details.

2-9-99   4.1.g.0: This is 4.1.e.4 with minor modifications to make the system
         more usable for DNA analysis. Added prntstct.c: PrintPattern() to
         print the DNA pattern a subgraph represents, as well as the -numpos and
         -minpercent command line options to specify the minimum number of
         instances a substructure must have to be kept for expansion in
		CLSubdue.

2-15-99  4.1.g.1: Fixed the numeric edge label and string label groups problems
         by modifying extemp.c: CreateSubFromVETemplate() and 
		 CreateSubFromETemplate(). All templates are now searched for matching
         labels on identical expansions, so instances with different yet 
         matchable labels are now included in a substructure without resorting
		 to fuzzy match.

///////// MINOR Version change: 4.2

2-20-99  4.2.a.0: Subdue 4.2 is the new version number for the system; it 
         reflects the fact that concept-learning functionality has been 
         extensively tested and improved, and is now ready for the public.
         This version is the same as 4.1.g.1, with a bug fix in the concept.c
         communication functions; numeric labels are now packed as doubles 
         instead of floats.

3-1-99   4.2.a.1: Modified dl.c: GraphDL() and SubGraphDL() to use 
         GV.NumberOfVertexLabels for VerticesBits and GV.NumberOfEdgeLabels 
         for EdgesBits in description length calculation.

3-2-99   4.2.a.2: Modified tempop.c: RegisterInTemplate() to heavily penalize
         overlapping substructures by adding a new edge label for each 
         edge shared between two substructures. Adding all these labels to the
         label list severely degraded performance, so a dummy label is added for
         the first overlapped edge, and GV.NumberOfEdgeLabels is incremented for
         all the others. It turned out that this penalty was too severe and 
         hindered the discovery, so it will be abandoned.

3-5-99   4.2.b.0: Changed heuristic evaluation of substructures to base the 
         heuristic value on the graph compression. See eval.c: EvaluateSub()
         function header.

3-16-99  4.2.b.1: Corrected handling of undirected edges in predefined subs
         by modifying abstract.c: AddEdgeToAbstractSub().

3-18-99  4.2.c.0: Modified nearly all the code to pass a pointer to a 
         TGraphVar structure, rather than access a global structure GV.
         This allows supervised Subdue (old CLSubdue) to run as a single
         process; no more PVM! Parallel version does not support -supervised
         option yet.

3-24-99  4.2.c.1: Changed supervised heuristic; concept.c: GetNegativeValue()
         returns DL(Gneg) / ( DL(S) + DL(Gneg) ) when no negative instances are
         found.

3-26-99  4.2.c.2: Changed Gehad's heuristic to not add edges to the compressed
         graph to describe (penalize) instance overlaps.

3-31-99  4.2.c.3: Changed supervised heuristic to multiply NegativeValue by
         NegativeWeight.

3-31-99  4.2.c.4: This is 4.2.c.0 with the 4.1.e.4 supervised heuristic 
         calculation.

4-1-99   4.2.c.5: 4.2.c.3 with new supervised heuristic: 
         Value = PositiveValue - ( NegativeWeight * NegativeValue )
		 Also, iterations continue even if the best sub does not compress the
         graph ( main.c: main() ).

4-3-99   4.2.c.5: Added accounting of GV->NumberOfUndirectedEdges to correct
         calculation of Gehad's size heuristic.

4-7-99   4.2.c.6: In concept.c: GetNegativeValue(), temporarily increased
         NegativeGraph->NumberOfVertexLabels by 1 before calculating 
         DL(Gneg|S) when there are no negative instances. This is so that a 
         substructure with one instance will have a slightly higher negative 
         value than a substructure with no negative instances. The added label
         is for the compressed-instance vertex label.

/////////////////////////////////////////////////////////////////////////////////

Istvan Jonyer's notes:

6-18-99		4.2.c.7: Converted code to comply with new coding standards. Removed 
			unused variables and functions.

6-23-99		4.2.c.7: Modified the PVM part of the code to compile. It now 
			compiles with Ron's new graph variables structure. (Testing of the 
			code is still required!)

7-1-99		4.2.c.7: Looks like the PVM part of the code works fine.

7-9-99		4.2.c.7: Added function LoadDefaultGraphParameters to do just that.
				Added memory management macros Malloc, Calloc, Realloc and Free. 
			All of these replace themselves with the corresponding library call, 
			and in addition, free will also set the freed pointer to NULL. This
			allows replacing the if/else malloc/realloc style memory allocation
			to be just realloc.  (Garbage collection should be considered later.)
				Removed exit()'s all over the program, and replaced it with 
			ErrorFatal(message), which also calls pvm_exit() if needed.

7-10-99		4.2.c.7: Replaced all occurrences of debug trace printouts that had
			hardcoded filenames in it with __FILE__ directive.

7-10-99		4.2.c.8: Modularized command line argument parsing.

7-13-99		4.2.c.8: -plot command line argument added.  See manual for details.

7-23-99		4.2.c.8: -cluster command line argument added.  
			Switching to 4.2.d.1 to continue developing cluster analysis.

7-24-99		4.2.d.1: -cluster option generates classification lattice and prints 
			it sideways in preorder.

7-28-99		4.2.d.1: -cluster option generates <input file name>.dot file which
			describes the classification lattice in AT&T Bell Lab's "dot" format.
			Use "dotty" to view the lattice.

8-05-99		4.2.d.1: Added new output level: 1. Shifted all other output levels
			up, making the default 2. This new output level is used for cluster
			analysis.

8-09-99		4.2.d.1: BUG: Dr. Holder discovered a bug in Base2LogOfFact(), which
			has been fixed. This bug altered the minimum description length in 
			an adverse way,	since at least version 3.4.

8-12-99		4.2.d.1: Added efficiency hack to Base2Log(), Base2LogOfFact(), and 
			Base2LogOfComb() functions.

8-12-99		4.2.d.2: Removed commented out parts (4.2.c.8) from ParseCommandLine().
			Added timing in WIN32.
			Added lookup table for lg n! computation. Phased out Base2LogOfFact(),
			and Base2LogOfComb() functions, which only approximated the results,
			and calculated them each time.  Result is seeeeedup!!!
			New type of BOOLEAN (unsigned char) is added to replace BOOL (int).

RELEASE: 8-16-99   4.2.d.2R: This is the latest release version thus far, 
                             released today.


8-17-99		4.2.d.3: -truelabel option is added (described above).  Also, the 
			definition of the subgraph the cluster is derived from is not copied
			into the classification lattice node anymore (code commented out),
			since I have not found any useful purpose of doing so.
				-exhaust option is added (described above).
				-prune2 option is added (described above).

8-25-99		4.2.d.4: BUG discovered: incorrect calculation of the description
			length for Sub's and AbstractSub's.

RELEASE: 8-25-99   4.2.d.4R: This is the latest release version thus far, 
                             prompted by the bug fix.

8-27-99		4.2.d.5: Modified beam-search such that there are only "maxLength" 
			number of different values represented by all the subs in the queue.
			This opens up the search space and removes the arbitrariness of the
			beam search algorithm.  As a result, however, there is a slowdown
			in performance, as Subdue has to consider more subs.
				Observation: the "-prune2 1" command line argument is equivalent
			to -prune, but with the removal of the "prune bug".
				When -prune2 is set, the "-limit" is removed.
				Changed label of root node of the classification lattice from 
			ROOT to the filename capitalized, and .'s, -'s, \'s, and /'s 
			replaced with _'s (since graphviz cannot handle those in node 
			labels).

9-3-99		4.2.d.5: -prune2 1 is default for clustering.  It still can be 
			overwritten by the command line arguments.

9-7-99:		4.2.d.5: Fixed classification lattice printing bug.

9-8-99:		4.2.d.6: Start tweaking template beam length.

9-14-99:	4.2.d.6: -subbeam option is introduced.  Default is 1.

9-14-99:	4.2.d.7: -subbeam option is taken out by side commenting it.  

9-21-99		4.2.d.7: Changed representation of undirected edges.  Changes are
			labeled with //{U}.  Now undirected edges are just like directed 
			ones, but the 'directed' flag is set to false.

10-1-99:	4.2.d.8: Added GraphSubDL() to compute the description length of the
			graph compressed with the substructre as one graph (vs. 2 separate
			graphs).

10-10-99:	4.2.d.8: Added PurgeBestSub() to remove subs from the expansion Q that
			would eventually result in the same sub--this way reducing the search
			space. This actually has the potential to reduce the search space from
			exponential growth to linear growth!

10-28-99:	4.2.d.8: Fixed bugs in PurgeBestSub(), and it looks fine at the moment.

11-12-99:	4.2.d.8: Replaced %u with %lu for printing ULONG's.

11-19-99:	4.2.d.8: Added UpdateLabels() to do away with labels not used after
			compression.

2-10-00:	4.2.d.8: Added option -oldeval to use Dr. Holder's evaluation insted of
			mine. (mine is the default)
			Removed the -nominencode option.

2-17-00:	4.2.d.8: -prune2 2 is default for clustering (replacing -prune2 1)

2-22-00:	4.2.d.9: Added option -savesub, and function SaveSub() to save the best
			substructure in each iteration into a file called Sub_#-i.

4-18-00:	4.3.a.1: Version 4.2.d.9 has been renamed.

5-01-00:	4.3.a.1: Added Andi Baritchi's modifications.

RELEASE: 5-02-00:  4.3.a.1R  This is the latest release version thus far.


